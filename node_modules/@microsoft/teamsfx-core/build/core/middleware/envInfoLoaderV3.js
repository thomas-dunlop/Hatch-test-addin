"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadEnvInfoV3 = exports.EnvInfoLoaderMW_V3 = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../component/constants");
const constants_2 = require("../../plugins/solution/fx-solution/v3/constants");
const crypto_1 = require("../crypto");
const environment_1 = require("../environment");
const error_1 = require("../error");
const globalVars_1 = require("../globalVars");
const envInfoLoader_1 = require("./envInfoLoader");
const projectSettingsLoader_1 = require("./projectSettingsLoader");
function EnvInfoLoaderMW_V3(skip) {
    return async (ctx, next) => {
        var _a, _b, _c, _d;
        if (projectSettingsLoader_1.shouldIgnored(ctx)) {
            await next();
            return;
        }
        const inputs = ctx.arguments[ctx.arguments.length - 1];
        if (!ctx.projectSettings) {
            ctx.result = teamsfx_api_1.err(error_1.ProjectSettingsUndefinedError());
            return;
        }
        if (!inputs.projectPath) {
            ctx.result = teamsfx_api_1.err(new error_1.NoProjectOpenedError());
            return;
        }
        // make sure inputs.env always has value so telemetry can use it.
        if (inputs.stage === teamsfx_api_1.Stage.debug)
            inputs.ignoreEnvInfo = false; // for local debug v3, envInfo should not be ignored
        const envRes = await envInfoLoader_1.getTargetEnvName(skip, inputs, ctx);
        if (envRes.isErr()) {
            ctx.result = teamsfx_api_1.err(envRes.error);
            return;
        }
        inputs.env = envRes.value;
        const result = await loadEnvInfoV3(inputs, ctx.projectSettings, inputs.env, skip || inputs.ignoreEnvInfo);
        if (result.isErr()) {
            ctx.result = teamsfx_api_1.err(result.error);
            return;
        }
        ctx.envInfoV3 = result.value;
        envInfoLoader_1.upgradeProgrammingLanguage(ctx.envInfoV3.state, ctx.projectSettings);
        envInfoLoader_1.upgradeDefaultFunctionName(ctx.envInfoV3.state, ctx.projectSettings);
        // set globalVars for teamsAppId and m365TenantId
        const appManifestKey = globalVars_1.isV3()
            ? constants_1.ComponentNames.AppManifest
            : constants_2.BuiltInFeaturePluginNames.appStudio;
        globalVars_1.globalVars.teamsAppId = (_b = (_a = ctx.envInfoV3.state) === null || _a === void 0 ? void 0 : _a[appManifestKey]) === null || _b === void 0 ? void 0 : _b.teamsAppId;
        globalVars_1.globalVars.m365TenantId = (_d = (_c = ctx.envInfoV3.state) === null || _c === void 0 ? void 0 : _c[appManifestKey]) === null || _d === void 0 ? void 0 : _d.m365TenantId;
        await next();
    };
}
exports.EnvInfoLoaderMW_V3 = EnvInfoLoaderMW_V3;
async function loadEnvInfoV3(inputs, projectSettings, targetEnvName, ignoreEnvInfo = false) {
    const cryptoProvider = new crypto_1.LocalCrypto(projectSettings.projectId);
    let envInfo;
    // in pre-multi-env case, envInfo is always loaded.
    if (ignoreEnvInfo) {
        envInfo = environment_1.newEnvInfoV3();
        envInfo.envName = "";
    }
    else {
        // ensure backwards compatibility:
        // project id will be generated for previous TeamsFx project.
        // Decrypting the secrets in *.userdata with generated project id works because secrets doesn't have prefix.
        const envDataResult = await environment_1.environmentManager.loadEnvInfo(inputs.projectPath, cryptoProvider, targetEnvName, true);
        if (envDataResult.isErr()) {
            return teamsfx_api_1.err(envDataResult.error);
        }
        envInfo = envDataResult.value;
    }
    return teamsfx_api_1.ok(envInfo);
}
exports.loadEnvInfoV3 = loadEnvInfoV3;
//# sourceMappingURL=envInfoLoaderV3.js.map