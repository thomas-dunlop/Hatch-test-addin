"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsV2 = exports.getQuestionsForUserTaskV2 = exports.getQuestionsForCreateProjectV2 = exports.getQuestionsForCreateProjectV3 = exports.getQuestionsForInit = exports.getQuestionsForPublish = exports.getQuestionsForDeploy = exports.getQuestionsForProvision = exports.getQuestionsForUserTaskV3 = exports.getQuestionsForAddFeature = exports.traverseToCollectPasswordNodes = exports.desensitize = exports.QuestionModelMW = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../common/tools");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const question_1 = require("../../plugins/solution/fx-solution/question");
const collaborator_1 = require("../collaborator");
const error_1 = require("../error");
const globalVars_1 = require("../globalVars");
const question_2 = require("../question");
const SolutionPluginContainer_1 = require("../SolutionPluginContainer");
const common_1 = require("../../common");
const questionV3_1 = require("../../component/questionV3");
const spfx_1 = require("../../component/feature/spfx");
/**
 * This middleware will help to collect input from question flow
 */
const QuestionModelMW = async (ctx, next) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const method = ctx.method;
    const core = ctx.self;
    let getQuestionRes = teamsfx_api_1.ok(undefined);
    if (method === "createProjectV2") {
        getQuestionRes = await core._getQuestionsForCreateProjectV2(inputs);
    }
    else if (method === "createProjectV3") {
        getQuestionRes = await core._getQuestionsForCreateProjectV2(inputs);
    }
    else if (method === "init" || method === "_init") {
        getQuestionRes = await core._getQuestionsForInit(inputs);
    }
    else if ([
        "addFeature",
        "_addFeature",
        "provisionResourcesV3",
        "deployArtifactsV3",
        "publishApplicationV3",
        "executeUserTaskV3",
    ].includes(method || "")) {
        const solutionV3 = ctx.solutionV3;
        const contextV2 = ctx.contextV2;
        if (solutionV3 && contextV2) {
            if (method === "addFeature" || method === "_addFeature") {
                getQuestionRes = await core._getQuestionsForAddFeature(inputs, solutionV3, contextV2);
            }
            else if (method === "provisionResourcesV3") {
                getQuestionRes = await core._getQuestionsForProvision(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
            else if (method === "deployArtifactsV3") {
                getQuestionRes = await core._getQuestionsForDeploy(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
            else if (method === "publishApplicationV3") {
                getQuestionRes = await core._getQuestionsForPublish(inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
            else if (method === "executeUserTaskV3") {
                const func = ctx.arguments[0];
                getQuestionRes = await core._getQuestionsForUserTaskV3(func, inputs, solutionV3, contextV2, ctx.envInfoV3);
            }
        }
    }
    else if (method === "grantPermissionV3") {
        getQuestionRes = await collaborator_1.getQuestionsForGrantPermission(inputs);
    }
    else {
        if (ctx.solutionV2 && ctx.contextV2) {
            const solution = ctx.solutionV2;
            const context = ctx.contextV2;
            if (solution && context) {
                if (method === "provisionResources" || method === "provisionResourcesV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.provision, inputs, ctx.envInfoV2);
                }
                else if (method === "localDebug" || method === "localDebugV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.debug, inputs, ctx.envInfoV2);
                }
                else if (method === "deployArtifacts" || method === "deployArtifactsV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.deploy, inputs, ctx.envInfoV2);
                }
                else if (method === "publishApplication" || method === "publishApplicationV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.publish, inputs, ctx.envInfoV2);
                }
                else if (method === "executeUserTaskV2") {
                    const func = ctx.arguments[0];
                    getQuestionRes = await core._getQuestionsForUserTask(context, solution, func, inputs, ctx.envInfoV2);
                }
                else if (method === "grantPermissionV2") {
                    getQuestionRes = await core._getQuestions(context, solution, teamsfx_api_1.Stage.grantPermission, inputs, ctx.envInfoV2);
                }
            }
        }
    }
    if (getQuestionRes.isErr()) {
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.error(`[core] failed to get questions for ${method}: ${getQuestionRes.error.message}`);
        ctx.result = teamsfx_api_1.err(getQuestionRes.error);
        return;
    }
    globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.debug(`[core] success to get questions for ${method}`);
    const node = getQuestionRes.value;
    if (node) {
        const res = await teamsfx_api_1.traverse(node, inputs, globalVars_1.TOOLS.ui, globalVars_1.TOOLS.telemetryReporter);
        if (res.isErr()) {
            globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.debug(`[core] failed to run question model for ${method}`);
            ctx.result = teamsfx_api_1.err(res.error);
            return;
        }
        const desensitized = desensitize(node, inputs);
        globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider.info(`[core] success to run question model for ${method}, answers:${JSON.stringify(desensitized)}`);
    }
    await next();
};
exports.QuestionModelMW = QuestionModelMW;
function desensitize(node, input) {
    const copy = tools_1.deepCopy(input);
    const names = new Set();
    traverseToCollectPasswordNodes(node, names);
    for (const name of names) {
        copy[name] = "******";
    }
    return copy;
}
exports.desensitize = desensitize;
function traverseToCollectPasswordNodes(node, names) {
    if (node.data.type === "text" && node.data.password === true) {
        names.add(node.data.name);
    }
    for (const child of node.children || []) {
        traverseToCollectPasswordNodes(child, names);
    }
}
exports.traverseToCollectPasswordNodes = traverseToCollectPasswordNodes;
//////V3 questions
async function getQuestionsForAddFeature(inputs, solution, context) {
    if (solution.getQuestionsForAddFeature) {
        const res = await solution.getQuestionsForAddFeature(context, inputs);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForAddFeature = getQuestionsForAddFeature;
async function getQuestionsForUserTaskV3(func, inputs, solution, context, envInfo) {
    if (solution.getQuestionsForUserTask) {
        const res = await solution.getQuestionsForUserTask(context, inputs, func, envInfo, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForUserTaskV3 = getQuestionsForUserTaskV3;
async function getQuestionsForProvision(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForProvision) {
        const res = await solution.getQuestionsForProvision(context, inputs, envInfo, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForProvision = getQuestionsForProvision;
async function getQuestionsForDeploy(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForDeploy) {
        const res = await solution.getQuestionsForDeploy(context, inputs, envInfo, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForDeploy = getQuestionsForDeploy;
async function getQuestionsForPublish(inputs, solution, context, envInfo) {
    if (solution.getQuestionsForPublish) {
        const res = await solution.getQuestionsForPublish(context, inputs, envInfo, globalVars_1.TOOLS.tokenProvider.m365TokenProvider);
        return res;
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForPublish = getQuestionsForPublish;
async function getQuestionsForInit(inputs) {
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForInit = getQuestionsForInit;
async function getQuestionsForCreateProjectV3(inputs) {
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForCreateProjectV3 = getQuestionsForCreateProjectV3;
async function setSolutionScaffoldingQuestionNodeAsChild(inputs, parent) {
    const globalSolutions = await SolutionPluginContainer_1.getAllSolutionPluginsV2();
    const context = tools_1.createV2Context(projectSettingsHelper_1.newProjectSettings());
    for (const solutionPlugin of globalSolutions) {
        let res = teamsfx_api_1.ok(undefined);
        const v2plugin = solutionPlugin;
        res = v2plugin.getQuestionsForScaffolding
            ? await v2plugin.getQuestionsForScaffolding(context, inputs)
            : teamsfx_api_1.ok(undefined);
        if (res.isErr())
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError({ source: error_1.CoreSource, name: "QuestionModelFail", error: res.error }));
        if (res.value) {
            const solutionNode = Array.isArray(res.value)
                ? res.value
                : [res.value];
            for (const node of solutionNode) {
                if (node.data) {
                    parent.addChild(node);
                }
            }
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
async function getQuestionsForCreateProjectWithoutDotNet(inputs) {
    const node = new teamsfx_api_1.QTreeNode(question_2.getCreateNewOrFromSampleQuestion(inputs.platform));
    // create new
    const createNew = new teamsfx_api_1.QTreeNode({ type: "group" });
    node.addChild(createNew);
    createNew.condition = { equals: question_2.ScratchOptionYes.id };
    // capabilities
    let capNode;
    if (common_1.isPreviewFeaturesEnabled()) {
        const capQuestion = question_2.createCapabilityQuestionPreview();
        capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    }
    else {
        const capQuestion = question_2.createCapabilityQuestion();
        capNode = new teamsfx_api_1.QTreeNode(capQuestion);
    }
    createNew.addChild(capNode);
    if (!globalVars_1.isV3()) {
        const solutionNodeResult = await setSolutionScaffoldingQuestionNodeAsChild(inputs, capNode);
        if (solutionNodeResult.isErr()) {
            return teamsfx_api_1.err(solutionNodeResult.error);
        }
    }
    else {
        const triggerNodeRes = await questionV3_1.getNotificationTriggerQuestionNode(inputs);
        if (triggerNodeRes.isErr())
            return teamsfx_api_1.err(triggerNodeRes.error);
        if (triggerNodeRes.value) {
            capNode.addChild(triggerNodeRes.value);
        }
        const spfxNode = await spfx_1.getSPFxScaffoldQuestion();
        if (spfxNode) {
            spfxNode.condition = { equals: question_1.TabSPFxItem.id };
            capNode.addChild(spfxNode);
        }
    }
    // Language
    const programmingLanguage = new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestion);
    if (common_1.isPreviewFeaturesEnabled()) {
        programmingLanguage.condition = {
            notEquals: question_1.ExistingTabOptionItem.id,
        };
    }
    else {
        programmingLanguage.condition = {
            minItems: 1,
            excludes: question_1.ExistingTabOptionItem.id,
        };
    }
    capNode.addChild(programmingLanguage);
    // existing tab endpoint
    if (tools_1.isExistingTabAppEnabled()) {
        const existingTabEndpoint = new teamsfx_api_1.QTreeNode(question_2.ExistingTabEndpointQuestion);
        existingTabEndpoint.condition = {
            equals: question_1.ExistingTabOptionItem.id,
        };
        capNode.addChild(existingTabEndpoint);
    }
    createNew.addChild(new teamsfx_api_1.QTreeNode(question_2.QuestionRootFolder));
    createNew.addChild(new teamsfx_api_1.QTreeNode(question_2.createAppNameQuestion()));
    // create from sample
    const sampleNode = new teamsfx_api_1.QTreeNode(question_2.SampleSelect);
    node.addChild(sampleNode);
    sampleNode.condition = { equals: question_2.ScratchOptionNo.id };
    sampleNode.addChild(new teamsfx_api_1.QTreeNode(question_2.QuestionRootFolder));
    return teamsfx_api_1.ok(node.trim());
}
async function getQuestionsForCreateProjectWithDotNet(inputs) {
    const runtimeNode = new teamsfx_api_1.QTreeNode(question_2.getRuntimeQuestion());
    const maybeNode = await getQuestionsForCreateProjectWithoutDotNet(inputs);
    if (maybeNode.isErr()) {
        return teamsfx_api_1.err(maybeNode.error);
    }
    const node = maybeNode.value;
    if (node) {
        node.condition = {
            equals: question_2.RuntimeOptionNodeJs.id,
        };
        runtimeNode.addChild(node);
    }
    const dotnetNode = new teamsfx_api_1.QTreeNode({ type: "group" });
    dotnetNode.condition = {
        equals: question_2.RuntimeOptionDotNet.id,
    };
    runtimeNode.addChild(dotnetNode);
    const dotnetCapNode = new teamsfx_api_1.QTreeNode(question_2.createCapabilityForDotNet());
    dotnetNode.addChild(dotnetCapNode);
    if (!globalVars_1.isV3()) {
        const solutionNodeResult = await setSolutionScaffoldingQuestionNodeAsChild(inputs, dotnetCapNode);
        if (solutionNodeResult.isErr()) {
            return teamsfx_api_1.err(solutionNodeResult.error);
        }
    }
    else {
        const triggerNodeRes = await questionV3_1.getNotificationTriggerQuestionNode(inputs);
        if (triggerNodeRes.isErr())
            return teamsfx_api_1.err(triggerNodeRes.error);
        if (triggerNodeRes.value) {
            dotnetCapNode.addChild(triggerNodeRes.value);
        }
        const spfxNode = await spfx_1.getSPFxScaffoldQuestion();
        if (spfxNode) {
            spfxNode.condition = { equals: question_1.TabSPFxItem.id };
            dotnetCapNode.addChild(spfxNode);
        }
    }
    dotnetCapNode.addChild(new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestionForDotNet));
    // only CLI need folder input
    if (teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
        runtimeNode.addChild(new teamsfx_api_1.QTreeNode(question_2.QuestionRootFolder));
    }
    runtimeNode.addChild(new teamsfx_api_1.QTreeNode(question_2.createAppNameQuestion()));
    return teamsfx_api_1.ok(runtimeNode.trim());
}
//////V2 questions
async function getQuestionsForCreateProjectV2(inputs) {
    if (common_1.isCLIDotNetEnabled() && teamsfx_api_1.CLIPlatforms.includes(inputs.platform)) {
        return getQuestionsForCreateProjectWithDotNet(inputs);
    }
    else {
        return getQuestionsForCreateProjectWithoutDotNet(inputs);
    }
}
exports.getQuestionsForCreateProjectV2 = getQuestionsForCreateProjectV2;
async function getQuestionsForUserTaskV2(ctx, solution, func, inputs, envInfo) {
    const namespace = func.namespace;
    const array = namespace ? namespace.split("/") : [];
    if (namespace && "" !== namespace && array.length > 0) {
        let res = teamsfx_api_1.ok(undefined);
        const solutionV2 = solution;
        if (solutionV2.getQuestionsForUserTask) {
            res = await solutionV2.getQuestionsForUserTask(ctx, inputs, func, envInfo, globalVars_1.TOOLS.tokenProvider);
        }
        if (res.isOk()) {
            if (res.value) {
                const node = res.value.trim();
                return teamsfx_api_1.ok(node);
            }
        }
        return res;
    }
    return teamsfx_api_1.err(error_1.FunctionRouterError(func));
}
exports.getQuestionsForUserTaskV2 = getQuestionsForUserTaskV2;
async function getQuestionsV2(ctx, solution, stage, inputs, envInfo) {
    if (stage !== teamsfx_api_1.Stage.create) {
        let res = teamsfx_api_1.ok(undefined);
        const solutionV2 = solution;
        if (solutionV2.getQuestions) {
            inputs.stage = stage;
            res = await solutionV2.getQuestions(ctx, inputs, envInfo, globalVars_1.TOOLS.tokenProvider);
        }
        if (res.isErr())
            return res;
        if (res.value) {
            const node = res.value;
            if (node.data) {
                return teamsfx_api_1.ok(node.trim());
            }
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsV2 = getQuestionsV2;
//# sourceMappingURL=questionModel.js.map