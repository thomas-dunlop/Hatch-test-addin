"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collaborationApiAdaptor = exports.assignJsonInc = exports.setEnvInfoV1ByStateV2 = exports.setStateV2ByConfigMapInc = exports.getQuestionsForUserTaskAdapter = exports.getQuestionsAdapter = exports.getQuestionsForScaffoldingAdapter = exports.executeUserTaskAdapter = exports.configureLocalResourceAdapter = exports.provisionLocalResourceAdapter = exports.deployAdapter = exports.configureResourceAdapter = exports.legacyConfig2EnvState = exports.flattenConfigMap = exports.provisionResourceAdapter = exports.updateResourceTemplateAdapter = exports.generateResourceTemplateAdapter = exports.scaffoldSourceCodeAdapter = exports.convert2Context = exports.convert2PluginContext = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const localSettingsProvider_1 = require("../../common/localSettingsProvider");
const tools_1 = require("../../common/tools");
const error_1 = require("../../core/error");
const constants_1 = require("../solution/fx-solution/constants");
const environment_1 = require("../../core/environment");
function convert2PluginContext(pluginName, ctx, inputs, ignoreEmptyProjectPath = false) {
    if (!ignoreEmptyProjectPath && !inputs.projectPath)
        throw new error_1.NoProjectOpenedError();
    const envInfo = environment_1.newEnvInfo(inputs.env);
    const config = new teamsfx_api_1.ConfigMap();
    envInfo.state.set(pluginName, config);
    const pluginContext = {
        root: inputs.projectPath || "",
        config: config,
        envInfo: envInfo,
        projectSettings: ctx.projectSetting,
        answers: inputs,
        logProvider: ctx.logProvider,
        telemetryReporter: ctx.telemetryReporter,
        cryptoProvider: ctx.cryptoProvider,
        permissionRequestProvider: ctx.permissionRequestProvider,
        ui: ctx.userInteraction,
    };
    return pluginContext;
}
exports.convert2PluginContext = convert2PluginContext;
function convert2Context(ctx, ignoreEmptyProjectPath = false) {
    if (!ignoreEmptyProjectPath && !ctx.answers.projectPath)
        throw new error_1.NoProjectOpenedError();
    const inputs = {
        projectPath: ctx.root,
        env: ctx.envInfo.envName,
        platform: ctx.answers.platform,
    };
    const context = {
        projectSetting: ctx.projectSettings,
        logProvider: ctx.logProvider,
        telemetryReporter: ctx.telemetryReporter,
        cryptoProvider: ctx.cryptoProvider,
        permissionRequestProvider: ctx.permissionRequestProvider,
        userInteraction: ctx.ui,
    };
    return { context, inputs };
}
exports.convert2Context = convert2Context;
async function scaffoldSourceCodeAdapter(ctx, inputs, plugin) {
    if (!plugin.scaffold && !plugin.postScaffold)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "scaffold"));
    if (!inputs.projectPath) {
        return teamsfx_api_1.err(new error_1.NoProjectOpenedError());
    }
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    const localSettingsProvider = new localSettingsProvider_1.LocalSettingsProvider(pluginContext.root);
    pluginContext.localSettings = await localSettingsProvider.load(pluginContext.cryptoProvider);
    if (plugin.preScaffold) {
        const preRes = await plugin.preScaffold(pluginContext);
        if (preRes.isErr()) {
            return teamsfx_api_1.err(preRes.error);
        }
    }
    if (plugin.scaffold) {
        const res = await plugin.scaffold(pluginContext);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
    }
    if (plugin.postScaffold) {
        const postRes = await plugin.postScaffold(pluginContext);
        if (postRes.isErr()) {
            return teamsfx_api_1.err(postRes.error);
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.scaffoldSourceCodeAdapter = scaffoldSourceCodeAdapter;
async function generateResourceTemplateAdapter(ctx, inputs, plugin) {
    if (!plugin.generateArmTemplates)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "generateArmTemplates"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    const armRes = await plugin.generateArmTemplates(pluginContext);
    if (armRes.isErr()) {
        return teamsfx_api_1.err(armRes.error);
    }
    const output = armRes.value;
    const bicepTemplate = { kind: "bicep", template: output };
    return teamsfx_api_1.ok(bicepTemplate);
}
exports.generateResourceTemplateAdapter = generateResourceTemplateAdapter;
async function updateResourceTemplateAdapter(ctx, inputs, plugin) {
    if (!plugin.updateArmTemplates)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "updateArmTemplates"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    const armRes = await plugin.updateArmTemplates(pluginContext);
    if (armRes.isErr()) {
        return teamsfx_api_1.err(armRes.error);
    }
    const output = armRes.value;
    const bicepTemplate = { kind: "bicep", template: output };
    return teamsfx_api_1.ok(bicepTemplate);
}
exports.updateResourceTemplateAdapter = updateResourceTemplateAdapter;
async function provisionResourceAdapter(ctx, inputs, envInfo, tokenProvider, plugin) {
    var _a;
    if (!plugin.provision) {
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "provision"));
    }
    const state = teamsfx_api_1.ConfigMap.fromJSON(envInfo.state);
    if (!state) {
        return teamsfx_api_1.err(error_1.InvalidStateError(plugin.name, envInfo.state));
    }
    const solutionInputs = inputs;
    state.set(constants_1.GLOBAL_CONFIG, teamsfx_api_1.ConfigMap.fromJSON(solutionInputs));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    pluginContext.envInfo.state = flattenConfigMap(state);
    pluginContext.envInfo.config = envInfo.config;
    pluginContext.config = (_a = pluginContext.envInfo.state.get(plugin.name)) !== null && _a !== void 0 ? _a : new teamsfx_api_1.ConfigMap();
    if (plugin.preProvision) {
        const preRes = await plugin.preProvision(pluginContext);
        if (preRes.isErr()) {
            return teamsfx_api_1.err(preRes.error);
        }
    }
    const res = await plugin.provision(pluginContext);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    pluginContext.envInfo.state.delete(constants_1.GLOBAL_CONFIG);
    envInfo.state[plugin.name] = pluginContext.config.toJSON();
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.provisionResourceAdapter = provisionResourceAdapter;
// flattens output/secrets fields in config map for backward compatibility
function flattenConfigMap(configMap) {
    return configMap;
}
exports.flattenConfigMap = flattenConfigMap;
// Convert legacy config map to env state with output and secrets fields
function legacyConfig2EnvState(config, pluginName) {
    const output = config.toJSON();
    return output;
}
exports.legacyConfig2EnvState = legacyConfig2EnvState;
async function configureResourceAdapter(ctx, inputs, envInfo, tokenProvider, plugin) {
    var _a;
    if (!plugin.postProvision)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "postProvision"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    const state = teamsfx_api_1.ConfigMap.fromJSON(envInfo.state);
    if (!state) {
        return teamsfx_api_1.err(error_1.InvalidStateError(plugin.name, envInfo.state));
    }
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    pluginContext.envInfo.state = flattenConfigMap(state);
    pluginContext.envInfo.config = envInfo.config;
    pluginContext.config = (_a = pluginContext.envInfo.state.get(plugin.name)) !== null && _a !== void 0 ? _a : new teamsfx_api_1.ConfigMap();
    const postRes = await plugin.postProvision(pluginContext);
    if (postRes.isErr()) {
        return teamsfx_api_1.err(postRes.error);
    }
    envInfo.state[plugin.name] = pluginContext.config.toJSON();
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.configureResourceAdapter = configureResourceAdapter;
async function deployAdapter(ctx, inputs, envInfo, tokenProvider, plugin) {
    if (!plugin.deploy)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "deploy"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    setEnvInfoV1ByStateV2(plugin.name, pluginContext, envInfo);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    if (plugin.preDeploy) {
        const preRes = await plugin.preDeploy(pluginContext);
        if (preRes.isErr()) {
            return teamsfx_api_1.err(preRes.error);
        }
    }
    const deployRes = await plugin.deploy(pluginContext);
    if (deployRes.isErr()) {
        return teamsfx_api_1.err(deployRes.error);
    }
    if (plugin.postDeploy) {
        const postRes = await plugin.postDeploy(pluginContext);
        if (postRes.isErr()) {
            return teamsfx_api_1.err(postRes.error);
        }
    }
    // We are making an exception for APIM plugin to modify envInfo, which should be immutable
    // during deployment. Becasue it is the only plugin that needs to do so. Remove the following
    // line after APIM is refactored not to change env state.
    setStateV2ByConfigMapInc(plugin.name, envInfo.state, pluginContext.config);
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.deployAdapter = deployAdapter;
/**
 * An adaptor that behaves like a ConfigMap for plugin local settings,
 * but modifies plugin settings json in-place when setting values.
 */
class ConfigMapAdaptor {
    constructor(pluginName, json) {
        this._pluginSettings = json;
        const map = teamsfx_api_1.ConfigMap.fromJSON(json);
        if (!map) {
            throw error_1.InvalidStateError(pluginName, json);
        }
        this._map = map;
        this.size = this._map.size;
    }
    getString(k, defaultValue) {
        return this._map.getString(k, defaultValue);
    }
    getBoolean(k, defaultValue) {
        return this._map.getBoolean(k, defaultValue);
    }
    getNumber(k, defaultValue) {
        return this._map.getNumber(k, defaultValue);
    }
    getStringArray(k, defaultValue) {
        return this._map.getStringArray(k, defaultValue);
    }
    getNumberArray(k, defaultValue) {
        return this._map.getNumberArray(k, defaultValue);
    }
    getBooleanArray(k, defaultValue) {
        return this._map.getBooleanArray(k, defaultValue);
    }
    getOptionItem(k, defaultValue) {
        return this._map.getOptionItem(k, defaultValue);
    }
    getOptionItemArray(k, defaultValue) {
        return this._map.getOptionItemArray(k, defaultValue);
    }
    toJSON() {
        return this._pluginSettings;
    }
    clear() {
        Object.keys(this._pluginSettings).forEach((key) => delete this._pluginSettings[key]);
        return this._map.clear();
    }
    delete(key) {
        const deleted = this._map.delete(key);
        if (deleted) {
            delete this._pluginSettings[key];
        }
        return deleted;
    }
    forEach(callbackfn, thisArg) {
        return this._map.forEach(callbackfn, thisArg);
    }
    get(key) {
        return this._map.get(key);
    }
    has(key) {
        return this._map.has(key);
    }
    entries() {
        return this._map.entries();
    }
    keys() {
        return this._map.keys();
    }
    values() {
        return this._map.values();
    }
    [Symbol.iterator]() {
        return this._map.entries();
    }
    set(key, value) {
        this._map.set(key, value);
        this._pluginSettings[key] = value;
        this.size = this._map.size;
        return this;
    }
}
Symbol.toStringTag;
/**
 * a Json backed LocalSettings which keeps localSettings Json and ConfigMap in sync
 */
class LocalSettingsAdaptor {
    constructor(localSettings, pluginName) {
        if (localSettings && localSettings["teamsApp"]) {
            this.teamsApp = new ConfigMapAdaptor(pluginName, localSettings["teamsApp"]);
        }
        if (localSettings && localSettings["auth"]) {
            this.auth = new ConfigMapAdaptor(pluginName, localSettings["auth"]);
        }
        if (localSettings && localSettings["frontend"]) {
            this.frontend = new ConfigMapAdaptor(pluginName, localSettings["frontend"]);
        }
        if (localSettings && localSettings["backend"]) {
            this.backend = new ConfigMapAdaptor(pluginName, localSettings["backend"]);
        }
        if (localSettings && localSettings["bot"]) {
            this.bot = new ConfigMapAdaptor(pluginName, localSettings["bot"]);
        }
    }
}
async function provisionLocalResourceAdapter(ctx, inputs, localSettings, tokenProvider, plugin, envInfo) {
    if (!plugin.localDebug)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "localDebug"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    if (envInfo) {
        pluginContext.envInfo.state = tools_1.objectToMap(envInfo.state);
        pluginContext.envInfo.config = envInfo.config;
    }
    if (!pluginContext.envInfo.state.get(plugin.name)) {
        pluginContext.envInfo.state.set(plugin.name, pluginContext.config);
    }
    const localSettingsAdaptor = new LocalSettingsAdaptor(localSettings, plugin.name);
    pluginContext.localSettings = localSettingsAdaptor;
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    const res = await plugin.localDebug(pluginContext);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    if (envInfo) {
        envInfo.state[plugin.name] = pluginContext.envInfo.state.get(plugin.name).toJSON();
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.provisionLocalResourceAdapter = provisionLocalResourceAdapter;
async function configureLocalResourceAdapter(ctx, inputs, localSettings, tokenProvider, plugin, envInfo) {
    if (!plugin.postLocalDebug)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "postLocalDebug"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    if (envInfo) {
        pluginContext.envInfo.state = tools_1.objectToMap(envInfo.state);
        pluginContext.envInfo.config = envInfo.config;
    }
    if (envInfo === null || envInfo === void 0 ? void 0 : envInfo.config.isLocalDebug) {
        pluginContext.envInfo.config.isLocalDebug = true;
    }
    if (!pluginContext.envInfo.state.get(plugin.name)) {
        pluginContext.envInfo.state.set(plugin.name, pluginContext.config);
    }
    const localSettingsAdaptor = new LocalSettingsAdaptor(localSettings, plugin.name);
    pluginContext.localSettings = localSettingsAdaptor;
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    const res = await plugin.postLocalDebug(pluginContext);
    if (res.isErr()) {
        return teamsfx_api_1.err(res.error);
    }
    if (envInfo) {
        envInfo.state[plugin.name] = pluginContext.envInfo.state.get(plugin.name).toJSON();
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.configureLocalResourceAdapter = configureLocalResourceAdapter;
async function executeUserTaskAdapter(ctx, inputs, func, localSettings, envInfo, tokenProvider, plugin) {
    if (!plugin.executeUserTask)
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, "executeUserTask"));
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    setEnvInfoV1ByStateV2(plugin.name, pluginContext, envInfo);
    const localSettingsAdaptor = new LocalSettingsAdaptor(localSettings, plugin.name);
    pluginContext.localSettings = localSettingsAdaptor;
    const res = await plugin.executeUserTask(func, pluginContext);
    if (res.isErr())
        return teamsfx_api_1.err(res.error);
    setStateV2ByConfigMapInc(plugin.name, envInfo.state, pluginContext.config);
    return teamsfx_api_1.ok(res.value);
}
exports.executeUserTaskAdapter = executeUserTaskAdapter;
async function getQuestionsForScaffoldingAdapter(ctx, inputs, plugin) {
    if (!plugin.getQuestions)
        return teamsfx_api_1.ok(undefined);
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs, true);
    return await plugin.getQuestions(teamsfx_api_1.Stage.create, pluginContext);
}
exports.getQuestionsForScaffoldingAdapter = getQuestionsForScaffoldingAdapter;
async function getQuestionsAdapter(ctx, inputs, envInfo, tokenProvider, plugin) {
    if (!plugin.getQuestions)
        return teamsfx_api_1.ok(undefined);
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs, true);
    setEnvInfoV1ByStateV2(plugin.name, pluginContext, envInfo);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    return await plugin.getQuestions(inputs.stage, pluginContext);
}
exports.getQuestionsAdapter = getQuestionsAdapter;
async function getQuestionsForUserTaskAdapter(ctx, inputs, func, envInfo, tokenProvider, plugin) {
    if (!plugin.getQuestionsForUserTask)
        return teamsfx_api_1.ok(undefined);
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs, true);
    setEnvInfoV1ByStateV2(plugin.name, pluginContext, envInfo);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    return await plugin.getQuestionsForUserTask(func, pluginContext);
}
exports.getQuestionsForUserTaskAdapter = getQuestionsForUserTaskAdapter;
function setStateV2ByConfigMapInc(pluginName, state, config) {
    const pluginConfig = legacyConfig2EnvState(config, pluginName);
    state[pluginName] = lodash_1.default.assign(state[pluginName], pluginConfig);
}
exports.setStateV2ByConfigMapInc = setStateV2ByConfigMapInc;
function setEnvInfoV1ByStateV2(pluginName, pluginContext, envInfoV2) {
    const envInfo = environment_1.newEnvInfo();
    let stateV1 = teamsfx_api_1.ConfigMap.fromJSON(envInfoV2.state);
    if (!stateV1) {
        throw error_1.InvalidStateError(pluginName, envInfoV2.state);
    }
    stateV1 = flattenConfigMap(stateV1);
    let selfConfigMap = stateV1.get(pluginName);
    if (!selfConfigMap) {
        selfConfigMap = new teamsfx_api_1.ConfigMap();
        stateV1.set(pluginName, selfConfigMap);
    }
    envInfo.envName = envInfoV2.envName;
    envInfo.config = envInfoV2.config;
    envInfo.state = stateV1;
    pluginContext.config = selfConfigMap;
    pluginContext.envInfo = envInfo;
}
exports.setEnvInfoV1ByStateV2 = setEnvInfoV1ByStateV2;
function assignJsonInc(target, source) {
    if (!target)
        return source;
    if (!source)
        return target;
    for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue !== undefined) {
            const type = typeof sourceValue;
            if (type === "string") {
                if (sourceValue) {
                    target[key] = sourceValue;
                }
            }
            else {
                target[key] = sourceValue;
            }
        }
    }
    return target;
}
exports.assignJsonInc = assignJsonInc;
async function collaborationApiAdaptor(ctx, inputs, envInfo, tokenProvider, userInfo, plugin, taskName) {
    var _a;
    const fn = plugin[taskName];
    if (!fn) {
        return teamsfx_api_1.err(error_1.PluginHasNoTaskImpl(plugin.displayName, taskName));
    }
    const state = teamsfx_api_1.ConfigMap.fromJSON(envInfo.state);
    if (!state) {
        return teamsfx_api_1.err(error_1.InvalidStateError(plugin.name, envInfo.state));
    }
    const pluginContext = convert2PluginContext(plugin.name, ctx, inputs);
    pluginContext.azureAccountProvider = tokenProvider.azureAccountProvider;
    pluginContext.m365TokenProvider = tokenProvider.m365TokenProvider;
    pluginContext.envInfo.state = flattenConfigMap(state);
    pluginContext.envInfo.config = envInfo.config;
    pluginContext.config = (_a = pluginContext.envInfo.state.get(plugin.name)) !== null && _a !== void 0 ? _a : new teamsfx_api_1.ConfigMap();
    return fn.bind(plugin)(pluginContext, userInfo);
}
exports.collaborationApiAdaptor = collaborationApiAdaptor;
//# sourceMappingURL=utils4v2.js.map