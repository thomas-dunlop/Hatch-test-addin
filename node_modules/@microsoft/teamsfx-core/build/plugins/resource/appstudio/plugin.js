"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createManifest = exports.AppStudioPluginImpl = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const appStudio_1 = require("./appStudio");
const question_1 = require("../../solution/fx-solution/question");
const constants_1 = require("../../solution/fx-solution/constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
const constants_2 = require("./constants");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs = tslib_1.__importStar(require("fs-extra"));
const folder_1 = require("../../../folder");
const path_1 = tslib_1.__importDefault(require("path"));
const util = tslib_1.__importStar(require("util"));
const common_1 = require("../../../common");
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const utils_1 = require("./utils/utils");
const telemetry_1 = require("./utils/telemetry");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const constants_3 = require("../../../common/constants");
const manifestTemplate_1 = require("./manifestTemplate");
const environment_1 = require("../../../core/environment");
const localizeUtils_1 = require("../../../common/localizeUtils");
const utils_2 = require("../../../common/utils");
const strings_1 = require("../../resource/bot/resources/strings");
class AppStudioPluginImpl {
    constructor() {
        this.commonProperties = {};
    }
    async provision(ctx) {
        var _a, _b, _c;
        const provisionProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"), 1);
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.start());
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionProgress", ctx.projectSettings.appName)));
        let remoteTeamsAppId = await this.getTeamsAppId(ctx);
        let create = false;
        if (!remoteTeamsAppId) {
            create = true;
        }
        else {
            const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
                scopes: common_1.AppStudioScopes,
            }));
            if (appStudioTokenRes.isErr()) {
                return teamsfx_api_1.err(appStudioTokenRes.error);
            }
            const appStudioToken = appStudioTokenRes.value;
            try {
                await appStudio_1.AppStudioClient.getApp(remoteTeamsAppId, appStudioToken, ctx.logProvider);
            }
            catch (error) {
                create = true;
            }
        }
        if (create) {
            const result = await this.createApp(ctx, false);
            if (result.isErr()) {
                await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.end(false));
                return teamsfx_api_1.err(result.error);
            }
            remoteTeamsAppId = result.value.teamsAppId;
            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppCreatedNotice", remoteTeamsAppId));
        }
        (_c = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _c === void 0 ? void 0 : _c.set(constants_2.Constants.TEAMS_APP_ID, remoteTeamsAppId);
        await (provisionProgress === null || provisionProgress === void 0 ? void 0 : provisionProgress.end(true));
        return teamsfx_api_1.ok(remoteTeamsAppId);
    }
    async postProvision(ctx) {
        var _a, _b;
        const postProvisionProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"), 1);
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.start(localizeUtils_1.getLocalizedString("plugins.appstudio.postProvisionProgress", ctx.projectSettings.appName)));
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.next());
        const result = await this.updateApp(ctx, false);
        if (result.isErr()) {
            await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(false));
            return teamsfx_api_1.err(result.error);
        }
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", result.value));
        await (postProvisionProgress === null || postProvisionProgress === void 0 ? void 0 : postProvisionProgress.end(true));
        return teamsfx_api_1.ok(result.value);
    }
    async validateManifest(ctx, isLocalDebug) {
        var _a;
        let manifestString = undefined;
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const manifestRes = await this.getManifest(ctx, isLocalDebug);
            if (manifestRes.isErr()) {
                (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("plugins.appstudio.validationFailedNotice"));
                return teamsfx_api_1.err(manifestRes.error);
            }
            else {
                manifestString = JSON.stringify(manifestRes.value);
            }
        }
        const manifest = JSON.parse(manifestString);
        let errors;
        const res = await this.validateManifestAgainstSchema(manifest);
        if (res.isOk()) {
            errors = res.value;
        }
        else {
            return teamsfx_api_1.err(res.error);
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (manifest.icons.outline) {
            if (manifest.icons.outline.startsWith("https://") ||
                manifest.icons.outline.startsWith("http://")) {
                errors.push(localizeUtils_1.getLocalizedString("plugins.appstudio.relativePathTip", "icons.outline"));
            }
            else {
                const outlineFile = path_1.default.join(appDirectory, manifest.icons.outline);
                if (!(await fs.pathExists(outlineFile))) {
                    errors.push(localizeUtils_1.getLocalizedString("error.appstudio.fileNotFoundError", outlineFile));
                }
            }
        }
        if (manifest.icons.color) {
            if (manifest.icons.color.startsWith("https://") ||
                manifest.icons.color.startsWith("http://")) {
                errors.push(localizeUtils_1.getLocalizedString("plugins.appstudio.relativePathTip", "icons.color"));
            }
            else {
                const colorFile = path_1.default.join(appDirectory, manifest.icons.color);
                if (!(await fs.pathExists(colorFile))) {
                    errors.push(localizeUtils_1.getLocalizedString("error.appstudio.fileNotFoundError", colorFile));
                }
            }
        }
        return teamsfx_api_1.ok(errors);
    }
    async updateManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const teamsAppId = await this.getTeamsAppId(ctx);
        let manifest;
        let manifestString;
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        else {
            manifestString = JSON.stringify(manifestResult.value);
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx);
            manifest = JSON.parse(manifestString);
        }
        else {
            const appManifest = await this.getManifest(ctx, isLocalDebug);
            if (appManifest.isErr()) {
                (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"));
                const isProvisionSucceeded = !!((_b = ctx.envInfo.state
                    .get("solution")) === null || _b === void 0 ? void 0 : _b.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (appManifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
                else {
                    return teamsfx_api_1.err(appManifest.error);
                }
            }
            manifest = appManifest.value;
        }
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? environment_1.environmentManager.getLocalEnvName() : ctx.envInfo.envName) +
            `.json`;
        if (!(await fs.pathExists(manifestFileName))) {
            const isProvisionSucceeded = !!((_c = ctx.envInfo.state
                .get("solution")) === null || _c === void 0 ? void 0 : _c.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
            if (!isProvisionSucceeded) {
                const msgs = errors_1.AppStudioError.FileNotFoundError.message(manifestFileName);
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, [
                    msgs[0] + localizeUtils_1.getDefaultString("plugins.appstudio.provisionTip"),
                    msgs[1] + localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTip"),
                ], constants_3.HelpLinks.WhyNeedProvision));
            }
            await this.buildTeamsAppPackage(ctx, isLocalDebug);
        }
        const existingManifest = await fs.readJSON(manifestFileName);
        delete manifest.id;
        delete existingManifest.id;
        if (!lodash_1.default.isEqual(manifest, existingManifest)) {
            const res = await ((_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateManifestTip"), true, "Preview only", "Preview and update"));
            const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview only") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
                return teamsfx_api_1.err(error);
            }
            else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview and update") {
                this.buildTeamsAppPackage(ctx, isLocalDebug);
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioToken = appStudioTokenRes.value;
        try {
            const localUpdateTime = isLocalDebug
                ? undefined
                : (_e = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _e === void 0 ? void 0 : _e.get(constants_2.Constants.TEAMS_APP_UPDATED_AT);
            if (localUpdateTime) {
                const app = await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
                const devPortalUpdateTime = (_g = (_f = new Date(app.updatedAt)) === null || _f === void 0 ? void 0 : _f.getTime()) !== null && _g !== void 0 ? _g : -1;
                if (localUpdateTime < devPortalUpdateTime) {
                    const res = await ((_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateOverwriteTip"), true, "Overwrite and update"));
                    if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Overwrite and update")) {
                        const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
                        return teamsfx_api_1.err(error);
                    }
                }
            }
            const result = await this.updateApp(ctx, false);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
            (_j = ctx.logProvider) === null || _j === void 0 ? void 0 : _j.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", teamsAppId));
            (_k = ctx.ui) === null || _k === void 0 ? void 0 : _k.showMessage("info", localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedNotice"), false, constants_2.Constants.VIEW_DEVELOPER_PORTAL).then((res) => {
                var _a;
                if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === constants_2.Constants.VIEW_DEVELOPER_PORTAL) {
                    (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.openUrl(util.format(constants_2.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, result.value));
                }
            });
            return teamsfx_api_1.ok(teamsAppId);
        }
        catch (error) {
            if (error.message && error.message.includes("404")) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
    }
    async scaffold(ctx) {
        var _a, _b, _c;
        let manifest;
        const templatesFolder = folder_1.getTemplatesFolder();
        // cannot use getAppDirectory before creating the manifest file
        const appDir = path_1.default.join(await utils_2.getProjectTemplatesFolderPath(ctx.root), "appPackage");
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const templateManifestFolder = path_1.default.join(templatesFolder, "plugins", "resource", "spfx");
            const manifestFile = path_1.default.resolve(templateManifestFolder, "./solution/manifest_multi_env.json");
            const manifestString = (await fs.readFile(manifestFile)).toString();
            manifest = JSON.parse(manifestString);
        }
        else {
            const solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
            const hasFrontend = solutionSettings.capabilities.includes(question_1.TabOptionItem.id);
            const hasBot = solutionSettings.capabilities.includes(question_1.BotOptionItem.id);
            const scenarios = (_b = ctx.answers) === null || _b === void 0 ? void 0 : _b[question_1.AzureSolutionQuestionNames.Scenarios];
            const hasCommandAndResponseBot = (scenarios === null || scenarios === void 0 ? void 0 : scenarios.includes) && scenarios.includes(question_1.BotScenario.CommandAndResponseBot);
            const hasNotificationBot = (scenarios === null || scenarios === void 0 ? void 0 : scenarios.includes) && scenarios.includes(question_1.BotScenario.NotificationBot);
            const hasMessageExtension = solutionSettings.capabilities.includes(question_1.MessageExtensionItem.id);
            const hasAad = common_1.isAADEnabled(solutionSettings);
            const isM365 = (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.isM365;
            manifest = await createManifest(hasFrontend, hasBot, hasNotificationBot, hasCommandAndResponseBot, hasMessageExtension, false, hasAad, isM365);
        }
        await fs.ensureDir(appDir);
        const manifestTemplatePath = await manifestTemplate_1.getManifestTemplatePath(ctx.root);
        await fs.writeFile(manifestTemplatePath, JSON.stringify(manifest, null, 4));
        const defaultColorPath = path_1.default.join(templatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path_1.default.join(templatesFolder, constants_2.OUTLINE_TEMPLATE);
        const resourcesDir = path_1.default.join(appDir, constants_2.MANIFEST_RESOURCES);
        await fs.ensureDir(resourcesDir);
        await fs.copy(defaultColorPath, path_1.default.join(resourcesDir, constants_2.DEFAULT_COLOR_PNG_FILENAME));
        await fs.copy(defaultOutlinePath, path_1.default.join(resourcesDir, constants_2.DEFAULT_OUTLINE_PNG_FILENAME));
        return undefined;
    }
    async buildTeamsAppPackage(ctx, isLocalDebug) {
        var _a, _b, _c;
        // Validate manifest
        const validationResult = await this.validateManifest(ctx, isLocalDebug);
        if (validationResult.isOk() && validationResult.value.length > 0) {
            const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
            const validationFailed = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
            throw validationFailed;
        }
        let manifestString = undefined;
        if (!((_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.envName)) {
            throw results_1.AppStudioResultFactory.SystemError("InvalidInputError", [
                localizeUtils_1.getDefaultString("error.appstudio.noEnvInfo"),
                localizeUtils_1.getLocalizedString("error.appstudio.noEnvInfo"),
            ]);
        }
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        let zipFileName;
        if (isLocalDebug) {
            zipFileName = path_1.default.join(ctx.root, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, "appPackage.local.zip");
        }
        else {
            zipFileName = path_1.default.join(ctx.root, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName, `appPackage.${ctx.envInfo.envName}.zip`);
        }
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            manifestString = await this.getSPFxManifest(ctx);
            const manifest = JSON.parse(manifestString);
            if (!isUUID_1.default(manifest.id)) {
                manifest.id = uuid_1.v4();
            }
            manifestString = JSON.stringify(manifest, null, 4);
        }
        else {
            const manifest = await this.getManifest(ctx, isLocalDebug);
            if (manifest.isOk()) {
                manifestString = JSON.stringify(manifest.value, null, 4);
            }
            else {
                (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString("plugins.appstudio.buildFailedNotice"));
                const isProvisionSucceeded = !!((_c = ctx.envInfo.state
                    .get("solution")) === null || _c === void 0 ? void 0 : _c.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
                if (manifest.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
                    !isProvisionSucceeded) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.buildFailedNotice"), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision);
                }
                else {
                    throw manifest.error;
                }
            }
        }
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(manifestString));
        const manifest = JSON.parse(manifestString);
        // color icon
        if (manifest.icons.color && !manifest.icons.color.startsWith("https://")) {
            const colorFile = `${appDirectory}/${manifest.icons.color}`;
            const fileExists = await fs.pathExists(colorFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
            }
            const dir = path_1.default.dirname(manifest.icons.color);
            zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        }
        // outline icon
        if (manifest.icons.outline && !manifest.icons.outline.startsWith("https://")) {
            const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
            const fileExists = await fs.pathExists(outlineFile);
            if (!fileExists) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
            }
            const dir = path_1.default.dirname(manifest.icons.outline);
            zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        }
        await fs.ensureDir(path_1.default.dirname(zipFileName));
        const manifestFileName = `${ctx.root}/${teamsfx_api_1.BuildFolderName}/${teamsfx_api_1.AppPackageFolderName}/manifest.` +
            (isLocalDebug ? "local" : ctx.envInfo.envName) +
            `.json`;
        if (await fs.pathExists(manifestFileName)) {
            await fs.chmod(manifestFileName, 0o777);
        }
        await fs.writeFile(manifestFileName, manifestString);
        await fs.chmod(manifestFileName, 0o444);
        // localization file
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            await Promise.all(manifest.localizationInfo.additionalLanguages.map(async function (language) {
                const file = language.file;
                const fileName = `${appDirectory}/${file}`;
                if (!(await fs.pathExists(fileName))) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(fileName));
                }
                const dir = path_1.default.dirname(file);
                zip.addLocalFile(fileName, dir === "." ? "" : dir);
            }));
        }
        zip.writeZip(zipFileName);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const spfxTeamsPath = `${ctx.root}/SPFx/teams`;
            await fs.copyFile(zipFileName, path_1.default.join(spfxTeamsPath, "TeamsSPFxApp.zip"));
            for (const file of await fs.readdir(`${ctx.root}/SPFx/teams/`)) {
                if (file.endsWith("color.png") &&
                    manifest.icons.color &&
                    !manifest.icons.color.startsWith("https://")) {
                    const colorFile = `${appDirectory}/${manifest.icons.color}`;
                    const color = await fs.readFile(colorFile);
                    await fs.writeFile(path_1.default.join(spfxTeamsPath, file), color);
                }
                else if (file.endsWith("outline.png") &&
                    manifest.icons.outline &&
                    !manifest.icons.outline.startsWith("https://")) {
                    const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
                    const outline = await fs.readFile(outlineFile);
                    await fs.writeFile(path_1.default.join(spfxTeamsPath, file), outline);
                }
            }
        }
        if (appDirectory === path_1.default.join(ctx.root, `.${teamsfx_api_1.ConfigFolderName}`)) {
            await fs.ensureDir(path_1.default.join(ctx.root, `${teamsfx_api_1.AppPackageFolderName}`));
            const formerZipFileName = `${appDirectory}/appPackage.zip`;
            if (await fs.pathExists(formerZipFileName)) {
                await fs.remove(formerZipFileName);
            }
            const projectTemplatesFolderPath = await utils_2.getProjectTemplatesFolderPath(ctx.root);
            await fs.move(path_1.default.join(appDirectory, "manifest.icons.color"), path_1.default.join(projectTemplatesFolderPath, "appPackage", constants_2.MANIFEST_RESOURCES, manifest.icons.color));
            await fs.move(path_1.default.join(appDirectory, "manifest.icons.outline"), path_1.default.join(projectTemplatesFolderPath, "appPackage", constants_2.MANIFEST_RESOURCES, manifest.icons.outline));
            await fs.move(path_1.default.join(appDirectory, constants_2.REMOTE_MANIFEST), path_1.default.join(projectTemplatesFolderPath, "appPackage", constants_2.MANIFEST_TEMPLATE));
        }
        return zipFileName;
    }
    async publish(ctx) {
        var _a, _b;
        let manifest;
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        if (common_1.isSPFxProject(ctx.projectSettings)) {
            const manifestString = await this.getSPFxManifest(ctx);
            manifest = JSON.parse(manifestString);
        }
        else {
            const fillinRes = await this.getManifest(ctx, false);
            if (fillinRes.isOk()) {
                manifest = fillinRes.value;
            }
            else {
                throw fillinRes.error;
            }
        }
        if (!manifest) {
            throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.ManifestLoadFailedError.name, errors_1.AppStudioError.ManifestLoadFailedError.message(""));
        }
        // manifest.id === externalID
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            throw appStudioTokenRes.error;
        }
        const appStudioToken = appStudioTokenRes.value;
        const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioToken);
        if (existApp) {
            let executePublishUpdate = false;
            let description = localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublishedAppNotice", existApp.displayName, existApp.publishingState);
            if (existApp.lastModifiedDateTime) {
                description =
                    description +
                        localizeUtils_1.getLocalizedString("plugins.appstudio.lastModifiedTip", (_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString());
            }
            description = description + localizeUtils_1.getLocalizedString("plugins.appstudio.updatePublihsedAppConfirm");
            const res = await ((_b = ctx.ui) === null || _b === void 0 ? void 0 : _b.showMessage("warn", description, true, "Confirm"));
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
                executePublishUpdate = true;
            if (executePublishUpdate) {
                const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), true);
                return { id: appId, name: manifest.name.short, update: true };
            }
            else {
                throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
            }
        }
        else {
            const appId = await this.beforePublish(ctx, appDirectory, JSON.stringify(manifest), false);
            return { id: appId, name: manifest.name.short, update: false };
        }
    }
    async postLocalDebug(ctx) {
        const res = await this.updateApp(ctx, true);
        if (res.isErr()) {
            return res;
        }
        const teamsAppId = res.value;
        ctx.envInfo.state.get(constants_3.ResourcePlugins.AppStudio).set(constants_2.Constants.TEAMS_APP_ID, teamsAppId);
        return teamsfx_api_1.ok(teamsAppId);
    }
    async checkPermission(ctx, userInfo) {
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            throw appStudioTokenRes.error;
        }
        const appStudioToken = appStudioTokenRes.value;
        const teamsAppId = await this.getTeamsAppId(ctx);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        const teamsAppRoles = await appStudio_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId);
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [teamsAppRoles],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async listCollaborator(ctx) {
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            throw appStudioTokenRes.error;
        }
        const appStudioToken = appStudioTokenRes.value;
        const teamsAppId = await this.getTeamsAppId(ctx);
        if (!teamsAppId) {
            throw new Error(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
        }
        let userLists;
        try {
            userLists = await appStudio_1.AppStudioClient.getUserList(teamsAppId, appStudioToken);
            if (!userLists) {
                return [];
            }
        }
        catch (error) {
            if (error.name === 404) {
                error.message = constants_2.ErrorMessages.TeamsAppNotFound(teamsAppId);
            }
            throw error;
        }
        const teamsAppAdmin = userLists
            .filter((userList) => {
            return userList.isAdministrator;
        })
            .map((userList) => {
            return {
                userObjectId: userList.aadId,
                displayName: userList.displayName,
                userPrincipalName: userList.userPrincipalName,
                resourceId: teamsAppId,
            };
        });
        return teamsAppAdmin;
    }
    async grantPermission(ctx, userInfo) {
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            throw appStudioTokenRes.error;
        }
        const appStudioToken = appStudioTokenRes.value;
        const teamsAppId = await this.getTeamsAppId(ctx);
        if (!teamsAppId) {
            const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, constants_1.PluginNames.APPST));
            throw new teamsfx_api_1.UserError(constants_1.PluginNames.APPST, "GetConfigError", msgs[0], msgs[1]);
        }
        try {
            await appStudio_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo);
        }
        catch (error) {
            const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(error === null || error === void 0 ? void 0 : error.message, teamsAppId);
            throw new teamsfx_api_1.UserError(constants_1.PluginNames.APPST, "GrantPermissionFailedError", msgs[0], msgs[1]);
        }
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [constants_2.Constants.PERMISSIONS.admin],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return result;
    }
    async beforePublish(ctx, appDirectory, manifestString, update) {
        var _a, _b;
        const manifest = JSON.parse(manifestString);
        const publishProgress = (_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.createProgressBar(`Publishing ${manifest.name.short}`, 3);
        try {
            // Validate manifest
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.start(localizeUtils_1.getLocalizedString("plugins.appstudio.validateProgressStart")));
            const validationResult = await this.validateManifestAgainstSchema(manifest);
            if (validationResult.isErr()) {
                throw validationResult.error;
            }
            else if (validationResult.value.length > 0) {
                throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message(validationResult.value));
            }
            // Update App in App Studio
            const remoteTeamsAppId = await this.getTeamsAppId(ctx);
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressUpdate", remoteTeamsAppId)));
            const buildPackage = await this.buildTeamsAppPackage(ctx, false);
            const archivedFile = await fs.readFile(buildPackage);
            const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
                scopes: common_1.AppStudioScopes,
            }));
            if (appStudioTokenRes.isErr()) {
                throw appStudioTokenRes.error;
            }
            const appStudioToken = appStudioTokenRes.value;
            try {
                const app = await appStudio_1.AppStudioClient.importApp(archivedFile, appStudioToken, undefined, true);
                if (app.updatedAt) {
                    (_b = ctx.envInfo.state
                        .get(constants_1.PluginNames.APPST)) === null || _b === void 0 ? void 0 : _b.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, new Date(app.updatedAt).getTime());
                }
            }
            catch (e) {
                if (e.name === 404) {
                    throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppNotFoundError.name, errors_1.AppStudioError.TeamsAppNotFoundError.message(remoteTeamsAppId));
                }
            }
            // Build Teams App package
            // Platforms will be checked in buildTeamsAppPackage(ctx)
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressBuild", appDirectory)));
            const appPackage = await this.buildTeamsAppPackage(ctx, false);
            const appContent = await fs.readFile(appPackage);
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.next(localizeUtils_1.getLocalizedString("plugins.appstudio.publishProgressPublish", manifest.name.short)));
            if (update) {
                // Update existing app in App Catalog
                return await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, appContent, appStudioToken);
            }
            else {
                // Publish Teams App
                return await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, appContent, appStudioToken);
            }
        }
        finally {
            await (publishProgress === null || publishProgress === void 0 ? void 0 : publishProgress.end(true));
        }
    }
    async getConfigForCreatingManifest(ctx) {
        var _a, _b, _c, _d, _e, _f, _g;
        const tabEndpoint = (_a = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _a === void 0 ? void 0 : _a.get(constants_2.FRONTEND_ENDPOINT);
        const tabDomain = (_b = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _b === void 0 ? void 0 : _b.get(constants_2.FRONTEND_DOMAIN);
        const tabIndexPath = (_c = ctx.envInfo.state.get(constants_1.PluginNames.FE)) === null || _c === void 0 ? void 0 : _c.get(constants_2.FRONTEND_INDEX_PATH);
        const aadId = (_d = ctx.envInfo.state.get(constants_1.PluginNames.AAD)) === null || _d === void 0 ? void 0 : _d.get(constants_1.REMOTE_AAD_ID);
        const botId = (_e = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _e === void 0 ? void 0 : _e.get(constants_2.BOT_ID);
        const botDomain = (_f = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _f === void 0 ? void 0 : _f.get(constants_1.BOT_DOMAIN);
        const teamsAppId = await this.getTeamsAppId(ctx);
        // This config value is set by aadPlugin.setApplicationInContext. so aadPlugin.setApplicationInContext needs to run first.
        const webApplicationInfoResource = (_g = ctx.envInfo.state
            .get(constants_1.PluginNames.AAD)) === null || _g === void 0 ? void 0 : _g.get(constants_1.WEB_APPLICATION_INFO_SOURCE);
        return {
            tabEndpoint,
            tabDomain,
            tabIndexPath,
            aadId,
            botDomain,
            botId,
            webApplicationInfoResource,
            teamsAppId,
        };
    }
    // TODO: remove isLocalDebug later after merging local and remote configs
    async getTeamsAppId(ctx) {
        var _a;
        let teamsAppId = "";
        // User may manually update id in manifest template file, rather than configuration file
        // The id in manifest template file should override configurations
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root);
        if (manifestResult.isOk()) {
            teamsAppId = manifestResult.value.id;
        }
        if (!isUUID_1.default(teamsAppId)) {
            teamsAppId = (_a = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _a === void 0 ? void 0 : _a.get(constants_2.Constants.TEAMS_APP_ID);
        }
        return teamsAppId;
    }
    async createApp(ctx, isLocalDebug) {
        const appDirectory = await common_1.getAppDirectory(ctx.root);
        const status = await fs.lstat(appDirectory);
        if (!status.isDirectory()) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.NotADirectoryError.name, errors_1.AppStudioError.NotADirectoryError.message(appDirectory));
        }
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        let manifest = manifestResult.value;
        manifest.bots = undefined;
        manifest.composeExtensions = undefined;
        if (isLocalDebug || !isUUID_1.default(manifest.id)) {
            manifest.id = uuid_1.v4();
        }
        // Corner case: icons path defined in config file
        let manifestString = JSON.stringify(manifestResult.value);
        const view = {
            config: ctx.envInfo.config,
        };
        manifestString = utils_1.renderTemplate(manifestString, view);
        manifest = JSON.parse(manifestString);
        const colorFile = `${appDirectory}/${manifest.icons.color}`;
        if (!(await fs.pathExists(colorFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile));
        }
        const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
        if (!(await fs.pathExists(outlineFile))) {
            throw results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile));
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest)));
        zip.addLocalFile(colorFile);
        zip.addLocalFile(outlineFile);
        const archivedFile = zip.toBuffer();
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioToken = appStudioTokenRes.value;
        try {
            const appDefinition = await appStudio_1.AppStudioClient.importApp(archivedFile, appStudioToken, ctx.logProvider);
            return teamsfx_api_1.ok(appDefinition);
        }
        catch (e) {
            return teamsfx_api_1.err(isLocalDebug
                ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdCreateFailedError.name, errors_1.AppStudioError.LocalAppIdCreateFailedError.message(e))
                : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdCreateFailedError.name, errors_1.AppStudioError.RemoteAppIdCreateFailedError.message(e)));
        }
    }
    async updateApp(ctx, isLocalDebug) {
        var _a;
        const appStudioTokenRes = await (ctx === null || ctx === void 0 ? void 0 : ctx.m365TokenProvider.getAccessToken({
            scopes: common_1.AppStudioScopes,
        }));
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioToken = appStudioTokenRes.value;
        try {
            const buildPackage = await this.buildTeamsAppPackage(ctx, isLocalDebug);
            const archivedFile = await fs.readFile(buildPackage);
            const app = await appStudio_1.AppStudioClient.importApp(archivedFile, appStudioToken, ctx.logProvider, true);
            if (app.updatedAt) {
                const time = new Date(app.updatedAt).getTime();
                (_a = ctx.envInfo.state.get(constants_1.PluginNames.APPST)) === null || _a === void 0 ? void 0 : _a.set(constants_2.Constants.TEAMS_APP_UPDATED_AT, time);
            }
            return teamsfx_api_1.ok(app.teamsAppId);
        }
        catch (e) {
            if (e instanceof Error) {
                return teamsfx_api_1.err(isLocalDebug
                    ? results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.LocalAppIdUpdateFailedError.name, errors_1.AppStudioError.LocalAppIdUpdateFailedError.message(e))
                    : results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.RemoteAppIdUpdateFailedError.name, errors_1.AppStudioError.RemoteAppIdUpdateFailedError.message(e)));
            }
            throw e;
        }
    }
    async validateManifestAgainstSchema(manifest) {
        if (manifest.$schema) {
            try {
                const result = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
                return teamsfx_api_1.ok(result);
            }
            catch (e) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
                ]), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateSchemaNotDefined"),
            ]), constants_3.HelpLinks.WhyNeedProvision));
        }
    }
    async getManifest(ctx, isLocalDebug) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const { tabEndpoint, tabDomain, tabIndexPath, aadId, botDomain, botId, webApplicationInfoResource, teamsAppId, } = await this.getConfigForCreatingManifest(ctx);
        const isProvisionSucceeded = !!((_a = ctx.envInfo.state
            .get("solution")) === null || _a === void 0 ? void 0 : _a.get(constants_1.SOLUTION_PROVISION_SUCCEEDED));
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root);
        if (manifestResult.isErr()) {
            return teamsfx_api_1.err(manifestResult.error);
        }
        let manifestString = JSON.stringify(manifestResult.value);
        // Bot only project, without frontend hosting
        let endpoint = tabEndpoint;
        let indexPath = tabIndexPath;
        let hasFrontend = false;
        const capabilities = await manifestTemplate_1.getCapabilities(ctx.root);
        if (capabilities.isErr()) {
            return teamsfx_api_1.err(capabilities.error);
        }
        hasFrontend =
            capabilities.value.includes("staticTab") || capabilities.value.includes("configurableTab");
        if (!endpoint && !hasFrontend) {
            endpoint = constants_2.DEFAULT_DEVELOPER.websiteUrl;
            indexPath = "";
        }
        const customizedKeys = utils_1.getCustomizedKeys("", JSON.parse(manifestString));
        this.commonProperties = {
            [telemetry_1.TelemetryPropertyKey.customizedKeys]: JSON.stringify(customizedKeys),
        };
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-frontend-hosting": {
                    endpoint: endpoint !== null && endpoint !== void 0 ? endpoint : "{{state.fx-resource-frontend-hosting.endpoint}}",
                    indexPath: indexPath !== null && indexPath !== void 0 ? indexPath : "{{state.fx-resource-frontend-hosting.indexPath}}",
                    domain: tabDomain !== null && tabDomain !== void 0 ? tabDomain : "{{state.fx-resource-frontend-hosting.domain}}",
                },
                "fx-resource-aad-app-for-teams": {
                    clientId: aadId !== null && aadId !== void 0 ? aadId : "{{state.fx-resource-aad-app-for-teams.clientId}}",
                    applicationIdUris: webApplicationInfoResource !== null && webApplicationInfoResource !== void 0 ? webApplicationInfoResource : "{{state.fx-resource-aad-app-for-teams.applicationIdUris}}",
                },
                "fx-resource-appstudio": {
                    teamsAppId: teamsAppId !== null && teamsAppId !== void 0 ? teamsAppId : uuid_1.v4(),
                },
                "fx-resource-bot": {
                    botId: botId !== null && botId !== void 0 ? botId : "{{state.fx-resource-bot.botId}}",
                    siteEndpoint: (_c = (_b = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _b === void 0 ? void 0 : _b.get(strings_1.PluginBot.SITE_ENDPOINT)) !== null && _c !== void 0 ? _c : "{{state.fx-resource-bot.siteEndpoint}}",
                    siteName: (_e = (_d = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _d === void 0 ? void 0 : _d.get(strings_1.PluginBot.SITE_NAME)) !== null && _e !== void 0 ? _e : "{{state.fx-resource-bot.siteName}}",
                    validDomain: (_g = (_f = ctx.envInfo.state.get(constants_1.PluginNames.BOT)) === null || _f === void 0 ? void 0 : _f.get(strings_1.PluginBot.VALID_DOMAIN)) !== null && _g !== void 0 ? _g : "{{state.fx-resource-bot.validDomain}}",
                },
            },
        };
        manifestString = utils_1.renderTemplate(manifestString, view);
        const tokens = [
            ...new Set(mustache_1.default.parse(manifestString)
                .filter((x) => {
                return x[0] != "text" && x[1] != "state.fx-resource-appstudio.teamsAppId";
            })
                .map((x) => x[1])),
        ];
        if (tokens.length > 0) {
            if (isLocalDebug) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetLocalDebugConfigFailedError.name, errors_1.AppStudioError.GetLocalDebugConfigFailedError.message(new Error(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(","))))));
            }
            else {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", tokens.join(",")), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
            }
        }
        let updatedManifest;
        try {
            updatedManifest = JSON.parse(manifestString);
        }
        catch (error) {
            if (error.stack && error.stack.startsWith("SyntaxError")) {
                // teams app id in userData may be updated by user, result to invalid manifest
                const reg = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
                const result = teamsAppId.match(reg);
                if (!result) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error, "teamsAppId"), undefined, error.stack));
                }
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.InvalidManifestError.name, errors_1.AppStudioError.InvalidManifestError.message(error), undefined, error.stack));
            }
            else {
                return teamsfx_api_1.err(error);
            }
        }
        // This should be removed in future, the valid domains will be rendered by states
        if (((_h = updatedManifest.validDomains) === null || _h === void 0 ? void 0 : _h.length) == 0 || isLocalDebug) {
            const validDomains = [];
            if (tabDomain) {
                validDomains.push(tabDomain);
            }
            if (tabEndpoint && isLocalDebug) {
                validDomains.push(tabEndpoint.slice(8));
            }
            if (botId) {
                if (!botDomain) {
                    return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("plugins.appstudio.dataRequired", constants_1.BOT_DOMAIN), isProvisionSucceeded), constants_3.HelpLinks.WhyNeedProvision));
                }
                else {
                    validDomains.push(botDomain);
                }
            }
            for (const domain of validDomains) {
                if (((_j = updatedManifest.validDomains) === null || _j === void 0 ? void 0 : _j.indexOf(domain)) == -1) {
                    (_k = updatedManifest.validDomains) === null || _k === void 0 ? void 0 : _k.push(domain);
                }
            }
        }
        return teamsfx_api_1.ok(updatedManifest);
    }
    async getSPFxManifest(ctx) {
        const manifestResult = await manifestTemplate_1.loadManifest(ctx.root);
        if (manifestResult.isErr()) {
            throw manifestResult.error;
        }
        let manifestString = JSON.stringify(manifestResult.value);
        const view = {
            config: ctx.envInfo.config,
            state: {
                "fx-resource-appstudio": {
                    teamsAppId: await this.getTeamsAppId(ctx),
                },
            },
        };
        manifestString = utils_1.renderTemplate(manifestString, view);
        return manifestString;
    }
}
exports.AppStudioPluginImpl = AppStudioPluginImpl;
async function createManifest(hasFrontend, hasBot, hasNotificationBot, hasCommandAndResponseBot, hasMessageExtension, isSPFx, hasAad = true, isM365 = false) {
    var _a, _b;
    if (!hasBot && !hasMessageExtension && !hasFrontend && !hasAad) {
        throw new Error(`Invalid capability`);
    }
    if (!isSPFx || hasBot || hasMessageExtension || hasAad) {
        const manifestString = constants_2.TEAMS_APP_MANIFEST_TEMPLATE_V3;
        const manifest = JSON.parse(manifestString);
        if (hasAad) {
            manifest.webApplicationInfo = constants_2.WEB_APPLICATION_INFO_MULTI_ENV;
        }
        if (hasFrontend) {
            manifest.staticTabs = constants_2.STATIC_TABS_TPL_FOR_MULTI_ENV;
            if (!isM365) {
                manifest.configurableTabs = constants_2.CONFIGURABLE_TABS_TPL_FOR_MULTI_ENV;
            }
            (_a = manifest.validDomains) === null || _a === void 0 ? void 0 : _a.push("{{state.fx-resource-frontend-hosting.domain}}");
        }
        else {
            manifest.developer = constants_2.DEFAULT_DEVELOPER;
        }
        if (hasBot) {
            if (hasCommandAndResponseBot) {
                manifest.bots = constants_2.BOTS_TPL_FOR_COMMAND_AND_RESPONSE;
            }
            else if (hasNotificationBot) {
                manifest.bots = constants_2.BOTS_TPL_FOR_NOTIFICATION;
            }
            else {
                manifest.bots = constants_2.BOTS_TPL_FOR_MULTI_ENV;
            }
            (_b = manifest.validDomains) === null || _b === void 0 ? void 0 : _b.push("{{state.fx-resource-bot.validDomain}}");
        }
        if (hasMessageExtension) {
            manifest.composeExtensions = isM365
                ? constants_2.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV_M365
                : constants_2.COMPOSE_EXTENSIONS_TPL_FOR_MULTI_ENV;
        }
        if (isM365) {
            manifest.$schema = constants_2.M365_SCHEMA;
            manifest.manifestVersion = constants_2.M365_MANIFEST_VERSION;
        }
        return manifest;
    }
    return undefined;
}
exports.createManifest = createManifest;
//# sourceMappingURL=plugin.js.map