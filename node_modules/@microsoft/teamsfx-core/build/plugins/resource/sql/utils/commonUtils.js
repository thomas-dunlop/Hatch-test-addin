"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatEndpoint = exports.parseToken = exports.TokenInfo = exports.UserType = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const jwt_decode_1 = tslib_1.__importDefault(require("jwt-decode"));
const constants_1 = require("../constants");
var UserType;
(function (UserType) {
    UserType["User"] = "User";
    UserType["ServicePrincipal"] = "ServicePrincipal";
})(UserType = exports.UserType || (exports.UserType = {}));
class TokenInfo {
    constructor(name, objectId, userType) {
        this.name = name;
        this.objectId = objectId;
        this.userType = userType;
    }
}
exports.TokenInfo = TokenInfo;
function parseToken(accessToken) {
    const jwt = jwt_decode_1.default(accessToken);
    let authType;
    if (jwt.ver === constants_1.Constants.jwtToken.ver1) {
        authType = jwt.appidacr;
    }
    else if (jwt.ver === constants_1.Constants.jwtToken.ver2) {
        authType = jwt.azpacr;
    }
    else {
        throw new Error("invalide token");
    }
    if (authType === constants_1.Constants.jwtToken.userType) {
        return new TokenInfo(jwt.name, jwt.oid, UserType.User);
    }
    else {
        return new TokenInfo(jwt.appid, jwt.oid, UserType.ServicePrincipal);
    }
}
exports.parseToken = parseToken;
function formatEndpoint(endpoint) {
    endpoint = endpoint.toLowerCase();
    endpoint = endpoint.replace(/[^a-z0-9-]/gi, "");
    if (endpoint[0] === "-") {
        endpoint = endpoint.slice(1);
    }
    return endpoint;
}
exports.formatEndpoint = formatEndpoint;
//# sourceMappingURL=commonUtils.js.map