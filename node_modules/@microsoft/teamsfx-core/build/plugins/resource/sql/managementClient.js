"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlMgrClient = exports.ManagementClient = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_sql_1 = require("@azure/arm-sql");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const results_1 = require("./results");
class ManagementClient {
    constructor() {
        this.totalFirewallRuleCount = 0;
    }
    async create(azureAccountProvider, config) {
        const credential = await azureAccountProvider.getAccountCredentialAsync();
        this.config = config;
        this.client = new arm_sql_1.SqlManagementClient(credential, config.azureSubscriptionId);
    }
    async existAzureSQL() {
        if (!this.client || !this.config || !this.config.sqlServer)
            return false;
        try {
            const result = await this.client.servers.checkNameAvailability({
                name: this.config.sqlServer,
            });
            if (result.available) {
                return false;
            }
            else if (result.reason === "Invalid") {
                throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlEndpointError.name, errors_1.ErrorMessage.SqlEndpointError.message(this.config.sqlEndpoint));
            }
            else {
                return true;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlCheckError.name, errors_1.ErrorMessage.SqlCheckError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async existAadAdmin() {
        if (!this.client || !this.config)
            return false;
        try {
            const result = await this.client.serverAzureADAdministrators.listByServer(this.config.resourceGroup, this.config.sqlServer);
            if (result.find((item) => item.login === this.config.aadAdmin)) {
                return true;
            }
            else {
                return false;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCheckAdminError.name, errors_1.ErrorMessage.SqlCheckAdminError.message(this.config.identity, error.message), error);
        }
    }
    async addAADadmin() {
        if (!this.client || !this.config)
            return;
        let model = {
            tenantId: this.config.tenantId,
            sid: this.config.aadAdminObjectId,
            login: this.config.aadAdmin,
        };
        const tmp = model;
        tmp.administratorType = constants_1.Constants.sqlAdministratorType;
        model = tmp;
        try {
            await this.client.serverAzureADAdministrators.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlAddAdminError.name, errors_1.ErrorMessage.SqlAddAdminError.message(this.config.aadAdmin, error.message), error);
        }
    }
    async addLocalFirewallRule() {
        if (!this.client || !this.config)
            return;
        try {
            const response = await axios_1.default.get(constants_1.Constants.echoIpAddress);
            const localIp = response.data;
            const partials = localIp.split(".");
            partials[2] = constants_1.Constants.ipBeginToken;
            partials[3] = constants_1.Constants.ipBeginToken;
            const startIp = partials.join(".");
            partials[2] = constants_1.Constants.ipEndToken;
            partials[3] = constants_1.Constants.ipEndToken;
            const endIp = partials.join(".");
            const model = {
                startIpAddress: startIp,
                endIpAddress: endIp,
            };
            const ruleName = this.getRuleName(this.totalFirewallRuleCount);
            await this.client.firewallRules.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, ruleName, model);
            this.totalFirewallRuleCount++;
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlLocalFirwallError.name, errors_1.ErrorMessage.SqlLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async deleteLocalFirewallRule() {
        if (!this.client || !this.config)
            return;
        try {
            for (let i = 0; i < this.totalFirewallRuleCount; i++) {
                const ruleName = this.getRuleName(i);
                await this.client.firewallRules.deleteMethod(this.config.resourceGroup, this.config.sqlServer, ruleName);
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlDeleteLocalFirwallError.name, errors_1.ErrorMessage.SqlDeleteLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    getRuleName(suffix) {
        return constants_1.Constants.firewall.localRule + suffix;
    }
    async delay(s) {
        return new Promise((resolve) => setTimeout(resolve, s * 1000));
    }
}
exports.ManagementClient = ManagementClient;
exports.SqlMgrClient = new ManagementClient();
//# sourceMappingURL=managementClient.js.map