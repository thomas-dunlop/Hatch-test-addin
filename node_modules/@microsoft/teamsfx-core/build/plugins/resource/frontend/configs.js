"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendConfig = void 0;
const constants_1 = require("./constants");
const errors_1 = require("./resources/errors");
const utils_1 = require("./utils");
const tools_1 = require("../../../common/tools");
class FrontendConfig {
    constructor(subscriptionId, resourceGroupName, location, storageName, credentials) {
        this.subscriptionId = subscriptionId;
        this.resourceGroupName = resourceGroupName;
        this.location = location;
        this.storageName = storageName;
        this.credentials = credentials;
    }
    static async fromPluginContext(ctx) {
        var _a;
        const credentials = await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync());
        if (!credentials) {
            throw new errors_1.UnauthenticatedError();
        }
        return new FrontendConfig(FrontendConfig.getSubscriptionId(ctx), FrontendConfig.getResourceGroupName(ctx), FrontendConfig.getConfig(constants_1.DependentPluginInfo.Location, ctx.envInfo.state.get(constants_1.DependentPluginInfo.SolutionPluginName)), FrontendConfig.getStorageName(ctx), credentials);
    }
    syncToPluginContext(ctx) {
        Object.entries(this)
            .filter((kv) => FrontendConfig.persistentConfigList.includes(kv[0]))
            .forEach((kv) => {
            if (kv[1]) {
                FrontendConfig.setConfigIfNotExists(ctx, kv[0], kv[1]);
            }
        });
    }
    static getStorageName(ctx) {
        let result;
        try {
            result = tools_1.getStorageAccountNameFromResourceId(FrontendConfig.getStorageResourceId(ctx));
        }
        catch (e) {
            throw new errors_1.InvalidConfigError(constants_1.FrontendConfigInfo.StorageName, e.message);
        }
        if (!result) {
            const resourceNameSuffix = FrontendConfig.getConfig(constants_1.DependentPluginInfo.ResourceNameSuffix, ctx.envInfo.state.get(constants_1.DependentPluginInfo.SolutionPluginName));
            result = utils_1.Utils.generateStorageAccountName(ctx.projectSettings.appName, resourceNameSuffix, constants_1.Constants.FrontendSuffix);
        }
        if (!constants_1.RegularExpr.FrontendStorageNamePattern.test(result)) {
            throw new errors_1.InvalidStorageNameError();
        }
        return result;
    }
    static getStorageResourceId(ctx) {
        const result = ctx.config.getString(constants_1.FrontendConfigInfo.StorageResourceId);
        if (!result) {
            throw new errors_1.InvalidConfigError(constants_1.FrontendConfigInfo.StorageResourceId);
        }
        return result;
    }
    static getSubscriptionId(ctx) {
        const result = tools_1.getSubscriptionIdFromResourceId(FrontendConfig.getStorageResourceId(ctx));
        if (!result) {
            throw new errors_1.InvalidConfigError(constants_1.DependentPluginInfo.SubscriptionId);
        }
        return result;
    }
    static getResourceGroupName(ctx) {
        const result = tools_1.getResourceGroupNameFromResourceId(FrontendConfig.getStorageResourceId(ctx));
        if (!result) {
            throw new errors_1.InvalidConfigError(constants_1.DependentPluginInfo.ResourceGroupName);
        }
        return result;
    }
    static getConfig(key, configs) {
        const value = configs === null || configs === void 0 ? void 0 : configs.get(key);
        if (!value) {
            throw new errors_1.InvalidConfigError(key);
        }
        return value;
    }
    static setConfigIfNotExists(ctx, key, value) {
        if (ctx.config.get(key)) {
            return;
        }
        ctx.config.set(key, value);
    }
}
exports.FrontendConfig = FrontendConfig;
FrontendConfig.persistentConfigList = Object.values(constants_1.FrontendConfigInfo);
//# sourceMappingURL=configs.js.map