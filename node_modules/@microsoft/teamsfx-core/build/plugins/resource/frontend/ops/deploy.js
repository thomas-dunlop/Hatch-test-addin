"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendDeployment = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("../resources/errors");
const constants_1 = require("../constants");
const progress_helper_1 = require("../utils/progress-helper");
const steps_1 = require("../resources/steps");
const logger_1 = require("../utils/logger");
const messages_1 = require("../resources/messages");
const utils_1 = require("../utils");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const telemetry_helper_1 = require("../utils/telemetry-helper");
const env_1 = require("../env");
const v3error = tslib_1.__importStar(require("../v3/error"));
class FrontendDeployment {
    static async needBuild(componentPath, envName) {
        const lastBuildTime = await FrontendDeployment.getLastBuildTime(componentPath, envName);
        if (!lastBuildTime) {
            return true;
        }
        return FrontendDeployment.hasUpdatedContent(componentPath, lastBuildTime, (itemPath) => !itemPath.startsWith(env_1.envFileNamePrefix) || itemPath === env_1.envFileName(envName));
    }
    static async needDeploy(componentPath, envName) {
        const lastBuildTime = await FrontendDeployment.getLastBuildTime(componentPath, envName);
        const lastDeployTime = await FrontendDeployment.getLastDeploymentTime(componentPath, envName);
        if (!lastBuildTime || !lastDeployTime) {
            return true;
        }
        return lastDeployTime < lastBuildTime;
    }
    static async doFrontendBuild(componentPath, envName) {
        var _a;
        if (!(await FrontendDeployment.needBuild(componentPath, envName))) {
            return FrontendDeployment.skipBuild();
        }
        const progressHandler = progress_helper_1.ProgressHelper.progressHandler;
        const scripts = (_a = (await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.FileIOError(error.message), async () => (await fs_extra_1.default.readJSON(path_1.default.join(componentPath, constants_1.FrontendPathInfo.NodePackageFile))).scripts))) !== null && _a !== void 0 ? _a : [];
        if (!("install:teamsfx" in scripts)) {
            // * Track legacy projects
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(constants_1.TelemetryEvent.InstallScriptNotFound);
        }
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.NPMInstall));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.NpmInstallError(), async () => {
            await utils_1.Utils.execute("install:teamsfx" in scripts
                ? constants_1.Commands.InstallNodePackages
                : constants_1.Commands.DefaultInstallNodePackages, componentPath);
        });
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Build));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.BuildError(), async () => {
            if ("build:teamsfx" in scripts) {
                await utils_1.Utils.execute(constants_1.Commands.BuildFrontend, componentPath, {
                    TEAMS_FX_ENV: envName,
                });
            }
            else {
                const envs = await env_1.loadEnvFile(env_1.envFilePath(envName, componentPath));
                await utils_1.Utils.execute(constants_1.Commands.DefaultBuildFrontend, componentPath, Object.assign(Object.assign({}, envs.customizedRemoteEnvs), envs.teamsfxRemoteEnvs));
            }
        });
        await FrontendDeployment.saveDeploymentInfo(componentPath, envName, {
            lastBuildTime: new Date().toISOString(),
        });
    }
    static async doFrontendBuildV3(componentPath, envName) {
        const progress = progress_helper_1.ProgressHelper.progressHandler;
        const needBuild = await FrontendDeployment.needBuild(componentPath, envName);
        if (!needBuild) {
            await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.NPMInstall));
            await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Build));
            return;
        }
        const packageJson = await fs_extra_1.default.readJSON(path_1.default.join(componentPath, constants_1.FrontendPathInfo.NodePackageFile));
        const scripts = packageJson ? packageJson.scripts || [] : [];
        if (!("install:teamsfx" in scripts)) {
            // * Track legacy projects
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(constants_1.TelemetryEvent.InstallScriptNotFound);
        }
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.NPMInstall));
        const installCmd = "install:teamsfx" in scripts
            ? constants_1.Commands.InstallNodePackages
            : constants_1.Commands.DefaultInstallNodePackages;
        await utils_1.Utils.execute(installCmd, componentPath);
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Build));
        if ("build:teamsfx" in scripts) {
            await utils_1.Utils.execute(constants_1.Commands.BuildFrontend, componentPath, {
                TEAMS_FX_ENV: envName,
            });
        }
        else {
            const envs = await env_1.loadEnvFile(env_1.envFilePath(envName, componentPath));
            await utils_1.Utils.execute(constants_1.Commands.DefaultBuildFrontend, componentPath, Object.assign(Object.assign({}, envs.customizedRemoteEnvs), envs.teamsfxRemoteEnvs));
        }
        await FrontendDeployment.saveDeploymentInfo(componentPath, envName, {
            lastBuildTime: new Date().toISOString(),
        });
    }
    static async skipBuild() {
        logger_1.Logger.info(messages_1.Messages.SkipBuild);
        const progressHandler = progress_helper_1.ProgressHelper.progressHandler;
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.NPMInstall));
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Build));
    }
    static async getBuiltPath(componentPath) {
        const builtPath = path_1.default.join(componentPath, constants_1.FrontendPathInfo.BuildPath);
        const pathExists = await fs_extra_1.default.pathExists(builtPath);
        if (!pathExists) {
            throw new errors_1.NoBuildPathError();
        }
        return builtPath;
    }
    static async doFrontendDeployment(client, componentPath, envName) {
        if (!(await FrontendDeployment.needDeploy(componentPath, envName))) {
            return FrontendDeployment.skipDeployment();
        }
        const progressHandler = progress_helper_1.ProgressHelper.progressHandler;
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.getSrcAndDest));
        const builtPath = await FrontendDeployment.getBuiltPath(componentPath);
        const container = await errors_1.runWithErrorCatchAndThrow(new errors_1.GetContainerError(), async () => await client.getContainer(constants_1.Constants.AzureStorageWebContainer));
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Clear));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.ClearStorageError(), async () => {
            await client.deleteAllBlobs(container);
        });
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Upload));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.UploadToStorageError(), async () => {
            await client.uploadFiles(container, builtPath);
        });
        await FrontendDeployment.saveDeploymentInfo(componentPath, envName, {
            lastDeployTime: new Date().toISOString(),
        });
    }
    static async doFrontendDeploymentV3(client, componentPath, envName, progress) {
        const needDeploy = await FrontendDeployment.needDeploy(componentPath, envName);
        if (!needDeploy) {
            await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.getSrcAndDest));
            await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Clear));
            await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Upload));
            return;
        }
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.getSrcAndDest));
        const builtPath = await FrontendDeployment.getBuiltPath(componentPath);
        const container = await errors_1.runWithErrorCatchAndThrow(new v3error.GetContainerError(), async () => await client.getContainer(constants_1.Constants.AzureStorageWebContainer));
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Clear));
        await errors_1.runWithErrorCatchAndThrow(new v3error.ClearStorageError(), async () => {
            await client.deleteAllBlobs(container);
        });
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.DeployProgress.steps.Upload));
        await errors_1.runWithErrorCatchAndThrow(new v3error.UploadToStorageError(), async () => {
            await client.uploadFiles(container, builtPath);
        });
        await FrontendDeployment.saveDeploymentInfo(componentPath, envName, {
            lastDeployTime: new Date().toISOString(),
        });
    }
    static async skipDeployment() {
        telemetry_helper_1.TelemetryHelper.sendGeneralEvent(constants_1.TelemetryEvent.SkipDeploy);
        logger_1.Logger.warning(messages_1.Messages.SkipDeploy);
        const progressHandler = progress_helper_1.ProgressHelper.progressHandler;
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.getSrcAndDest));
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Clear));
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.DeployProgress.steps.Upload));
    }
    static async hasUpdatedContent(componentPath, referenceTime, filter) {
        const folderFilter = (itemPath) => !constants_1.FrontendPathInfo.TabDeployIgnoreFolder.includes(path_1.default.basename(itemPath));
        let changed = false;
        await utils_1.Utils.forEachFileAndDir(componentPath, (itemPath, stats) => {
            const relativePath = path_1.default.relative(componentPath, itemPath);
            if (relativePath && referenceTime < stats.mtime && (!filter || filter(relativePath))) {
                changed = true;
                return true;
            }
        }, folderFilter);
        return changed;
    }
    static async getDeploymentInfo(componentPath, envName) {
        const deploymentDir = path_1.default.join(componentPath, constants_1.FrontendPathInfo.TabDeploymentFolderName);
        const deploymentInfoPath = path_1.default.join(deploymentDir, constants_1.FrontendPathInfo.TabDeploymentInfoFileName);
        try {
            const deploymentInfoJson = await fs_extra_1.default.readJSON(deploymentInfoPath);
            if (!deploymentInfoJson) {
                return undefined;
            }
            return deploymentInfoJson[envName];
        }
        catch (_a) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(constants_1.TelemetryEvent.DeploymentInfoNotFound);
            return undefined;
        }
    }
    static async getLastBuildTime(componentPath, envName) {
        const deploymentInfoJson = await FrontendDeployment.getDeploymentInfo(componentPath, envName);
        return (deploymentInfoJson === null || deploymentInfoJson === void 0 ? void 0 : deploymentInfoJson.lastBuildTime)
            ? new Date(deploymentInfoJson.lastBuildTime)
            : undefined;
    }
    static async getLastDeploymentTime(componentPath, envName) {
        const deploymentInfoJson = await FrontendDeployment.getDeploymentInfo(componentPath, envName);
        return (deploymentInfoJson === null || deploymentInfoJson === void 0 ? void 0 : deploymentInfoJson.lastDeployTime)
            ? new Date(deploymentInfoJson.lastDeployTime)
            : undefined;
    }
    static async saveDeploymentInfo(componentPath, envName, deploymentInfo) {
        var _a, _b, _c;
        const deploymentDir = path_1.default.join(componentPath, constants_1.FrontendPathInfo.TabDeploymentFolderName);
        const deploymentInfoPath = path_1.default.join(deploymentDir, constants_1.FrontendPathInfo.TabDeploymentInfoFileName);
        await fs_extra_1.default.ensureDir(deploymentDir);
        let deploymentInfoJson = {};
        try {
            deploymentInfoJson = await fs_extra_1.default.readJSON(deploymentInfoPath);
        }
        catch (_d) {
            // Failed to read info file, which doesn't block deployment
        }
        (_a = deploymentInfoJson[envName]) !== null && _a !== void 0 ? _a : (deploymentInfoJson[envName] = {});
        deploymentInfoJson[envName].lastBuildTime =
            (_b = deploymentInfo.lastBuildTime) !== null && _b !== void 0 ? _b : deploymentInfoJson[envName].lastBuildTime;
        deploymentInfoJson[envName].lastDeployTime =
            (_c = deploymentInfo.lastDeployTime) !== null && _c !== void 0 ? _c : deploymentInfoJson[envName].lastDeployTime;
        try {
            await fs_extra_1.default.writeJSON(deploymentInfoPath, deploymentInfoJson);
        }
        catch (_e) {
            // Failed to write deployment info, which doesn't block deployment
        }
    }
}
exports.FrontendDeployment = FrontendDeployment;
//# sourceMappingURL=deploy.js.map