// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveEnvFile = exports.loadEnvFile = exports.getEmptyEnvs = exports.EnvKeys = exports.envFilePath = exports.envFileName = exports.envFileNamePrefix = void 0;
const tslib_1 = require("tslib");
const dotenv = tslib_1.__importStar(require("dotenv"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const os = tslib_1.__importStar(require("os"));
const telemetry_helper_1 = require("./utils/telemetry-helper");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const logger_1 = require("./utils/logger");
const errors_1 = require("./resources/errors");
exports.envFileNamePrefix = `.env.teamsfx.`;
const envFileName = (envName) => exports.envFileNamePrefix + envName;
exports.envFileName = envFileName;
const envFilePath = (envName, folder) => path.join(folder, exports.envFileName(envName));
exports.envFilePath = envFilePath;
exports.EnvKeys = Object.freeze({
    FuncEndpoint: "REACT_APP_FUNC_ENDPOINT",
    FuncName: "REACT_APP_FUNC_NAME",
    RuntimeEndpoint: "REACT_APP_TEAMSFX_ENDPOINT",
    StartLoginPage: "REACT_APP_START_LOGIN_PAGE_URL",
    ClientID: "REACT_APP_CLIENT_ID",
});
const getEmptyEnvs = () => {
    return {
        teamsfxRemoteEnvs: {},
        customizedRemoteEnvs: {},
    };
};
exports.getEmptyEnvs = getEmptyEnvs;
async function loadEnvFile(envPath) {
    try {
        return await _loadEnvFile(envPath);
    }
    catch (e) {
        logger_1.Logger.error(e.toString());
        const error = new errors_1.FileIOError(errors_1.ErrorMessages.FailedLoadEnv(envPath));
        logger_1.Logger.error(error.toString());
        telemetry_helper_1.TelemetryHelper.sendErrorEvent(constants_1.TelemetryEvent.LoadEnvFile, error);
    }
    return exports.getEmptyEnvs();
}
exports.loadEnvFile = loadEnvFile;
async function _loadEnvFile(envPath) {
    const result = exports.getEmptyEnvs();
    if (!(await fs_extra_1.default.pathExists(envPath))) {
        return result;
    }
    const envs = dotenv.parse(await fs_extra_1.default.readFile(envPath));
    const entries = Object.entries(envs);
    for (const [key, value] of entries) {
        if (Object.values(exports.EnvKeys).includes(key)) {
            result.teamsfxRemoteEnvs[key] = value;
        }
        else {
            result.customizedRemoteEnvs[key] = value;
        }
    }
    return result;
}
async function saveEnvFile(envPath, envs) {
    const configs = await loadEnvFile(envPath);
    try {
        return await _saveEnvFile(envPath, envs, configs);
    }
    catch (e) {
        logger_1.Logger.error(e.toString());
        const error = new errors_1.FileIOError(errors_1.ErrorMessages.FailedSaveEnv(envPath));
        logger_1.Logger.error(error.toString());
        telemetry_helper_1.TelemetryHelper.sendErrorEvent(constants_1.TelemetryEvent.SaveEnvFile, error);
    }
}
exports.saveEnvFile = saveEnvFile;
async function _saveEnvFile(envPath, envs, configs) {
    const newConfigs = {
        teamsfxRemoteEnvs: Object.assign(Object.assign({}, configs.teamsfxRemoteEnvs), envs.teamsfxRemoteEnvs),
        customizedRemoteEnvs: Object.assign(Object.assign({}, configs.customizedRemoteEnvs), envs.customizedRemoteEnvs),
    };
    if (utils_1.Utils.isKvPairEqual(newConfigs.teamsfxRemoteEnvs, configs.teamsfxRemoteEnvs) &&
        utils_1.Utils.isKvPairEqual(newConfigs.customizedRemoteEnvs, configs.customizedRemoteEnvs) &&
        (await fs_extra_1.default.pathExists(envPath))) {
        // Avoid updating dotenv file's modified time if path already exists and nothing changes.
        // We decide whether to skip deployment by comparing the mtime of all project files and last deployment time.
        return;
    }
    await fs_extra_1.default.ensureFile(envPath);
    const envString = `# Following variables are generated by TeamsFx${os.EOL}` +
        concatEnvString(newConfigs.teamsfxRemoteEnvs) +
        `${os.EOL}# Following variables can be customized or you can add your owns${os.EOL}` +
        `# FOO=BAR${os.EOL}` +
        concatEnvString(newConfigs.customizedRemoteEnvs);
    await fs_extra_1.default.writeFile(envPath, envString);
}
function concatEnvString(envs) {
    return (Object.entries(envs)
        .map(([k, v]) => `${k}=${v}`)
        .join(os.EOL) + os.EOL);
}
//# sourceMappingURL=env.js.map