"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const path = tslib_1.__importStar(require("path"));
const os_1 = tslib_1.__importDefault(require("os"));
const child_process_1 = require("child_process");
const glob_1 = tslib_1.__importDefault(require("glob"));
const constants_1 = require("./constants");
const logger_1 = require("./utils/logger");
const klaw_1 = tslib_1.__importDefault(require("klaw"));
class Utils {
    static async delays(millisecond) {
        return await new Promise((resolve) => setTimeout(resolve, millisecond));
    }
    static normalize(raw) {
        return raw.replace(constants_1.RegularExpr.AllCharToBeSkippedInName, constants_1.Constants.EmptyString).toLowerCase();
    }
    static capitalizeFirstLetter([first, ...rest]) {
        return [first === null || first === void 0 ? void 0 : first.toUpperCase(), ...rest].join("");
    }
    static generateStorageAccountName(appName, identSuffix, classSuffix) {
        const suffix = Utils.normalize(classSuffix + identSuffix).substr(0, constants_1.Constants.SuffixLenMax);
        const paddingLength = constants_1.Constants.AzureStorageAccountNameLenMax - suffix.length;
        const normalizedAppName = Utils.normalize(appName).substr(0, paddingLength);
        return normalizedAppName + suffix;
    }
    static async requestWithRetry(request, maxTryCount = constants_1.Constants.RequestTryCounts) {
        var _a;
        // !status means network error, see https://github.com/axios/axios/issues/383
        const canTry = (status) => !status || (status >= 500 && status < 600);
        let tryCount = 0;
        let error = new Error();
        while (tryCount++ < maxTryCount) {
            try {
                const result = await request();
                if (result.status === 200 || result.status === 201) {
                    return result;
                }
                error = new Error(`HTTP Request failed: ${JSON.stringify(result)}`);
                if (!canTry(result.status)) {
                    break;
                }
            }
            catch (e) {
                error = e;
                if (!canTry((_a = e.response) === null || _a === void 0 ? void 0 : _a.status)) {
                    break;
                }
            }
        }
        throw error;
    }
    static async execute(command, workingDir, env) {
        return new Promise((resolve, reject) => {
            logger_1.Logger.info(`Start to run command: "${command}".`);
            // Drive letter should be uppercase, otherwise when we run webpack in exec, it fails to resolve nested dependencies.
            if (os_1.default.platform() === "win32") {
                workingDir = this.capitalizeFirstLetter(path.resolve(workingDir !== null && workingDir !== void 0 ? workingDir : constants_1.Constants.EmptyString));
            }
            child_process_1.exec(command, { cwd: workingDir, env: Object.assign(Object.assign({}, process.env), env) }, (error, standardOutput, stderr) => {
                logger_1.Logger.debug(standardOutput);
                if (error) {
                    logger_1.Logger.error(`Failed to run command: "${command}".`);
                    if (stderr) {
                        logger_1.Logger.error(stderr);
                    }
                    logger_1.Logger.error(error.message);
                    reject(error);
                }
                resolve(standardOutput);
            });
        });
    }
    static async listFilePaths(directoryPath, matchPattern = "**", ignorePattern) {
        return new Promise((resolve, reject) => {
            const ignore = ignorePattern ? path.join(directoryPath, ignorePattern) : "";
            glob_1.default(path.join(directoryPath, matchPattern), {
                dot: true,
                nodir: true,
                ignore,
            }, (error, filePaths) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(filePaths);
                }
            });
        });
    }
    static async forEachFileAndDir(root, callback, filter) {
        await new Promise((resolve, reject) => {
            const stream = klaw_1.default(root, { filter: filter });
            stream
                .on("data", (item) => {
                if (callback(item.path, item.stats)) {
                    stream.emit("close");
                }
            })
                .on("end", () => resolve({}))
                .on("error", (err) => reject(err))
                .on("close", () => resolve({}));
        });
    }
    static isKvPairEqual(kv1, kv2) {
        const _compare = (l, r) => {
            for (const key of Object.keys(l)) {
                if (r[key] != l[key]) {
                    return false;
                }
            }
            return true;
        };
        return _compare(kv1, kv2) && _compare(kv2, kv1);
    }
}
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map