"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipDeploy = exports.generateZip = exports.build = exports.getFrameworkVersion = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const templatesUtils_1 = require("../../../../../common/template-utils/templatesUtils");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("../resources/errors");
const constants_1 = require("../constants");
const dir_walk_1 = require("../../../function/utils/dir-walk");
const logger_1 = require("../../utils/logger");
const messages_1 = require("../resources/messages");
const progress_helper_1 = require("../../utils/progress-helper");
const steps_1 = require("../resources/steps");
const utils_1 = require("../../utils");
async function getFrameworkVersion(projectFilePath) {
    const content = await fs_extra_1.default.readFile(projectFilePath, "utf8");
    const framework = content.match(constants_1.RegularExpr.targetFramework);
    if (framework === null || framework === void 0 ? void 0 : framework.length) {
        return framework[0].trim();
    }
    return constants_1.DotnetPluginInfo.defaultFramework;
}
exports.getFrameworkVersion = getFrameworkVersion;
async function build(path, runtime) {
    var _a;
    (_a = progress_helper_1.ProgressHelper.progressHandler) === null || _a === void 0 ? void 0 : _a.next(steps_1.WebappDeployProgress.steps.build);
    logger_1.Logger.info(messages_1.Messages.Build(path));
    const command = constants_1.DotnetCommands.buildRelease(runtime);
    await errors_1.runWithErrorCatchAndWrap((error) => new errors_1.BuildError(error), async () => await utils_1.Utils.execute(command, path));
}
exports.build = build;
async function generateZip(componentPath) {
    const zip = new adm_zip_1.default();
    const tasks = [];
    const zipFiles = new Set();
    const addFileIntoZip = async (zip, filePath, zipPath) => {
        const content = await fs_extra_1.default.readFile(filePath);
        zip.addFile(zipPath, content);
    };
    await dir_walk_1.forEachFileAndDir(componentPath, (itemPath, stats) => {
        const relativePath = path.relative(componentPath, itemPath);
        if (relativePath && !stats.isDirectory()) {
            zipFiles.add(relativePath);
            // If fail to reuse cached entry, load it from disk.
            const fullPath = path.join(componentPath, relativePath);
            const task = addFileIntoZip(zip, fullPath, relativePath);
            tasks.push(task);
        }
    });
    await Promise.all(tasks);
    return zip;
}
exports.generateZip = generateZip;
async function zipDeploy(client, resourceGroupName, webAppName, componentPath) {
    var _a, _b, _c;
    logger_1.Logger.info(messages_1.Messages.GenerateZip(componentPath));
    (_a = progress_helper_1.ProgressHelper.progressHandler) === null || _a === void 0 ? void 0 : _a.next(steps_1.WebappDeployProgress.steps.generateZip);
    const zip = await errors_1.runWithErrorCatchAndThrow(new errors_1.ZipError(), async () => await generateZip(componentPath));
    const zipContent = zip.toBuffer();
    (_b = progress_helper_1.ProgressHelper.progressHandler) === null || _b === void 0 ? void 0 : _b.next(steps_1.WebappDeployProgress.steps.fetchCredential);
    const publishCred = await errors_1.runWithErrorCatchAndThrow(new errors_1.PublishCredentialError(), async () => await client.webApps.listPublishingCredentials(resourceGroupName, webAppName));
    const username = publishCred.publishingUserName;
    const password = publishCred.publishingPassword;
    if (!password) {
        logger_1.Logger.error(messages_1.Messages.FailQueryPublishCred);
        throw new errors_1.PublishCredentialError();
    }
    logger_1.Logger.info(messages_1.Messages.UploadZip(zipContent.length));
    (_c = progress_helper_1.ProgressHelper.progressHandler) === null || _c === void 0 ? void 0 : _c.next(steps_1.WebappDeployProgress.steps.deploy);
    await errors_1.runWithErrorCatchAndThrow(new errors_1.UploadZipError(), async () => await templatesUtils_1.sendRequestWithRetry(async () => await axios_1.default.post(constants_1.AzureInfo.zipDeployURL(webAppName), zipContent, {
        headers: {
            "Content-Type": "application/octet-stream",
            "Cache-Control": "no-cache",
        },
        auth: {
            username: username,
            password: password,
        },
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        timeout: 10 * 60 * 1000,
    }), 3));
}
exports.zipDeploy = zipDeploy;
//# sourceMappingURL=deploy.js.map