"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotnetPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("./constants");
const messages_1 = require("./resources/messages");
const scaffold_1 = require("./ops/scaffold");
const azure_client_1 = require("./utils/azure-client");
const enum_1 = require("./enum");
const errors_1 = require("./resources/errors");
const Deploy = tslib_1.__importStar(require("./ops/deploy"));
const logger_1 = require("../utils/logger");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const folder_1 = require("../../../../folder");
const tools_1 = require("../../../../common/tools");
const templateInfo_1 = require("./resources/templateInfo");
const constants_2 = require("../../../../common/constants");
const ResourcePluginContainer_1 = require("../../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../../solution/fx-solution/v2/adaptor");
const progress_helper_1 = require("../utils/progress-helper");
const steps_1 = require("./resources/steps");
const question_1 = require("../../../solution/fx-solution/question");
const constants_3 = require("../../../solution/fx-solution/constants");
const question_2 = require("../../../../core/question");
const utils_1 = require("../../../../common/utils");
class DotnetPluginImpl {
    syncConfigFromContext(ctx) {
        var _a, _b;
        const config = {};
        const solutionConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.solutionPluginName);
        config.resourceGroupName = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.resourceGroupName);
        config.subscriptionId = solutionConfig === null || solutionConfig === void 0 ? void 0 : solutionConfig.get(constants_1.DependentPluginInfo.subscriptionId);
        config.webAppName = ctx.config.get(constants_1.DotnetConfigInfo.webAppName);
        config.appServicePlanName = ctx.config.get(constants_1.DotnetConfigInfo.appServicePlanName);
        config.projectFilePath = (_b = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.pluginSettings) === null || _b === void 0 ? void 0 : _b.projectFilePath;
        // Resource id priors to other configs
        const webAppResourceId = ctx.config.get(enum_1.DotnetConfigKey.webAppResourceId);
        if (webAppResourceId) {
            config.webAppResourceId = webAppResourceId;
            config.resourceGroupName = tools_1.getResourceGroupNameFromResourceId(webAppResourceId);
            config.webAppName = tools_1.getSiteNameFromResourceId(webAppResourceId);
            config.subscriptionId = tools_1.getSubscriptionIdFromResourceId(webAppResourceId);
        }
        return config;
    }
    checkAndGet(v, key) {
        if (v) {
            return v;
        }
        throw new errors_1.FetchConfigError(key);
    }
    async scaffold(ctx) {
        var _a, _b, _c, _d, _e;
        logger_1.Logger.info(messages_1.Messages.StartScaffold);
        if (!ctx.projectSettings) {
            throw new errors_1.NoProjectSettingError();
        }
        const projectName = ctx.projectSettings.appName;
        const safeProjectName = (_b = (_a = ctx.answers) === null || _a === void 0 ? void 0 : _a[question_2.CoreQuestionNames.SafeProjectName]) !== null && _b !== void 0 ? _b : utils_1.convertToAlphanumericOnly(projectName);
        const capabilities = (_d = (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.solutionSettings) === null || _d === void 0 ? void 0 : _d.capabilities;
        await scaffold_1.scaffoldFromZipPackage(ctx.root, new templateInfo_1.TemplateInfo({ ProjectName: projectName, SafeProjectName: safeProjectName }, tools_1.isAadManifestEnabled() && !capabilities.includes(question_1.TabSsoItem.id)
            ? templateInfo_1.TemplateInfo.NoneSsoScenario
            : templateInfo_1.TemplateInfo.DefaultScenario));
        ctx.projectSettings.pluginSettings = Object.assign(Object.assign({}, (_e = ctx.projectSettings) === null || _e === void 0 ? void 0 : _e.pluginSettings), { projectFilePath: path_1.default.resolve(ctx.root, constants_1.DotnetPathInfo.projectFilename(projectName)) });
        logger_1.Logger.info(messages_1.Messages.EndScaffold);
        return teamsfx_api_1.ok(undefined);
    }
    async generateArmTemplates(ctx) {
        var _a, _b, _c, _d;
        if (((_b = (_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.existingCapabilities) === null || _b === void 0 ? void 0 : _b.includes(question_1.BotOptionItem.id)) ||
            ((_d = (_c = ctx.answers) === null || _c === void 0 ? void 0 : _c.existingCapabilities) === null || _d === void 0 ? void 0 : _d.includes(question_1.TabOptionItem.id))) {
            return teamsfx_api_1.ok({});
        }
        logger_1.Logger.info(messages_1.Messages.StartGenerateArmTemplates);
        const bicepTemplateDirectory = constants_1.DotnetPathInfo.bicepTemplateFolder(folder_1.getTemplatesFolder());
        const provisionTemplateFilePath = path_1.default.join(bicepTemplateDirectory, constants_2.Bicep.ProvisionFileName);
        const provisionWebappTemplateFilePath = path_1.default.join(bicepTemplateDirectory, constants_1.WebappBicepFile.provisionTemplateFileName);
        const configTemplateFilePath = path_1.default.join(bicepTemplateDirectory, constants_2.Bicep.ConfigFileName);
        const configWebappTemplateFilePath = path_1.default.join(bicepTemplateDirectory, constants_1.WebappBicepFile.configurationTemplateFileName);
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionTemplateFilePath, pluginCtx);
        const provisionModule = await tools_1.generateBicepFromFile(provisionWebappTemplateFilePath, pluginCtx);
        const configOrchestration = await tools_1.generateBicepFromFile(configTemplateFilePath, pluginCtx);
        const configModule = await tools_1.generateBicepFromFile(configWebappTemplateFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { webapp: provisionModule },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { webapp: configModule },
            },
            Reference: constants_1.WebappBicep.Reference,
        };
        logger_1.Logger.info(messages_1.Messages.EndGenerateArmTemplates);
        return teamsfx_api_1.ok(result);
    }
    async updateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.EndUpdateArmTemplates);
        const bicepTemplateDirectory = constants_1.DotnetPathInfo.bicepTemplateFolder(folder_1.getTemplatesFolder());
        const configWebappTemplateFilePath = path_1.default.join(bicepTemplateDirectory, constants_1.WebappBicepFile.configurationTemplateFileName);
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const configModule = await tools_1.generateBicepFromFile(configWebappTemplateFilePath, pluginCtx);
        const result = {
            Reference: constants_1.WebappBicep.Reference,
            Configuration: {
                Modules: { webapp: configModule },
            },
        };
        logger_1.Logger.info(messages_1.Messages.EndUpdateArmTemplates);
        return teamsfx_api_1.ok(result);
    }
    async localDebug(ctx) {
        var _a;
        (_a = ctx.envInfo.state.get(constants_1.DotnetPluginInfo.pluginName)) === null || _a === void 0 ? void 0 : _a.set(constants_1.DotnetConfigInfo.indexPath, constants_1.DotnetPathInfo.indexPath);
        return teamsfx_api_1.ok(undefined);
    }
    async postLocalDebug(ctx) {
        var _a, _b, _c, _d, _e;
        const appSettingsPath = path_1.default.join(ctx.root, constants_1.DotnetPathInfo.appSettingDevelopment);
        let appSettings;
        if (!(await errors_1.runWithErrorCatchAndThrow(new errors_1.FileIOError(appSettingsPath), async () => await fs_extra_1.default.pathExists(appSettingsPath)))) {
            // if appsetting file not exist, generate a new one
            // TODO(qidon): load content from resource file or template
            appSettings =
                '\
{\r\n\
  "Logging": {\r\n\
    "LogLevel": {\r\n\
      "Default": "Information",\r\n\
      "Microsoft": "Warning",\r\n\
      "Microsoft.Hosting.Lifetime": "Information"\r\n\
    }\r\n\
  },\r\n\
  "AllowedHosts": "*",\r\n\
  "TeamsFx": {\r\n\
    "Authentication": {\r\n\
      "ClientId": "$clientId$",\r\n\
      "ClientSecret": "$client-secret$",\r\n\
      "OAuthAuthority": "$oauthAuthority$"\r\n\
    }\r\n\
  }\r\n\
}\r\n';
        }
        else {
            appSettings = await errors_1.runWithErrorCatchAndThrow(new errors_1.FileIOError(appSettingsPath), async () => await fs_extra_1.default.readFile(appSettingsPath, "utf-8"));
        }
        const clientId = (_b = (_a = ctx.envInfo.state.get(constants_3.PluginNames.AAD)) === null || _a === void 0 ? void 0 : _a.get(constants_1.DependentPluginInfo.aadClientId)) !== null && _b !== void 0 ? _b : constants_1.AppSettingsPlaceholders.clientId;
        const clientSecret = (_d = (_c = ctx.envInfo.state.get(constants_3.PluginNames.AAD)) === null || _c === void 0 ? void 0 : _c.get(constants_1.DependentPluginInfo.aadClientSecret)) !== null && _d !== void 0 ? _d : constants_1.AppSettingsPlaceholders.clientSecret;
        const tenantId = (_e = ctx.envInfo.state
            .get(constants_3.PluginNames.SOLUTION)) === null || _e === void 0 ? void 0 : _e.get(constants_1.DependentPluginInfo.appTenantId);
        const oauthAuthority = tenantId ? constants_1.DotnetPathInfo.oauthHost(tenantId) : constants_1.AppSettingsPlaceholders.oauthAuthority;
        appSettings = appSettings.replace(constants_1.RegularExpr.clientId, clientId);
        appSettings = appSettings.replace(constants_1.RegularExpr.clientSecret, clientSecret);
        appSettings = appSettings.replace(constants_1.RegularExpr.oauthAuthority, oauthAuthority);
        await errors_1.runWithErrorCatchAndThrow(new errors_1.FileIOError(appSettingsPath), async () => await fs_extra_1.default.writeFile(appSettingsPath, appSettings, "utf-8"));
        return teamsfx_api_1.ok(undefined);
    }
    async postProvision(ctx) {
        return teamsfx_api_1.ok(undefined);
    }
    async preDeploy(ctx) {
        return teamsfx_api_1.ok(undefined);
    }
    async executeUserTask(func, ctx) {
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(ctx) {
        var _a;
        logger_1.Logger.info(messages_1.Messages.StartDeploy);
        await progress_helper_1.ProgressHelper.startProgress(ctx.ui, steps_1.WebappDeployProgress);
        const config = this.syncConfigFromContext(ctx);
        const webAppName = this.checkAndGet(config.webAppName, enum_1.DotnetConfigKey.webAppName);
        const resourceGroupName = this.checkAndGet(config.resourceGroupName, enum_1.DotnetConfigKey.resourceGroupName);
        const subscriptionId = this.checkAndGet(config.subscriptionId, enum_1.DotnetConfigKey.subscriptionId);
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enum_1.DotnetConfigKey.credential);
        const projectFilePath = path_1.default.resolve(ctx.root, this.checkAndGet(config.projectFilePath, enum_1.DotnetConfigKey.projectFilePath));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.ProjectPathError(projectFilePath), async () => await fs_extra_1.default.pathExists(projectFilePath));
        const projectPath = path_1.default.dirname(projectFilePath);
        const runtime = constants_1.DotnetPluginInfo.defaultRuntime;
        const client = azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId);
        await Deploy.build(projectPath, runtime);
        const folderToBeZipped = constants_1.DotnetPathInfo.publishFolderPath(projectPath);
        await Deploy.zipDeploy(client, resourceGroupName, webAppName, folderToBeZipped);
        await progress_helper_1.ProgressHelper.endProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndDeploy);
        return teamsfx_api_1.ok(undefined);
    }
}
exports.DotnetPluginImpl = DotnetPluginImpl;
//# sourceMappingURL=plugin.js.map