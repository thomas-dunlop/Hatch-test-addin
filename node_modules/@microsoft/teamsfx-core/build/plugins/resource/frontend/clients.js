"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageClient = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const storage_blob_1 = require("@azure/storage-blob");
const arm_resources_1 = require("@azure/arm-resources");
const arm_storage_1 = require("@azure/arm-storage");
const mime = tslib_1.__importStar(require("mime"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("./constants");
const logger_1 = require("./utils/logger");
const messages_1 = require("./resources/messages");
const utils_1 = require("./utils");
class AzureStorageClient {
    constructor(config) {
        this.resourceGroupName = config.resourceGroupName;
        this.storageName = config.storageName;
        this.location = config.location;
        this.resourceGroupClient = new arm_resources_1.ResourceGroups(new arm_resources_1.ResourceManagementClientContext(config.credentials, config.subscriptionId));
        this.storageAccountClient = new arm_storage_1.StorageManagementClient(config.credentials, config.subscriptionId).storageAccounts;
    }
    async doesResourceGroupExists() {
        logger_1.Logger.debug(messages_1.Messages.StartCheckResourceGroupExistence(this.resourceGroupName));
        const result = await this.resourceGroupClient.checkExistence(this.resourceGroupName);
        return result.body;
    }
    async doesStorageAccountExists() {
        const result = await this.storageAccountClient.listByResourceGroup(this.resourceGroupName);
        if (result.find((storage) => storage.name === this.storageName)) {
            return true;
        }
        return false;
    }
    async isStorageStaticWebsiteEnabled() {
        var _a;
        logger_1.Logger.debug(messages_1.Messages.StartCheckStaticWebsiteEnabled(this.storageName));
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        const result = (_a = (await blobClient.getProperties()).staticWebsite) === null || _a === void 0 ? void 0 : _a.enabled;
        return result;
    }
    async createStorageAccount() {
        var _a;
        logger_1.Logger.debug(messages_1.Messages.StartCreateStorageAccount(this.storageName, this.resourceGroupName));
        const parameters = AzureStorageClient.getStorageAccountCreateParams(this.location);
        const response = await this.storageAccountClient.create(this.resourceGroupName, this.storageName, parameters);
        const endpoint = (_a = response.primaryEndpoints) === null || _a === void 0 ? void 0 : _a.web;
        if (!endpoint) {
            throw new Error(messages_1.Messages.GetEmptyStorageEndpoint);
        }
        return endpoint.endsWith("/") ? endpoint.substring(0, endpoint.length - 1) : endpoint;
    }
    async enableStaticWebsite() {
        logger_1.Logger.debug(messages_1.Messages.StartEnableStaticWebsite(this.storageName));
        if (await this.isStorageStaticWebsiteEnabled()) {
            logger_1.Logger.debug(messages_1.Messages.SkipEnableStaticWebsite(this.storageName));
            return;
        }
        const properties = AzureStorageClient.getStaticWebsiteEnableParams();
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        return blobClient.setProperties(properties);
    }
    async getContainer(containerName) {
        const blobClient = await AzureStorageClient.getBlobServiceClient(AzureStorageClient.getBlobUri(this.storageName), await AzureStorageClient.generateSasToken(this.storageAccountClient, this.resourceGroupName, this.storageName));
        const container = blobClient.getContainerClient(containerName);
        if (!(await container.exists())) {
            await container.create();
        }
        return container;
    }
    async deleteAllBlobs(client) {
        var e_1, _a;
        logger_1.Logger.debug(messages_1.Messages.StartDeleteAllBlobs(this.storageName, constants_1.Constants.AzureStorageWebContainer));
        const deleteJobs = [];
        try {
            for (var _b = tslib_1.__asyncValues(client.listBlobsFlat()), _c; _c = await _b.next(), !_c.done;) {
                const blob = _c.value;
                if (AzureStorageClient.isBlobFile(blob)) {
                    deleteJobs.push(client.deleteBlob(blob.name));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        const responses = await Promise.all(deleteJobs);
        const errorResponse = responses.find((res) => res.errorCode !== undefined);
        if (errorResponse) {
            throw new Error(messages_1.Messages.FailedOperationWithErrorCode("delete blob", errorResponse.errorCode));
        }
    }
    async uploadFiles(client, sourceFolder) {
        logger_1.Logger.debug(messages_1.Messages.StartSyncLocalToStorage(sourceFolder, this.storageName));
        const filePathsToUpload = await utils_1.Utils.listFilePaths(sourceFolder);
        const responses = await Promise.all(filePathsToUpload.map((filePath) => {
            const destFilePath = path.relative(sourceFolder, filePath);
            return AzureStorageClient.uploadLocalFile(client, filePath, destFilePath);
        }));
        const errorResponse = responses.find((res) => res.errorCode !== undefined);
        if (errorResponse) {
            throw new Error(messages_1.Messages.FailedOperationWithErrorCode("upload file", errorResponse.errorCode));
        }
    }
    static isBlobFile(blob) {
        return blob.properties.contentLength !== undefined && blob.properties.contentLength > 0;
    }
    static uploadLocalFile(client, filePath, blobPath) {
        const blockBlobClient = client.getBlockBlobClient(blobPath);
        const options = {
            blobHTTPHeaders: {
                blobContentType: mime.getType(blobPath) || undefined,
            },
        };
        return blockBlobClient.uploadFile(filePath, options);
    }
    static async getBlobServiceClient(blobUri, sasToken) {
        const connectionString = `BlobEndpoint=${blobUri};SharedAccessSignature=${sasToken}`;
        return storage_blob_1.BlobServiceClient.fromConnectionString(connectionString);
    }
    static getBlobUri(storageName) {
        return `https://${storageName}.blob.core.windows.net`;
    }
    static async generateSasToken(client, resourceGroupName, storageName) {
        const accountSasParameters = {
            // A workaround, to ignore type checking for the services/resourceTypes/permissions are enum type.
            services: "bf",
            resourceTypes: "sco",
            permissions: "rwld",
            sharedAccessStartTime: new Date(Date.now() - constants_1.Constants.SasTokenLifetimePadding),
            sharedAccessExpiryTime: new Date(Date.now() + constants_1.Constants.SasTokenLifetime),
        };
        const token = (await client.listAccountSAS(resourceGroupName, storageName, accountSasParameters)).accountSasToken;
        if (!token) {
            throw new Error(messages_1.Messages.GetEmptySasToken);
        }
        return token;
    }
    static getStorageAccountCreateParams(location) {
        return {
            sku: {
                name: constants_1.Constants.AzureStorageDefaultSku,
                tier: constants_1.Constants.AzureStorageDefaultTier,
            },
            kind: constants_1.Constants.AzureStorageDefaultKind,
            location: location,
            enableHttpsTrafficOnly: true,
            isHnsEnabled: false,
        };
    }
    static getStaticWebsiteEnableParams() {
        return {
            staticWebsite: {
                indexDocument: constants_1.Constants.FrontendIndexDocument,
                errorDocument404Path: constants_1.Constants.FrontendErrorDocument,
                enabled: true,
            },
        };
    }
}
exports.AzureStorageClient = AzureStorageClient;
//# sourceMappingURL=clients.js.map