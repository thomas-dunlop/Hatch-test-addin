"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrontendPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const clients_1 = require("./clients");
const errors_1 = require("./resources/errors");
const constants_1 = require("./constants");
const configs_1 = require("./configs");
const deploy_1 = require("./ops/deploy");
const logger_1 = require("./utils/logger");
const messages_1 = require("./resources/messages");
const scaffold_1 = require("./ops/scaffold");
const progress_helper_1 = require("./utils/progress-helper");
const steps_1 = require("./resources/steps");
const templateInfo_1 = require("./resources/templateInfo");
const folder_1 = require("../../../folder");
const constants_2 = require("../../../common/constants");
const question_1 = require("../../solution/fx-solution/question");
const env_1 = require("./env");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../solution/fx-solution/v2/adaptor");
const tools_1 = require("../../../common/tools");
const constants_3 = require("../appstudio/constants");
class FrontendPluginImpl {
    async scaffold(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartScaffold(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.startProgress(ctx.ui, steps_1.ScaffoldProgress);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.ScaffoldProgress.steps.Scaffold));
        const templateInfo = new templateInfo_1.TemplateInfo(ctx);
        await scaffold_1.FrontendScaffold.scaffoldFromZipPackage(path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir), templateInfo);
        await progress_helper_1.ProgressHelper.endProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndScaffold(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async postProvision(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartPostProvision(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.startProgress(ctx.ui, steps_1.PostProvisionProgress);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.PostProvisionProgress.steps.EnableStaticWebsite));
        const client = new clients_1.AzureStorageClient(await configs_1.FrontendConfig.fromPluginContext(ctx));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.EnableStaticWebsiteError(), async () => await client.enableStaticWebsite());
        await progress_helper_1.ProgressHelper.endProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndPostProvision(constants_1.FrontendPluginInfo.DisplayName));
        await this.updateDotEnv(ctx);
        return teamsfx_api_1.ok(undefined);
    }
    async preDeploy(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartPreDeploy(constants_1.FrontendPluginInfo.DisplayName));
        const progressHandler = await progress_helper_1.ProgressHelper.startProgress(ctx.ui, steps_1.PreDeployProgress);
        await this.updateDotEnv(ctx);
        await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(steps_1.PreDeployProgress.steps.CheckStorage));
        await this.checkStorageAvailability(ctx);
        await progress_helper_1.ProgressHelper.endProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndPreDeploy(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartDeploy(constants_1.FrontendPluginInfo.DisplayName));
        await progress_helper_1.ProgressHelper.startProgress(ctx.ui, steps_1.DeployProgress);
        const config = await configs_1.FrontendConfig.fromPluginContext(ctx);
        const client = new clients_1.AzureStorageClient(config);
        const componentPath = path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir);
        const envName = ctx.envInfo.envName;
        await deploy_1.FrontendDeployment.doFrontendBuild(componentPath, envName);
        await deploy_1.FrontendDeployment.doFrontendDeployment(client, componentPath, envName);
        await progress_helper_1.ProgressHelper.endProgress(true);
        logger_1.Logger.info(messages_1.Messages.EndDeploy(constants_1.FrontendPluginInfo.DisplayName));
        return teamsfx_api_1.ok(undefined);
    }
    async updateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartUpdateArmTemplates(constants_1.FrontendPluginInfo.DisplayName));
        const result = {
            Reference: {
                endpoint: constants_1.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_1.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok(result);
    }
    async generateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.StartGenerateArmTemplates(constants_1.FrontendPluginInfo.DisplayName));
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const bicepTemplateDir = path_1.default.join(folder_1.getTemplatesFolder(), constants_1.FrontendPathInfo.BicepTemplateRelativeDir);
        const provisionFilePath = path_1.default.join(bicepTemplateDir, constants_2.Bicep.ProvisionFileName);
        const moduleProvisionFilePath = path_1.default.join(bicepTemplateDir, constants_1.FrontendPathInfo.ModuleProvisionFileName);
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionFilePath, pluginCtx);
        const provisionModules = await tools_1.generateBicepFromFile(moduleProvisionFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { frontendHosting: provisionModules },
            },
            Reference: {
                endpoint: constants_1.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_1.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok(result);
    }
    async localDebug(ctx) {
        var _a;
        (_a = ctx.envInfo.state
            .get(constants_1.FrontendPluginInfo.PluginName)) === null || _a === void 0 ? void 0 : _a.set(constants_3.FRONTEND_INDEX_PATH, constants_1.Constants.FrontendIndexPath);
        return teamsfx_api_1.ok(undefined);
    }
    async postLocalDebug(ctx) {
        return teamsfx_api_1.ok(undefined);
    }
    collectEnvs(ctx) {
        var _a, _b, _c, _d, _e, _f, _g;
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        const solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
        if ((_b = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.azureResources) === null || _b === void 0 ? void 0 : _b.includes(question_1.AzureResourceFunction.id)) {
            addToEnvs(env_1.EnvKeys.FuncName, (_c = ctx.projectSettings) === null || _c === void 0 ? void 0 : _c.defaultFunctionName);
            addToEnvs(env_1.EnvKeys.FuncEndpoint, (_d = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.FunctionPluginName)) === null || _d === void 0 ? void 0 : _d.get(constants_1.DependentPluginInfo.FunctionEndpoint));
        }
        if (tools_1.IsSimpleAuthEnabled(ctx.projectSettings)) {
            addToEnvs(env_1.EnvKeys.RuntimeEndpoint, (_e = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.RuntimePluginName)) === null || _e === void 0 ? void 0 : _e.get(constants_1.DependentPluginInfo.RuntimeEndpoint));
        }
        if ((_f = solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins) === null || _f === void 0 ? void 0 : _f.includes(constants_1.DependentPluginInfo.AADPluginName)) {
            addToEnvs(env_1.EnvKeys.ClientID, (_g = ctx.envInfo.state
                .get(constants_1.DependentPluginInfo.AADPluginName)) === null || _g === void 0 ? void 0 : _g.get(constants_1.DependentPluginInfo.ClientID));
            addToEnvs(env_1.EnvKeys.StartLoginPage, constants_1.DependentPluginInfo.StartLoginPageURL);
        }
        return envs;
    }
    async updateDotEnv(ctx) {
        const envs = this.collectEnvs(ctx);
        await env_1.saveEnvFile(env_1.envFilePath(ctx.envInfo.envName, path_1.default.join(ctx.root, constants_1.FrontendPathInfo.WorkingDir)), {
            teamsfxRemoteEnvs: envs,
            customizedRemoteEnvs: {},
        });
    }
    async checkStorageAvailability(ctx) {
        const client = new clients_1.AzureStorageClient(await configs_1.FrontendConfig.fromPluginContext(ctx));
        await this.ensureResourceGroupExists(client);
        await this.ensureStorageExists(client);
        await this.ensureStorageAvailable(client);
    }
    async ensureResourceGroupExists(client) {
        const resourceGroupExists = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckResourceGroupError(), async () => await client.doesResourceGroupExists());
        if (!resourceGroupExists) {
            throw new errors_1.NoResourceGroupError();
        }
    }
    async ensureStorageExists(client) {
        const storageExists = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckStorageError(), async () => await client.doesStorageAccountExists());
        if (!storageExists) {
            throw new errors_1.NoStorageError();
        }
    }
    async ensureStorageAvailable(client) {
        const storageAvailable = await errors_1.runWithErrorCatchAndThrow(new errors_1.CheckStorageError(), async () => await client.isStorageStaticWebsiteEnabled());
        if (!storageAvailable) {
            throw new errors_1.StaticWebsiteDisabledError();
        }
    }
}
exports.FrontendPluginImpl = FrontendPluginImpl;
//# sourceMappingURL=plugin.js.map