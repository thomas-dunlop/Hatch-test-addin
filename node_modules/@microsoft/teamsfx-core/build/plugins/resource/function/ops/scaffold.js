"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionScaffold = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../constants");
const enums_1 = require("../enums");
const message_1 = require("../resources/message");
const language_strategy_1 = require("../language-strategy");
const logger_1 = require("../utils/logger");
const steps_1 = require("../resources/steps");
const errors_1 = require("../resources/errors");
const telemetry_helper_1 = require("../utils/telemetry-helper");
const templatesActions_1 = require("../../../../common/template-utils/templatesActions");
class FunctionScaffold {
    static convertTemplateLanguage(language) {
        switch (language) {
            case enums_1.FunctionLanguage.JavaScript:
                return "js";
            case enums_1.FunctionLanguage.TypeScript:
                return "ts";
        }
    }
    static async doesFunctionPathExist(componentPath, language, entryName) {
        const entryFileOrFolderName = language_strategy_1.LanguageStrategyFactory.getStrategy(language).getFunctionEntryFileOrFolderName(entryName);
        return fs.pathExists(path.join(componentPath, entryFileOrFolderName));
    }
    static async scaffoldFromZipPackage(componentPath, group, language, scenario, variables, nameReplaceFn) {
        const _nameReplaceFn = (name, data) => {
            name = nameReplaceFn ? nameReplaceFn(name, data) : name;
            return templatesActions_1.removeTemplateExtReplaceFn(name, data);
        };
        await templatesActions_1.scaffoldFromTemplates({
            group: group,
            lang: this.convertTemplateLanguage(language),
            scenario: scenario,
            dst: componentPath,
            fileNameReplaceFn: _nameReplaceFn,
            fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    logger_1.Logger.info(message_1.InfoMessages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : constants_1.CommonConstants.emptyString));
                }
            },
            onActionError: async (action, context, error) => {
                logger_1.Logger.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        telemetry_helper_1.TelemetryHelper.sendScaffoldFallbackEvent(error.message);
                        logger_1.Logger.info(message_1.InfoMessages.getTemplateFromLocal);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new errors_1.TemplateZipFallbackError();
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new errors_1.UnzipError();
                    default:
                        throw new errors_1.UnknownFallbackError();
                }
            },
        });
    }
    static async scaffoldFunction(componentPath, language, trigger, entryName, variables) {
        await steps_1.step(steps_1.StepGroup.ScaffoldStepGroup, steps_1.ScaffoldSteps.ensureFunctionAppProject, async () => await this.ensureFunctionAppProject(componentPath, language, variables));
        await steps_1.step(steps_1.StepGroup.ScaffoldStepGroup, steps_1.ScaffoldSteps.scaffoldFunction, async () => await this.scaffoldFromZipPackage(componentPath, constants_1.FunctionPluginInfo.templateTriggerGroupName, language, trigger, variables, (name) => name.replace(constants_1.RegularExpr.replaceTemplateFileNamePlaceholder, entryName)));
    }
    /*
     * Always call ensure project before scaffold a function entry.
     */
    static async ensureFunctionAppProject(componentPath, language, variables) {
        const exists = await fs.pathExists(componentPath);
        if (exists) {
            logger_1.Logger.info(message_1.InfoMessages.projectScaffoldAt(componentPath));
            return;
        }
        await this.scaffoldFromZipPackage(componentPath, constants_1.FunctionPluginInfo.templateBaseGroupName, language, constants_1.FunctionPluginInfo.templateBaseScenarioName, variables);
    }
}
exports.FunctionScaffold = FunctionScaffold;
//# sourceMappingURL=scaffold.js.map