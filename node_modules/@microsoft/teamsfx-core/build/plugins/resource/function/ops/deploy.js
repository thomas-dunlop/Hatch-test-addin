"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionDeploy = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const constants_1 = require("../constants");
const errors_1 = require("../resources/errors");
const steps_1 = require("../resources/steps");
const message_1 = require("../resources/message");
const enums_1 = require("../enums");
const language_strategy_1 = require("../language-strategy");
const logger_1 = require("../utils/logger");
const execute_1 = require("../utils/execute");
const dir_walk_1 = require("../utils/dir-walk");
const depsChecker_1 = require("../../../../common/deps-checker/depsChecker");
const funcPluginTelemetry_1 = require("../utils/depsChecker/funcPluginTelemetry");
const funcPluginLogger_1 = require("../utils/depsChecker/funcPluginLogger");
const depsManager_1 = require("../../../../common/deps-checker/depsManager");
const telemetry_helper_1 = require("../utils/telemetry-helper");
const templatesUtils_1 = require("../../../../common/template-utils/templatesUtils");
const funcHelper_1 = require("../utils/depsChecker/funcHelper");
class FunctionDeploy {
    static async getLastDeploymentTime(componentPath, envName) {
        const deploymentInfoDir = path.join(componentPath, constants_1.FunctionPluginPathInfo.funcDeploymentFolderName);
        const deploymentInfoPath = path.join(deploymentInfoDir, constants_1.FunctionPluginPathInfo.funcDeploymentInfoFileName);
        try {
            const lastFunctionDeployJson = await fs.readJSON(deploymentInfoPath);
            return new Date(lastFunctionDeployJson[envName].time);
        }
        catch (err) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.DeploymentInfoNotFound);
            throw err;
        }
    }
    static async hasUpdatedContent(componentPath, language, envName) {
        const folderFilter = language_strategy_1.LanguageStrategyFactory.getStrategy(language).hasUpdatedContentFilter;
        try {
            const lastFunctionDeployTime = await this.getLastDeploymentTime(componentPath, envName);
            // Always ignore node_modules folder and bin folder and the file ignored both by git and func.
            const defaultIgnore = ignore_1.default().add(constants_1.FunctionPluginPathInfo.npmPackageFolderName);
            defaultIgnore.add(constants_1.FunctionPluginPathInfo.functionExtensionsFolderName);
            const funcIgnore = await this.prepareIgnore(componentPath, constants_1.FunctionPluginPathInfo.funcIgnoreFileName);
            const gitIgnore = await this.prepareIgnore(componentPath, constants_1.FunctionPluginPathInfo.gitIgnoreFileName);
            let changed = false;
            await dir_walk_1.forEachFileAndDir(componentPath, (itemPath, stats) => {
                // Don't check the modification time of .deployment folder.
                const relativePath = path.relative(componentPath, itemPath);
                if (relativePath &&
                    !defaultIgnore.test(relativePath).ignored &&
                    !(funcIgnore.test(relativePath).ignored && gitIgnore.test(relativePath).ignored) &&
                    lastFunctionDeployTime < stats.mtime) {
                    changed = true;
                    // Return true to stop walking.
                    return true;
                }
            }, folderFilter);
            return changed;
        }
        catch (e) {
            // Failed to check updated, but it doesn't block the deployment.
            return true;
        }
    }
    static async build(componentPath, language) {
        for (const commandItem of language_strategy_1.LanguageStrategyFactory.getStrategy(language).buildCommands) {
            const command = commandItem.command;
            const relativePath = commandItem.relativePath;
            const absolutePath = path.join(componentPath, relativePath);
            await execute_1.execute(command, absolutePath);
        }
    }
    static async installFuncExtensions(componentPath, language) {
        if (language_strategy_1.LanguageStrategyFactory.getStrategy(language).skipFuncExtensionInstall) {
            return;
        }
        const binPath = path.join(componentPath, constants_1.FunctionPluginPathInfo.functionExtensionsFolderName);
        const depsManager = new depsManager_1.DepsManager(funcPluginLogger_1.funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        const dotentStatus = (await depsManager.getStatus([depsChecker_1.DepsType.Dotnet]))[0];
        await funcHelper_1.funcDepsHelper.installFuncExtension(componentPath, dotentStatus.command, funcPluginLogger_1.funcDepsLogger, constants_1.FunctionPluginPathInfo.functionExtensionsFileName, binPath);
    }
    static async deployFunction(client, componentPath, functionAppName, language, resourceGroupName, envName) {
        const deployTime = new Date();
        // To parallel execute the three tasks, we first create all and then await them.
        const publishRelativePath = language_strategy_1.LanguageStrategyFactory.getStrategy(language).deployFolderRelativePath;
        const publishAbsolutePath = path.join(componentPath, publishRelativePath);
        const zip = await errors_1.runWithErrorCatchAndThrow(new errors_1.ZipError(), async () => await steps_1.step(steps_1.StepGroup.DeployStepGroup, steps_1.DeploySteps.generateZip, async () => await this.generateFunctionZip(publishAbsolutePath)));
        const publishCred = await errors_1.runWithErrorCatchAndThrow(new errors_1.PublishCredentialError(), async () => await steps_1.step(steps_1.StepGroup.DeployStepGroup, steps_1.DeploySteps.fetchCredential, async () => await client.webApps.listPublishingCredentials(resourceGroupName, functionAppName)));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await steps_1.step(steps_1.StepGroup.DeployStepGroup, steps_1.DeploySteps.checkFuncAppSettings, async () => this.checkRunFromPackageSetting(client, resourceGroupName, functionAppName)));
        const zipContent = zip.toBuffer();
        const username = publishCred.publishingUserName;
        const password = publishCred.publishingPassword;
        logger_1.Logger.debug(message_1.InfoMessages.uploadZipSize(zipContent.length));
        if (!password) {
            logger_1.Logger.error(message_1.ErrorMessages.failToQueryPublishCred);
            throw new errors_1.PublishCredentialError();
        }
        await errors_1.runWithErrorCatchAndThrow(new errors_1.UploadZipError(), async () => await steps_1.step(steps_1.StepGroup.DeployStepGroup, steps_1.DeploySteps.deploy, async () => await templatesUtils_1.sendRequestWithRetry(async () => await axios_1.default.post(constants_1.AzureInfo.zipDeployURL(functionAppName), zipContent, {
            headers: {
                "Content-Type": "application/octet-stream",
                "Cache-Control": "no-cache",
            },
            auth: {
                username: username,
                password: password,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            timeout: constants_1.DefaultValues.deployTimeoutInMs,
        }), constants_1.DefaultValues.maxTryCount)));
        await errors_1.runWithErrorCatchAndThrow(new errors_1.FunctionAppOpError("restart"), async () => await steps_1.step(steps_1.StepGroup.DeployStepGroup, steps_1.DeploySteps.restart, async () => await client.webApps.restart(resourceGroupName, functionAppName)));
        await this.saveDeploymentInfo(componentPath, zipContent, deployTime, envName);
    }
    static async saveDeploymentInfo(componentPath, zipContent, deployTime, envName) {
        var _a;
        const deploymentInfoDir = path.join(componentPath, constants_1.FunctionPluginPathInfo.funcDeploymentFolderName);
        const deploymentInfoPath = path.join(deploymentInfoDir, constants_1.FunctionPluginPathInfo.funcDeploymentInfoFileName);
        const deploymentZipCache = path.join(deploymentInfoDir, constants_1.FunctionPluginPathInfo.funcDeploymentZipCacheFileName);
        await fs.ensureDir(deploymentInfoDir);
        let lastFunctionDeployJson = {};
        try {
            lastFunctionDeployJson = await fs.readJSON(deploymentInfoPath);
        }
        catch (_b) {
            // It's fine if failed to read json from the deployment file.
        }
        (_a = lastFunctionDeployJson[envName]) !== null && _a !== void 0 ? _a : (lastFunctionDeployJson[envName] = {});
        lastFunctionDeployJson[envName].time = deployTime;
        try {
            await fs.writeJSON(deploymentInfoPath, lastFunctionDeployJson);
            await fs.writeFile(deploymentZipCache, zipContent);
        }
        catch (_c) {
            // Deploy still succeeded even we failed to record it.
        }
    }
    static async loadLastDeploymentZipCache(componentPath) {
        const deploymentInfoDir = path.join(componentPath, constants_1.FunctionPluginPathInfo.funcDeploymentFolderName);
        const deploymentZipCache = path.join(deploymentInfoDir, constants_1.FunctionPluginPathInfo.funcDeploymentZipCacheFileName);
        try {
            const content = await fs.readFile(deploymentZipCache);
            const zip = new adm_zip_1.default(content);
            logger_1.Logger.info(message_1.InfoMessages.reuseZipNotice);
            return zip;
        }
        catch (_a) {
            // Failed to load cache, it doesn't block deployment.
        }
        return undefined;
    }
    static removeLegacyFileInZip(zip, existenceFiles) {
        zip
            .getEntries()
            .filter((entry) => !existenceFiles.has(entry.name))
            .forEach((entry) => {
            zip.deleteFile(entry.name);
        });
    }
    static async generateFunctionZip(componentPath) {
        // The granularity of time store in zip is 2-seconds.
        // To compare it with mtime in fs.Stats, we need to normalize them into same granularity.
        const normalizeTime = (t) => Math.floor(t / constants_1.CommonConstants.zipTimeMSGranularity);
        const zip = (await this.loadLastDeploymentZipCache(componentPath)) || new adm_zip_1.default();
        const ig = await this.prepareIgnore(componentPath, constants_1.FunctionPluginPathInfo.funcIgnoreFileName);
        const tasks = [];
        const zipFiles = new Set();
        const addFileIntoZip = async (zip, filePath, zipPath, stats) => {
            const content = await fs.readFile(filePath);
            zip.addFile(zipPath, content);
            if (stats) {
                zip.getEntry(zipPath).header.time = stats.mtime;
            }
        };
        await dir_walk_1.forEachFileAndDir(componentPath, (itemPath, stats) => {
            const relativePath = path.relative(componentPath, itemPath);
            if (relativePath && !stats.isDirectory() && ig.filter([relativePath]).length > 0) {
                zipFiles.add(relativePath);
                const entry = zip.getEntry(relativePath);
                if (entry) {
                    // The header is an object, the ts declare of adm-zip is wrong.
                    const header = entry.header;
                    const mtime = header && header.time;
                    // Some files' mtime in node_modules are too old, which may be invalid,
                    // so we arbitrarily add a limitation to update this kind of files.
                    // If mtime is valid and the two mtime is same in two-seconds, we think the two are same file.
                    if (mtime >= constants_1.CommonConstants.latestTrustMtime &&
                        normalizeTime(mtime.getTime()) === normalizeTime(stats.mtime.getTime())) {
                        return;
                    }
                    // Delete the entry because the file has been updated.
                    zip.deleteFile(relativePath);
                }
                // If fail to reuse cached entry, load it from disk.
                const fullPath = path.join(componentPath, relativePath);
                const task = addFileIntoZip(zip, fullPath, relativePath, stats);
                tasks.push(task);
            }
        });
        await Promise.all(tasks);
        this.removeLegacyFileInZip(zip, zipFiles);
        return zip;
    }
    // If we can find an ignore file, parse it and use it for zip generation.
    static async prepareIgnore(componentPath, fileName) {
        const ignoreFilePath = path.join(componentPath, fileName);
        const ig = ignore_1.default().add(constants_1.FunctionPluginPathInfo.funcDeploymentFolderName);
        if (await fs.pathExists(ignoreFilePath)) {
            const ignoreFileContent = await fs.readFile(ignoreFilePath);
            ignoreFileContent
                .toString()
                .split("\n")
                .forEach((line) => ig.add(line.trim()));
        }
        return ig;
    }
    static async checkRunFromPackageSetting(client, resourceGroupName, azureFuncName) {
        const appSettings = await client.webApps.listApplicationSettings(resourceGroupName, azureFuncName);
        if (!appSettings.properties) {
            appSettings.properties = {};
        }
        if (appSettings.properties[constants_1.AzureInfo.runFromPackageSettingKey] !== constants_1.AzureInfo.runFromPackageEnabled) {
            appSettings.properties[constants_1.AzureInfo.runFromPackageSettingKey] = constants_1.AzureInfo.runFromPackageEnabled;
            await client.webApps.updateApplicationSettings(resourceGroupName, azureFuncName, appSettings);
        }
    }
}
exports.FunctionDeploy = FunctionDeploy;
//# sourceMappingURL=deploy.js.map