"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureLib = exports.AzureClientFactory = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_resources_1 = require("@azure/arm-resources");
const arm_storage_1 = require("@azure/arm-storage");
const arm_appservice_1 = require("@azure/arm-appservice");
const message_1 = require("../resources/message");
const logger_1 = require("./logger");
class AzureClientFactory {
    /* TODO: we wrap the constructor to function and further discuss whether we should make it singleton.
     * We would better not make these client singleton, because they records credential.
     * It has security issue to put sensitive data in static memory address for long time.
     */
    static getStorageManagementClient(credentials, subscriptionId) {
        return new arm_storage_1.StorageManagementClient(credentials, subscriptionId);
    }
    static getWebSiteManagementClient(credentials, subscriptionId) {
        return new arm_appservice_1.WebSiteManagementClient(credentials, subscriptionId);
    }
    static getResourceManagementClient(credentials, subscriptionId) {
        return new arm_resources_1.ResourceManagementClient(credentials, subscriptionId);
    }
    static getResourceProviderClient(credentials, subscriptionId) {
        return new arm_resources_1.Providers(new arm_resources_1.ResourceManagementClientContext(credentials, subscriptionId));
    }
}
exports.AzureClientFactory = AzureClientFactory;
class AzureLib {
    static async doesResourceGroupExist(client, resourceGroupName) {
        const res = await client.resourceGroups.checkExistence(resourceGroupName);
        return res.body;
    }
    static async ensureResource(createFn, findFn) {
        const _t = await (findFn === null || findFn === void 0 ? void 0 : findFn());
        if (!_t) {
            return createFn();
        }
        logger_1.Logger.info(message_1.InfoMessages.resourceExists);
        return _t;
    }
    static async findResourceProvider(client, namespace) {
        const provider = await client.get(namespace);
        if (provider.registrationState === "Registered") {
            return provider;
        }
    }
    static async ensureResourceProviders(client, providerNamespaces) {
        return Promise.all(providerNamespaces.map((namespace) => this.ensureResource(() => client.register(namespace), () => this.findResourceProvider(client, namespace))));
    }
    static async findAppServicePlans(client, resourceGroupName, appServicePlanName) {
        const appServicePlansRes = await client.appServicePlans.listByResourceGroup(resourceGroupName);
        return appServicePlansRes.find((plan) => plan.name === appServicePlanName);
    }
    static async ensureAppServicePlans(client, resourceGroupName, appServicePlanName, options) {
        return this.ensureResource(() => client.appServicePlans.createOrUpdate(resourceGroupName, appServicePlanName, options), () => this.findAppServicePlans(client, resourceGroupName, appServicePlanName));
    }
    static async findStorageAccount(client, resourceGroupName, storageName) {
        const storageAccountListResult = await client.storageAccounts.listByResourceGroup(resourceGroupName);
        return storageAccountListResult.find((storageAccount) => storageAccount.name === storageName);
    }
    static async ensureStorageAccount(client, resourceGroupName, storageName, params) {
        return this.ensureResource(() => client.storageAccounts.create(resourceGroupName, storageName, params));
    }
    static async getConnectionString(client, resourceGroupName, storageAccountName) {
        var _a;
        const keyList = await client.storageAccounts.listKeys(resourceGroupName, storageAccountName);
        if (!keyList.keys || !((_a = keyList.keys[0]) === null || _a === void 0 ? void 0 : _a.value)) {
            return undefined;
        }
        const key = keyList.keys[0].value;
        return `DefaultEndpointsProtocol=https;AccountName=${storageAccountName};AccountKey=${key};EndpointSuffix=core.windows.net`;
    }
    static async findFunctionApp(client, resourceGroupName, functionAppName) {
        const webAppCollection = await client.webApps.listByResourceGroup(resourceGroupName);
        return webAppCollection.find((webApp) => webApp.name === functionAppName);
    }
    static async ensureFunctionApp(client, resourceGroupName, functionAppName, siteEnvelope) {
        return this.ensureResource(() => client.webApps.createOrUpdate(resourceGroupName, functionAppName, siteEnvelope), () => this.findFunctionApp(client, resourceGroupName, functionAppName));
    }
}
exports.AzureLib = AzureLib;
//# sourceMappingURL=azure-client.js.map