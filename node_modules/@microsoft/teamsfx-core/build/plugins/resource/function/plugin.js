"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const path = tslib_1.__importStar(require("path"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const azure_client_1 = require("./utils/azure-client");
const errors_1 = require("./resources/errors");
const constants_1 = require("./constants");
const message_1 = require("./resources/message");
const enums_1 = require("./enums");
const deploy_1 = require("./ops/deploy");
const provision_1 = require("./ops/provision");
const scaffold_1 = require("./ops/scaffold");
const result_1 = require("./result");
const logger_1 = require("./utils/logger");
const steps_1 = require("./resources/steps");
const funcHelper_1 = require("./utils/depsChecker/funcHelper");
const depsError_1 = require("../../../common/deps-checker/depsError");
const checkerFactory_1 = require("../../../common/deps-checker/checkerFactory");
const depsChecker_1 = require("../../../common/deps-checker/depsChecker");
const funcPluginTelemetry_1 = require("./utils/depsChecker/funcPluginTelemetry");
const funcPluginLogger_1 = require("./utils/depsChecker/funcPluginLogger");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const folder_1 = require("../../../folder");
const constants_2 = require("../../../common/constants");
const common_1 = require("../../../common");
const question_1 = require("./question");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../solution/fx-solution/v2/adaptor");
const tools_1 = require("../../../common/tools");
class FunctionPluginImpl {
    constructor() {
        this.config = {
            skipDeploy: false,
        };
    }
    async syncConfigFromContext(ctx) {
        var _a, _b;
        this.config.functionLanguage = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.programmingLanguage;
        this.config.defaultFunctionName = (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.defaultFunctionName;
        this.config.functionEndpoint = ctx.config.get(enums_1.FunctionConfigKey.functionEndpoint);
        this.config.functionAppResourceId = ctx.config.get(enums_1.FunctionConfigKey.functionAppResourceId);
        /* Always validate after sync for safety and security. */
        this.validateConfig();
    }
    syncConfigToContext(ctx) {
        // sync plugin config to context
        Object.entries(this.config)
            .filter((kv) => constants_1.FunctionPluginInfo.FunctionPluginPersistentConfig.find((x) => x === kv[0]))
            .forEach((kv) => {
            if (kv[1]) {
                ctx.config.set(kv[0], kv[1].toString());
            }
        });
        // sync project settings to context
        if (this.config.defaultFunctionName) {
            ctx.projectSettings.defaultFunctionName = this.config.defaultFunctionName;
        }
    }
    validateConfig() {
        if (this.config.functionLanguage &&
            !Object.values(enums_1.FunctionLanguage).includes(this.config.functionLanguage)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.functionLanguage);
        }
        if (this.config.resourceNameSuffix &&
            !constants_1.RegularExpr.validResourceSuffixPattern.test(this.config.resourceNameSuffix)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.resourceNameSuffix);
        }
        if (this.config.functionAppName &&
            !constants_1.RegularExpr.validFunctionAppNamePattern.test(this.config.functionAppName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.functionAppName);
        }
        if (this.config.storageAccountName &&
            !constants_1.RegularExpr.validStorageAccountNamePattern.test(this.config.storageAccountName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.storageAccountName);
        }
        if (this.config.appServicePlanName &&
            !constants_1.RegularExpr.validAppServicePlanNamePattern.test(this.config.appServicePlanName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.appServicePlanName);
        }
        if (this.config.defaultFunctionName &&
            !constants_1.RegularExpr.validFunctionNamePattern.test(this.config.defaultFunctionName)) {
            throw new errors_1.ValidationError(enums_1.FunctionConfigKey.defaultFunctionName);
        }
    }
    async callFunc(func, ctx) {
        var _a, _b;
        if (func.method === constants_1.QuestionValidationFunc.validateFunctionName) {
            const workingPath = this.getFunctionProjectRootPath(ctx);
            const name = func.params;
            if (!name || !constants_1.RegularExpr.validFunctionNamePattern.test(name)) {
                return result_1.FunctionPluginResultFactory.Success(message_1.ErrorMessages.invalidFunctionName);
            }
            const stage = ctx.answers[enums_1.QuestionKey.stage];
            if (stage === teamsfx_api_1.Stage.create) {
                return result_1.FunctionPluginResultFactory.Success();
            }
            const language = (_a = ctx.answers[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.programmingLanguage;
            // If language is unknown, skip checking and let scaffold handle the error.
            if (language && (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
                return result_1.FunctionPluginResultFactory.Success(message_1.ErrorMessages.functionAlreadyExists);
            }
        }
        return result_1.FunctionPluginResultFactory.Success();
    }
    getQuestionsForUserTask(func, ctx) {
        const res = new teamsfx_api_1.QTreeNode({
            type: "group",
        });
        if (func.method === enums_1.CustomizedTask.addResource || func.method === enums_1.CustomizedTask.addFeature) {
            question_1.functionNameQuestion.validation = {
                validFunc: async (input, previousInputs) => {
                    var _a, _b;
                    const workingPath = this.getFunctionProjectRootPath(ctx);
                    const name = input;
                    if (!name || !constants_1.RegularExpr.validFunctionNamePattern.test(name)) {
                        return message_1.ErrorMessages.invalidFunctionName;
                    }
                    const stage = ctx.answers[enums_1.QuestionKey.stage];
                    if (stage === teamsfx_api_1.Stage.create) {
                        return undefined;
                    }
                    const language = (_a = ctx.answers[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.programmingLanguage;
                    // If language is unknown, skip checking and let scaffold handle the error.
                    if (language &&
                        (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
                        return message_1.ErrorMessages.functionAlreadyExists;
                    }
                },
            };
            res.addChild(new teamsfx_api_1.QTreeNode(question_1.functionNameQuestion));
        }
        return result_1.FunctionPluginResultFactory.Success(res);
    }
    async executeUserTask(func, ctx) {
        let result = result_1.FunctionPluginResultFactory.Success();
        if (func.method === enums_1.CustomizedTask.addResource) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.addResource);
            result = result.isErr() ? result : await this.preScaffold(ctx);
            result = result.isErr() ? result : await this.scaffold(ctx);
        }
        return result;
    }
    async preScaffold(ctx) {
        var _a;
        await this.syncConfigFromContext(ctx);
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const name = (_a = ctx.answers[enums_1.QuestionKey.functionName]) !== null && _a !== void 0 ? _a : constants_1.DefaultValues.functionName;
        if (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, functionLanguage, name)) {
            throw new errors_1.FunctionNameConflictError();
        }
        this.config.functionName = name;
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async scaffold(ctx) {
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionName = this.checkAndGet(this.config.functionName, enums_1.FunctionConfigKey.functionName);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        await scaffold_1.FunctionScaffold.scaffoldFunction(workingPath, functionLanguage, constants_1.DefaultValues.functionTriggerType, functionName, {
            appName: ctx.projectSettings.appName,
            functionName: functionName,
        });
        if (!this.config.defaultFunctionName) {
            this.config.defaultFunctionName = this.config.functionName;
        }
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async postProvision(ctx) {
        var _a;
        if (!this.needConfigure(ctx)) {
            return result_1.FunctionPluginResultFactory.Success();
        }
        await this.syncConfigFromContext(ctx);
        const functionAppName = this.getFunctionAppName();
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enums_1.FunctionConfigKey.credential);
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        const site = await this.getSite(ctx, webSiteManagementClient, resourceGroupName, functionAppName);
        // We must query app settings from azure here, for two reasons:
        // 1. The site object returned by SDK may not contain app settings.
        // 2. Azure automatically added some app settings during creation.
        const res = await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await webSiteManagementClient.webApps.listApplicationSettings(resourceGroupName, functionAppName));
        if (res.properties) {
            Object.entries(res.properties).forEach((kv) => {
                // The site have some settings added in provision step,
                // which should not be overwritten by queried settings.
                provision_1.FunctionProvision.pushAppSettings(site, kv[0], kv[1], false);
            });
        }
        this.collectFunctionAppSettings(ctx, site);
        await errors_1.runWithErrorCatchAndThrow(new errors_1.ConfigFunctionAppError(), async () => await steps_1.step(steps_1.StepGroup.PostProvisionStepGroup, steps_1.PostProvisionSteps.updateFunctionSettings, async () => await webSiteManagementClient.webApps.update(resourceGroupName, functionAppName, site)));
        logger_1.Logger.info(message_1.InfoMessages.functionAppSettingsUpdated);
        this.syncConfigToContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async preDeploy(ctx) {
        await this.syncConfigFromContext(ctx);
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const updated = await deploy_1.FunctionDeploy.hasUpdatedContent(workingPath, functionLanguage, ctx.envInfo.envName);
        if (!updated) {
            logger_1.Logger.info(message_1.InfoMessages.noChange);
            this.config.skipDeploy = true;
            return result_1.FunctionPluginResultFactory.Success();
        }
        // NOTE: make sure this step is before using `dotnet` command if you refactor this code.
        await this.handleDotnetChecker(ctx);
        await this.handleBackendExtensionsInstall(ctx, workingPath, functionLanguage);
        await errors_1.runWithErrorCatchAndThrow(new errors_1.InstallNpmPackageError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.npmPrepare, async () => deploy_1.FunctionDeploy.build(workingPath, functionLanguage)));
        this.config.skipDeploy = false;
        return result_1.FunctionPluginResultFactory.Success();
    }
    async updateArmTemplates(ctx) {
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.configuraitonTemplateFileName);
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Reference: {
                functionAppResourceId: constants_1.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_1.FunctionBicep.functionEndpoint,
            },
            Configuration: {
                Modules: { function: configModule },
            },
        };
        return result_1.FunctionPluginResultFactory.Success(result);
    }
    async generateArmTemplates(ctx) {
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const provisionTemplateFilePath = path.join(bicepTemplateDirectory, constants_2.Bicep.ProvisionFileName);
        const provisionFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.provisionModuleTemplateFileName);
        const configTemplateFilePath = path.join(bicepTemplateDirectory, constants_2.Bicep.ConfigFileName);
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.FunctionBicepFile.configuraitonTemplateFileName);
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionTemplateFilePath, pluginCtx);
        const provisionModule = await tools_1.generateBicepFromFile(provisionFuncTemplateFilePath, pluginCtx);
        const configOrchestration = await tools_1.generateBicepFromFile(configTemplateFilePath, pluginCtx);
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { function: provisionModule },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { function: configModule },
            },
            Reference: {
                functionAppResourceId: constants_1.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_1.FunctionBicep.functionEndpoint,
            },
        };
        return result_1.FunctionPluginResultFactory.Success(result);
    }
    async deploy(ctx) {
        var _a;
        if (this.config.skipDeploy) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.skipDeploy);
            logger_1.Logger.warning(message_1.InfoMessages.skipDeployment);
            return result_1.FunctionPluginResultFactory.Success();
        }
        const workingPath = this.getFunctionProjectRootPath(ctx);
        const functionAppName = this.getFunctionAppName();
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const credential = this.checkAndGet(await ((_a = ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync()), enums_1.FunctionConfigKey.credential);
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new errors_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        logger_1.Logger.debug(`deploy function with subscription id: ${subscriptionId}, resourceGroup name: ${resourceGroupName}, function web app name: ${functionAppName}`);
        await deploy_1.FunctionDeploy.deployFunction(webSiteManagementClient, workingPath, functionAppName, functionLanguage, resourceGroupName, ctx.envInfo.envName);
        return result_1.FunctionPluginResultFactory.Success();
    }
    getFunctionProjectRootPath(ctx) {
        return path.join(ctx.root, constants_1.FunctionPluginPathInfo.solutionFolderName);
    }
    checkAndGet(v, key) {
        if (v) {
            return v;
        }
        throw new errors_1.FetchConfigError(key);
    }
    isPluginEnabled(ctx, plugin) {
        var _a;
        const selectedPlugins = ((_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings)
            .activeResourcePlugins;
        return selectedPlugins.includes(plugin);
    }
    getFunctionAppName() {
        return common_1.getSiteNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    getFunctionAppResourceGroupName() {
        return common_1.getResourceGroupNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    getFunctionAppSubscriptionId() {
        return common_1.getSubscriptionIdFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    needConfigure(ctx) {
        const apimConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.apimPluginName);
        return this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.apimPluginName) && !!apimConfig;
    }
    async getSite(ctx, client, resourceGroupName, functionAppName) {
        const site = await azure_client_1.AzureLib.findFunctionApp(client, resourceGroupName, functionAppName);
        if (!site) {
            throw new errors_1.FindAppError();
        }
        else {
            return site;
        }
    }
    collectFunctionAppSettings(ctx, site) {
        const apimConfig = ctx.envInfo.state.get(constants_1.DependentPluginInfo.apimPluginName);
        if (this.isPluginEnabled(ctx, constants_1.DependentPluginInfo.apimPluginName) && apimConfig) {
            logger_1.Logger.info(message_1.InfoMessages.dependPluginDetected(constants_1.DependentPluginInfo.apimPluginName));
            const clientId = this.checkAndGet(apimConfig.get(constants_1.DependentPluginInfo.apimAppId), "APIM app Id");
            provision_1.FunctionProvision.ensureFunctionAllowAppIds(site, [clientId]);
        }
    }
    async handleDotnetChecker(ctx) {
        const dotnetChecker = checkerFactory_1.CheckerFactory.createChecker(depsChecker_1.DepsType.Dotnet, funcPluginLogger_1.funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.dotnetInstall, async () => {
            try {
                if (!(await funcHelper_1.funcDepsHelper.dotnetCheckerEnabled(ctx.answers))) {
                    return;
                }
                await dotnetChecker.resolve();
            }
            catch (error) {
                if (error instanceof depsError_1.LinuxNotSupportedError) {
                    return;
                }
                funcPluginLogger_1.funcDepsLogger.error(message_1.InfoMessages.failedToInstallDotnet(error));
                await funcPluginLogger_1.funcDepsLogger.printDetailLog();
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            finally {
                funcPluginLogger_1.funcDepsLogger.cleanup();
            }
        });
    }
    async handleBackendExtensionsInstall(ctx, workingPath, functionLanguage) {
        await errors_1.runWithErrorCatchAndThrow(new errors_1.InstallTeamsFxBindingError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.installTeamsfxBinding, async () => {
            try {
                await deploy_1.FunctionDeploy.installFuncExtensions(workingPath, functionLanguage);
            }
            catch (error) {
                // wrap the original error to UserError so the extensibility model will pop-up a dialog correctly
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
        }));
    }
}
exports.FunctionPluginImpl = FunctionPluginImpl;
//# sourceMappingURL=plugin.js.map