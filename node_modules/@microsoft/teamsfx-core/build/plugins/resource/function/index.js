"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionPlugin = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const question_1 = require("../../solution/fx-solution/question");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
const enums_1 = require("./enums");
const plugin_1 = require("./plugin");
const errors_1 = require("./resources/errors");
const steps_1 = require("./resources/steps");
const result_1 = require("./result");
const logger_1 = require("./utils/logger");
const telemetry_helper_1 = require("./utils/telemetry-helper");
require("./v2");
let FunctionPlugin = class FunctionPlugin {
    constructor() {
        this.name = "fx-resource-function";
        this.displayName = "Azure Function";
        this.functionPluginImpl = new plugin_1.FunctionPluginImpl();
    }
    activate(solutionSettings) {
        const azureResources = solutionSettings.azureResources || [];
        return (solutionSettings.hostType === question_1.HostTypeOptionAzure.id &&
            azureResources.includes(question_1.AzureResourceFunction.id));
    }
    async callFunc(func, ctx) {
        return await this.functionPluginImpl.callFunc(func, ctx);
    }
    setContext(ctx) {
        logger_1.Logger.setLogger(ctx.logProvider);
        telemetry_helper_1.TelemetryHelper.setContext(ctx);
    }
    async getQuestionsForUserTask(func, ctx) {
        this.setContext(ctx);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.getQuestions, () => Promise.resolve(this.functionPluginImpl.getQuestionsForUserTask(func, ctx)), false);
        return res;
    }
    async executeUserTask(func, ctx) {
        this.setContext(ctx);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.executeUserTask, () => this.functionPluginImpl.executeUserTask(func, ctx));
        return res;
    }
    async preScaffold(ctx) {
        this.setContext(ctx);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.preScaffold, () => this.functionPluginImpl.preScaffold(ctx));
        return res;
    }
    async scaffold(ctx) {
        this.setContext(ctx);
        await steps_1.StepHelperFactory.scaffoldStepHelper.start(Object.entries(steps_1.ScaffoldSteps).length, ctx.ui);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.scaffold, () => this.functionPluginImpl.scaffold(ctx));
        await steps_1.StepHelperFactory.scaffoldStepHelper.end(res.isOk());
        return res;
    }
    async preProvision(ctx) {
        this.setContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async provision(ctx) {
        this.setContext(ctx);
        return result_1.FunctionPluginResultFactory.Success();
    }
    async postProvision(ctx) {
        this.setContext(ctx);
        await steps_1.StepHelperFactory.postProvisionStepHelper.start(Object.entries(steps_1.PostProvisionSteps).length, ctx.ui);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.postProvision, () => this.functionPluginImpl.postProvision(ctx));
        await steps_1.StepHelperFactory.postProvisionStepHelper.end(res.isOk());
        return res;
    }
    async updateArmTemplates(ctx) {
        this.setContext(ctx);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.updateArmTemplates, () => this.functionPluginImpl.updateArmTemplates(ctx));
        return res;
    }
    async generateArmTemplates(ctx) {
        this.setContext(ctx);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.generateArmTemplates, () => this.functionPluginImpl.generateArmTemplates(ctx));
        return res;
    }
    async preDeploy(ctx) {
        this.setContext(ctx);
        await steps_1.StepHelperFactory.preDeployStepHelper.start(Object.entries(steps_1.PreDeploySteps).length, ctx.ui);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.preDeploy, () => this.functionPluginImpl.preDeploy(ctx));
        await steps_1.StepHelperFactory.preDeployStepHelper.end(res.isOk());
        return res;
    }
    async deploy(ctx) {
        this.setContext(ctx);
        await steps_1.StepHelperFactory.deployStepHelper.start(Object.entries(steps_1.DeploySteps).length, ctx.ui);
        const res = await this.runWithErrorWrapper(ctx, enums_1.FunctionEvent.deploy, () => this.functionPluginImpl.deploy(ctx));
        await steps_1.StepHelperFactory.deployStepHelper.end(res.isOk());
        return res;
    }
    async runWithErrorWrapper(ctx, event, fn, sendTelemetry = true) {
        try {
            sendTelemetry && telemetry_helper_1.TelemetryHelper.sendStartEvent(event);
            const res = await fn();
            sendTelemetry && telemetry_helper_1.TelemetryHelper.sendResultEvent(event, res);
            return res;
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                const res = teamsfx_api_1.err(e);
                sendTelemetry && telemetry_helper_1.TelemetryHelper.sendResultEvent(event, res);
                return res;
            }
            if (e instanceof errors_1.FunctionPluginError) {
                const res = e.errorType === errors_1.ErrorType.User
                    ? result_1.FunctionPluginResultFactory.UserError([e.getDefaultMessage(), e.getMessage()], e.code, undefined, e, e.stack)
                    : result_1.FunctionPluginResultFactory.SystemError([e.getDefaultMessage(), e.getMessage()], e.code, undefined, e, e.stack);
                sendTelemetry && telemetry_helper_1.TelemetryHelper.sendResultEvent(event, res);
                return res;
            }
            const UnhandledErrorCode = "UnhandledError";
            /* Never send unhandled error message for privacy concern. */
            sendTelemetry &&
                telemetry_helper_1.TelemetryHelper.sendResultEvent(event, result_1.FunctionPluginResultFactory.SystemError(["Got an unhandled error", "Got an unhandled error"], UnhandledErrorCode));
            return result_1.FunctionPluginResultFactory.SystemError([e.message, e.message], UnhandledErrorCode, undefined, e, e.stack);
        }
    }
};
FunctionPlugin = tslib_1.__decorate([
    typedi_1.Service(ResourcePluginContainer_1.ResourcePlugins.FunctionPlugin)
], FunctionPlugin);
exports.FunctionPlugin = FunctionPlugin;
exports.default = new FunctionPlugin();
//# sourceMappingURL=index.js.map