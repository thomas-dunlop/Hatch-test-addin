"use strict";
var TeamsBot_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsBot = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const plugin_1 = require("./plugin");
const progressBars_1 = require("./progressBars");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const solution_1 = require("../../solution");
const typedi_1 = require("typedi");
const ResourcePluginContainer_1 = require("../../solution/fx-solution/ResourcePluginContainer");
require("./v2");
const plugin_2 = require("./dotnet/plugin");
const common_1 = require("../../../common");
const plugin_3 = require("./functionsHostedBot/plugin");
const scaffoldConfig_1 = require("./configs/scaffoldConfig");
const question_1 = require("./question");
const enum_1 = require("./v2/enum");
const mapping_1 = require("./v2/mapping");
let TeamsBot = TeamsBot_1 = class TeamsBot {
    constructor() {
        this.name = "fx-resource-bot";
        this.displayName = "Bot";
        this.teamsBotImpl = new plugin_1.TeamsBotImpl();
        this.dotnetBotImpl = new plugin_2.DotnetBotImpl();
        this.functionsBotImpl = new plugin_3.FunctionsHostedBotImpl();
    }
    activate(solutionSettings) {
        const cap = solutionSettings.capabilities || [];
        return cap.includes(solution_1.BotOptionItem.id) || cap.includes(solution_1.MessageExtensionItem.id);
    }
    /**
     * @param isScaffold true for `scaffold` lifecycle, false otherwise.
     * @param context context of plugin
     */
    getImpl(context, isScaffold = false) {
        if (common_1.isVSProject(context.projectSettings)) {
            return this.dotnetBotImpl;
        }
        else if (TeamsBot_1.isFunctionsHostedBot(context, isScaffold)) {
            return this.functionsBotImpl;
        }
        else {
            return this.teamsBotImpl;
        }
    }
    async scaffold(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await errors_1.runWithExceptionCatching(context, () => this.getImpl(context, true).scaffold(context), true, constants_1.LifecycleFuncNames.SCAFFOLD);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.SCAFFOLD_TITLE);
        return result;
    }
    async preProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).preProvision(context), true, constants_1.LifecycleFuncNames.PRE_PROVISION);
    }
    async provision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).provision(context), true, constants_1.LifecycleFuncNames.PROVISION);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.PROVISION_TITLE);
        return result;
    }
    async postProvision(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).postProvision(context), true, constants_1.LifecycleFuncNames.POST_PROVISION);
    }
    async updateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).updateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
    }
    async generateArmTemplates(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).generateArmTemplates(context), true, constants_1.LifecycleFuncNames.GENERATE_ARM_TEMPLATES);
    }
    async preDeploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).preDeploy(context), true, constants_1.LifecycleFuncNames.PRE_DEPLOY);
    }
    async deploy(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).deploy(context), true, constants_1.LifecycleFuncNames.DEPLOY);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.DEPLOY_TITLE);
        return result;
    }
    async localDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        const result = await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).localDebug(context), true, constants_1.LifecycleFuncNames.LOCAL_DEBUG);
        await progressBars_1.ProgressBarFactory.closeProgressBar(result.isOk(), constants_1.ProgressBarConstants.LOCAL_DEBUG_TITLE);
        return result;
    }
    async postLocalDebug(context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, () => this.getImpl(context).postLocalDebug(context), true, constants_1.LifecycleFuncNames.POST_LOCAL_DEBUG);
    }
    async getQuestions(stage, context) {
        logger_1.Logger.setLogger(context.logProvider);
        if (stage === teamsfx_api_1.Stage.create) {
            return await errors_1.runWithExceptionCatching(context, async () => {
                var _a;
                const res = new teamsfx_api_1.QTreeNode({
                    type: "group",
                });
                if (common_1.isCLIDotNetEnabled()) {
                    Object.values(enum_1.Runtime).forEach((runtime) => {
                        var _a;
                        const node = new teamsfx_api_1.QTreeNode(question_1.createHostTypeTriggerQuestion((_a = context.answers) === null || _a === void 0 ? void 0 : _a.platform, runtime));
                        node.condition = question_1.getConditionOfNotificationTriggerQuestion(runtime);
                        res.addChild(node);
                    });
                }
                else {
                    const runtime = mapping_1.getPlatformRuntime(context.answers.platform);
                    const node = new teamsfx_api_1.QTreeNode(question_1.createHostTypeTriggerQuestion((_a = context.answers) === null || _a === void 0 ? void 0 : _a.platform, runtime));
                    res.addChild(node);
                }
                res.condition = question_1.showNotificationTriggerCondition;
                return teamsfx_api_1.ok(res);
            }, true, constants_1.LifecycleFuncNames.GET_QUETSIONS_FOR_SCAFFOLDING);
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
    async getQuestionsForUserTask(func, context) {
        logger_1.Logger.setLogger(context.logProvider);
        return await errors_1.runWithExceptionCatching(context, async () => {
            var _a;
            if ((func.method === constants_1.CustomizedTasks.addCapability ||
                func.method === constants_1.CustomizedTasks.addFeature) &&
                common_1.isBotNotificationEnabled()) {
                const res = new teamsfx_api_1.QTreeNode({
                    type: "group",
                });
                res.addChild(new teamsfx_api_1.QTreeNode(question_1.createHostTypeTriggerQuestion((_a = context.answers) === null || _a === void 0 ? void 0 : _a.platform)));
                res.condition = question_1.showNotificationTriggerCondition;
                return teamsfx_api_1.ok(res);
            }
            else {
                return teamsfx_api_1.ok(undefined);
            }
        }, true, constants_1.LifecycleFuncNames.GET_QUETSIONS_FOR_USER_TASK);
    }
    static isFunctionsHostedBot(context, isScaffold) {
        return scaffoldConfig_1.ScaffoldConfig.getBotHostType(context, isScaffold) === common_1.BotHostTypes.AzureFunctions;
    }
};
TeamsBot = TeamsBot_1 = tslib_1.__decorate([
    typedi_1.Service(ResourcePluginContainer_1.ResourcePlugins.BotPlugin)
], TeamsBot);
exports.TeamsBot = TeamsBot;
exports.default = new TeamsBot();
//# sourceMappingURL=index.js.map