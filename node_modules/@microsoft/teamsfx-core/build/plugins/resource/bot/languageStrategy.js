"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageStrategy = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const utils = tslib_1.__importStar(require("./utils/common"));
const programmingLanguage_1 = require("./enums/programmingLanguage");
const constants_1 = require("./constants");
const strings_1 = require("./resources/strings");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const messages_1 = require("./resources/messages");
const templatesActions_1 = require("../../../common/template-utils/templatesActions");
const pluginActRoles_1 = require("./enums/pluginActRoles");
const path = tslib_1.__importStar(require("path"));
const enum_1 = require("./v2/enum");
class LanguageStrategy {
    static async scaffoldProject(group_name, config, actions = templatesActions_1.defaultActionSeq) {
        await this.getTemplateProject(group_name, this.resolveScenarioFromTeamsBotConfig(config), config.scaffold.workingDir, config, actions);
    }
    static async scaffoldTriggers(group_name, config, actions = templatesActions_1.defaultActionSeq) {
        const scenarios = config.scaffold.triggers.map((trigger) => {
            return constants_1.TriggerTemplateScenarioMappings[trigger];
        });
        const projectRoot = config.scaffold.workingDir;
        for (const scenario of scenarios) {
            await this.getTemplateProject(group_name, scenario, path.join(projectRoot), config, actions);
        }
    }
    static async getTemplateProject(group_name, scenario, dst, config, actions = templatesActions_1.defaultActionSeq) {
        await templatesActions_1.scaffoldFromTemplates({
            group: group_name,
            lang: utils.convertToLangKey(config.scaffold.programmingLanguage),
            scenario: scenario,
            dst: dst,
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    logger_1.Logger.info(messages_1.Messages.SuccessfullyRetrievedTemplateZip((_a = context.zipUrl) !== null && _a !== void 0 ? _a : ""));
                }
            },
            onActionError: async (action, context, error) => {
                logger_1.Logger.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        logger_1.Logger.info(messages_1.Messages.FallingBackToUseLocalTemplateZip);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new errors_1.TemplateZipFallbackError();
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new errors_1.UnzipError(context.dst);
                    default:
                        throw new Error(error.message);
                }
            },
        }, actions);
    }
    static getSiteEnvelope(language, appServicePlanName, location, appSettings) {
        const siteEnvelope = {
            location: location,
            serverFarmId: appServicePlanName,
            siteConfig: {
                appSettings: [],
            },
        };
        if (!appSettings) {
            appSettings = [];
        }
        appSettings.push({
            name: "SCM_DO_BUILD_DURING_DEPLOYMENT",
            value: "true",
        });
        appSettings.push({
            name: "WEBSITE_NODE_DEFAULT_VERSION",
            value: "~14",
        });
        appSettings.forEach((p) => {
            var _a, _b;
            (_b = (_a = siteEnvelope === null || siteEnvelope === void 0 ? void 0 : siteEnvelope.siteConfig) === null || _a === void 0 ? void 0 : _a.appSettings) === null || _b === void 0 ? void 0 : _b.push(p);
        });
        return siteEnvelope;
    }
    static async localBuild(programmingLanguage, packDir, unPackFlag) {
        if (programmingLanguage === programmingLanguage_1.ProgrammingLanguage.TypeScript) {
            //Typescript needs tsc build before deploy because of windows app server. other languages don"t need it.
            try {
                await utils.execute("npm install", packDir);
                await utils.execute("npm run build", packDir);
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}, ${strings_1.Commands.NPM_BUILD}`, packDir, e);
            }
        }
        if (programmingLanguage === programmingLanguage_1.ProgrammingLanguage.JavaScript) {
            try {
                // fail to npm install @microsoft/teamsfx on azure web app, so pack it locally.
                await utils.execute("npm install", packDir);
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}`, packDir, e);
            }
        }
    }
    static resolveScenarioFromTeamsBotConfig(config) {
        if (config.actRoles.includes(pluginActRoles_1.PluginActRoles.Notification)) {
            if (config.scaffold.hostType === enum_1.HostType.AppService) {
                return constants_1.TemplateProjectsScenarios.NOTIFICATION_RESTIFY_SCENARIO_NAME;
            }
            else {
                return constants_1.TemplateProjectsScenarios.NOTIFICATION_FUNCTION_BASE_SCENARIO_NAME;
            }
        }
        else if (config.actRoles.includes(pluginActRoles_1.PluginActRoles.CommandAndResponse)) {
            return constants_1.TemplateProjectsScenarios.COMMAND_AND_RESPONSE_SCENARIO_NAME;
        }
        else {
            return config.isM365
                ? constants_1.TemplateProjectsScenarios.M365_SCENARIO_NAME
                : constants_1.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME;
        }
    }
}
exports.LanguageStrategy = LanguageStrategy;
//# sourceMappingURL=languageStrategy.js.map