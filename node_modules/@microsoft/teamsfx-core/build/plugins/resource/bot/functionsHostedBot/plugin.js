"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionsHostedBotImpl = void 0;
const tslib_1 = require("tslib");
const languageStrategy_1 = require("../languageStrategy");
const messages_1 = require("../resources/messages");
const result_1 = require("../result");
const constants_1 = require("../constants");
const strings_1 = require("../resources/strings");
const errors_1 = require("../errors");
const progressBars_1 = require("../progressBars");
const logger_1 = require("../logger");
const plugin_1 = require("../plugin");
const ResourcePluginContainer_1 = require("../../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../../solution/fx-solution/v2/adaptor");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const folder_1 = require("../../../../folder");
const constants_2 = require("../../../../common/constants");
const common_1 = require("../../../../common");
const deployMgr_1 = require("./deployMgr");
const appService = tslib_1.__importStar(require("@azure/arm-appservice"));
const zipDeploy_1 = require("../utils/zipDeploy");
const utils = tslib_1.__importStar(require("../utils/common"));
const azureOps_1 = require("../../../../common/azure-hosting/azureOps");
const hostingConstant_1 = require("../../../../common/azure-hosting/hostingConstant");
const enum_1 = require("../v2/enum");
class FunctionsHostedBotImpl extends plugin_1.TeamsBotImpl {
    async scaffold(context) {
        this.ctx = context;
        await this.config.restoreConfigFromContext(context, true);
        this.config.scaffold.hostType = enum_1.HostType.Functions;
        logger_1.Logger.info(messages_1.Messages.ScaffoldingBot);
        // title must match closeProgressBar in bot/index.ts::scaffold()
        const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_1.ProgressBarConstants.SCAFFOLD_TITLE, constants_1.ProgressBarConstants.SCAFFOLD_FUNCTIONS_NOTIFICATION_STEPS_NUM, this.ctx);
        await (handler === null || handler === void 0 ? void 0 : handler.start(constants_1.ProgressBarConstants.SCAFFOLD_FUNCTIONS_NOTIFICATION_STEP_START));
        // 1. Copy the corresponding template project into target directory.
        const group_name = constants_1.TemplateProjectsConstants.GROUP_NAME_BOT;
        if (!this.config.actRoles) {
            throw new errors_1.SomethingMissingError("act roles");
        }
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.SCAFFOLD_FUNCTIONS_NOTIFICATION_STEP_FETCH_PROJECT_TEMPLATE));
        await languageStrategy_1.LanguageStrategy.scaffoldProject(group_name, this.config);
        // 2. Copy the trigger template(s) into the trigger directories.
        // For example,
        //  templates/bot/ts/notification-trigger-http ==> ${projectRoot}/notifyHttpTrigger
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.SCAFFOLD_FUNCTIONS_NOTIFICATION_STEP_FETCH_TRIGGER_TEMPLATE));
        await languageStrategy_1.LanguageStrategy.scaffoldTriggers(group_name, this.config);
        this.config.saveConfigIntoContext(context);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyScaffoldedBot);
        return result_1.FxBotPluginResultFactory.Success();
    }
    async generateArmTemplates(ctx) {
        logger_1.Logger.info(messages_1.Messages.GeneratingArmTemplatesBot);
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const pluginCtx = { plugins: plugins.map((obj) => obj.name) };
        const bicepTemplateDir = path.join(folder_1.getTemplatesFolder(), constants_1.PathInfo.BicepTemplateRelativeDir);
        const provisionOrchestration = await common_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_2.Bicep.ProvisionFileName), pluginCtx);
        const provisionModules = await common_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_1.PathInfo.FuncHostedProvisionModuleTemplateFileName), pluginCtx);
        const configOrchestration = await common_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_2.Bicep.ConfigFileName), pluginCtx);
        const configModule = await common_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_1.PathInfo.ConfigurationModuleTemplateFileName), pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { bot: provisionModules },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { bot: configModule },
            },
            Reference: {
                resourceId: constants_1.BotBicep.resourceId,
                hostName: constants_1.BotBicep.hostName,
                webAppEndpoint: constants_1.BotBicep.webAppEndpoint,
            },
            Parameters: JSON.parse(await fs.readFile(path.join(bicepTemplateDir, constants_2.Bicep.ParameterFileName), constants_2.ConstantString.UTF8Encoding)),
        };
        logger_1.Logger.info(messages_1.Messages.SuccessfullyGenerateArmTemplatesBot);
        return result_1.FxBotPluginResultFactory.Success(result);
    }
    async deploy(context) {
        var _a, _b;
        this.ctx = context;
        await this.config.restoreConfigFromContext(context);
        this.config.provision.subscriptionId = common_1.getSubscriptionIdFromResourceId(this.config.provision.botWebAppResourceId);
        this.config.provision.resourceGroup = common_1.getResourceGroupNameFromResourceId(this.config.provision.botWebAppResourceId);
        this.config.provision.siteName = common_1.getSiteNameFromResourceId(this.config.provision.botWebAppResourceId);
        logger_1.Logger.info(messages_1.Messages.DeployingBot);
        const workingDir = this.config.scaffold.workingDir;
        if (!workingDir) {
            throw new errors_1.PreconditionError(messages_1.Messages.WorkingDirIsMissing, []);
        }
        const programmingLanguage = this.config.scaffold.programmingLanguage;
        if (!programmingLanguage) {
            throw new errors_1.PreconditionError(messages_1.Messages.SomethingIsMissing(strings_1.PluginBot.PROGRAMMING_LANGUAGE), []);
        }
        const deployMgr = new deployMgr_1.FuncHostedDeployMgr(workingDir, this.ctx.envInfo.envName);
        const needsToRedeploy = await deployMgr.needsToRedeploy();
        if (!needsToRedeploy) {
            logger_1.Logger.debug(messages_1.Messages.SkipDeployNoUpdates);
            return result_1.FxBotPluginResultFactory.Success();
        }
        const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_1.ProgressBarConstants.DEPLOY_TITLE, constants_1.ProgressBarConstants.DEPLOY_STEPS_NUM, this.ctx);
        await (handler === null || handler === void 0 ? void 0 : handler.start(constants_1.ProgressBarConstants.DEPLOY_STEP_START));
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_NPM_INSTALL));
        await languageStrategy_1.LanguageStrategy.localBuild(programmingLanguage, workingDir);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_ZIP_FOLDER));
        const deployTime = new Date();
        const rules = await deployMgr.getIgnoreRules(hostingConstant_1.DeployConfigsConstants.FUNC_IGNORE_FILE);
        const zipBuffer = await deployMgr.zipAFolder(rules);
        // 2.2 Retrieve publishing credentials.
        const webSiteMgmtClient = new appService.WebSiteManagementClient(await this.getAzureAccountCredential(), this.config.provision.subscriptionId);
        const listResponse = await azureOps_1.AzureOperations.listPublishingCredentials(webSiteMgmtClient, this.config.provision.resourceGroup, this.config.provision.siteName);
        const publishingUserName = (_a = listResponse.publishingUserName) !== null && _a !== void 0 ? _a : "";
        const publishingPassword = (_b = listResponse.publishingPassword) !== null && _b !== void 0 ? _b : "";
        const encryptedCreds = utils.toBase64(`${publishingUserName}:${publishingPassword}`);
        const config = {
            headers: {
                "Content-Type": "application/octet-stream",
                "Cache-Control": "no-cache",
                Authorization: `Basic ${encryptedCreds}`,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            timeout: hostingConstant_1.AzureOperationCommonConstants.deployTimeoutInMs,
        };
        const zipDeployEndpoint = zipDeploy_1.getZipDeployEndpoint(this.config.provision.siteName);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_ZIP_DEPLOY));
        const statusUrl = await azureOps_1.AzureOperations.zipDeployPackage(zipDeployEndpoint, zipBuffer, config);
        await azureOps_1.AzureOperations.checkDeployStatus(statusUrl, config);
        await azureOps_1.AzureOperations.restartWebApp(webSiteMgmtClient, this.config.provision.resourceGroup, this.config.provision.siteName);
        await deployMgr.saveDeploymentInfo(zipBuffer, deployTime);
        this.config.saveConfigIntoContext(context);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyDeployedBot);
        return result_1.FxBotPluginResultFactory.Success();
    }
}
exports.FunctionsHostedBotImpl = FunctionsHostedBotImpl;
//# sourceMappingURL=plugin.js.map