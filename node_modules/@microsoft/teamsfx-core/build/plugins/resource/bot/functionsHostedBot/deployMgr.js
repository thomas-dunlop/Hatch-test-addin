"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuncHostedDeployMgr = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const dir_walk_1 = require("../utils/dir-walk");
const constants_1 = require("../constants");
const logger_1 = require("../logger");
const hostingConstant_1 = require("../../../../common/azure-hosting/hostingConstant");
class FuncHostedDeployMgr {
    constructor(workingDir, envName) {
        this.workingDir = workingDir;
        this.deploymentDir = path.join(workingDir, constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        this.deploymentInfoFile = path.join(this.deploymentDir, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_INFO_FILE);
        this.deploymentZipCacheFile = path.join(this.deploymentDir, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_ZIP_CACHE_FILE);
        this.envName = envName;
    }
    async getLastDeployTime() {
        try {
            const lastDeployJson = await fs.readJSON(this.deploymentInfoFile);
            return new Date(lastDeployJson[this.envName].time);
        }
        catch (err) {
            logger_1.Logger.debug(`readJson ${this.deploymentInfoFile} failed with error: ${err}.`);
            throw err;
        }
    }
    async needsToRedeploy() {
        try {
            const lastDeployTime = await this.getLastDeployTime();
            // Always ignore node_modules folder and bin folder and the file ignored both by git and func.
            const defaultIgnore = await FuncHostedDeployMgr.prepareIgnore([constants_1.FolderNames.NODE_MODULES]);
            const funcIgnoreRules = await this.getIgnoreRules(hostingConstant_1.DeployConfigsConstants.FUNC_IGNORE_FILE);
            const funcIgnore = await FuncHostedDeployMgr.prepareIgnore(funcIgnoreRules);
            const gitIgnoreRules = await this.getIgnoreRules(hostingConstant_1.DeployConfigsConstants.GIT_IGNORE_FILE);
            const gitIgnore = await FuncHostedDeployMgr.prepareIgnore(gitIgnoreRules);
            let changed = false;
            await dir_walk_1.forEachFileAndDir(this.workingDir, (itemPath, stats) => {
                // Don't check the modification time of .deployment folder.
                const relativePath = path.relative(this.workingDir, itemPath);
                if (relativePath &&
                    !defaultIgnore.test(relativePath).ignored &&
                    !(funcIgnore.test(relativePath).ignored && gitIgnore.test(relativePath).ignored) &&
                    lastDeployTime < stats.mtime) {
                    changed = true;
                    // Return true to stop walking.
                    return true;
                }
            }, (itemPath) => path.basename(itemPath) !== constants_1.FolderNames.NODE_MODULES);
            return changed;
        }
        catch (e) {
            // Failed to check updated, but it doesn't block the deployment.
            return true;
        }
    }
    async saveDeploymentInfo(zipContent, deployTime) {
        var _a;
        var _b;
        await fs.ensureDir(this.deploymentDir);
        let lastDeployJson = {};
        try {
            lastDeployJson = await fs.readJSON(this.deploymentInfoFile);
        }
        catch (_c) {
            // It's fine if failed to read json from the deployment file.
        }
        (_a = lastDeployJson[_b = this.envName]) !== null && _a !== void 0 ? _a : (lastDeployJson[_b] = {});
        lastDeployJson[this.envName].time = deployTime;
        try {
            await fs.writeJSON(this.deploymentInfoFile, lastDeployJson);
            await fs.writeFile(this.deploymentZipCacheFile, zipContent);
        }
        catch (_d) {
            // Deploy still succeeded even we failed to record it.
        }
    }
    async loadLastDeploymentZipCache() {
        try {
            const content = await fs.readFile(this.deploymentZipCacheFile);
            return new adm_zip_1.default(content);
        }
        catch (_a) {
            // Failed to load cache, it doesn't block deployment.
        }
        return undefined;
    }
    removeLegacyFileInZip(zip, existenceFiles) {
        zip
            .getEntries()
            .filter((entry) => !existenceFiles.has(entry.name))
            .forEach((entry) => {
            zip.deleteFile(entry.name);
        });
    }
    async zipAFolder(rules) {
        // The granularity of time store in zip is 2-seconds.
        // To compare it with mtime in fs.Stats, we need to normalize them into same granularity.
        const normalizeTime = (t) => Math.floor(t / hostingConstant_1.AzureOperationCommonConstants.zipTimeMSGranularity);
        const zip = (await this.loadLastDeploymentZipCache()) || new adm_zip_1.default();
        const ig = await FuncHostedDeployMgr.prepareIgnore(rules);
        const tasks = [];
        const zipFiles = new Set();
        const addFileIntoZip = async (zip, filePath, zipPath, stats) => {
            const content = await fs.readFile(filePath);
            zip.addFile(zipPath, content);
            if (stats) {
                zip.getEntry(zipPath).header.time = stats.mtime;
            }
        };
        await dir_walk_1.forEachFileAndDir(this.workingDir, (itemPath, stats) => {
            const relativePath = path.relative(this.workingDir, itemPath);
            if (relativePath && !stats.isDirectory() && ig.filter([relativePath]).length > 0) {
                zipFiles.add(relativePath);
                const entry = zip.getEntry(relativePath);
                if (entry) {
                    // The header is an object, the ts declare of adm-zip is wrong.
                    const header = entry.header;
                    const mtime = header && header.time;
                    // Some files' mtime in node_modules are too old, which may be invalid,
                    // so we arbitrarily add a limitation to update this kind of files.
                    // If mtime is valid and the two mtime is same in two-seconds, we think the two are same file.
                    if (mtime >= hostingConstant_1.AzureOperationCommonConstants.latestTrustMtime &&
                        normalizeTime(mtime.getTime()) === normalizeTime(stats.mtime.getTime())) {
                        return;
                    }
                    // Delete the entry because the file has been updated.
                    zip.deleteFile(relativePath);
                }
                // If fail to reuse cached entry, load it from disk.
                const fullPath = path.join(this.workingDir, relativePath);
                const task = addFileIntoZip(zip, fullPath, relativePath, stats);
                tasks.push(task);
            }
        });
        await Promise.all(tasks);
        this.removeLegacyFileInZip(zip, zipFiles);
        return zip.toBuffer();
    }
    static async prepareIgnore(rules) {
        const ig = ignore_1.default().add(constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        for (const rule of rules) {
            ig.add(rule);
        }
        return ig;
    }
    async getIgnoreRules(fileName) {
        let result = [];
        const ignoreFilePath = path.join(this.workingDir, fileName);
        if (await fs.pathExists(ignoreFilePath)) {
            const ignoreFileContent = await fs.readFile(ignoreFilePath);
            result = ignoreFileContent
                .toString()
                .split("\n")
                .map((line) => line.trim());
        }
        return result;
    }
}
exports.FuncHostedDeployMgr = FuncHostedDeployMgr;
//# sourceMappingURL=deployMgr.js.map