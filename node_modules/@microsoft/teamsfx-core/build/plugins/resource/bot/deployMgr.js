"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployMgr = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("./constants");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const errors_1 = require("./errors");
const logger_1 = require("./logger");
const dir_walk_1 = require("./utils/dir-walk");
const messages_1 = require("./resources/messages");
class DeployMgr {
    constructor(workingDir, envName) {
        this.workingDir = workingDir;
        this.deploymentDir = path.join(workingDir, constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        this.envName = envName;
    }
    async init() {
        await fs.ensureDir(this.deploymentDir);
        const configFile = path.join(this.deploymentDir, constants_1.DeployConfigs.DEPLOYMENT_CONFIG_FILE);
        if (await fs.pathExists(configFile)) {
            return;
        }
        const botDeployJson = {};
        botDeployJson[this.envName] = { time: 0 };
        try {
            await fs.writeJSON(configFile, botDeployJson);
        }
        catch (e) {
            // If anything wrong here, don't throw exception to fail end users.
            logger_1.Logger.debug(`writeJson failed with target file: ${configFile}, json: ${botDeployJson} with error: ${e}.`);
        }
    }
    async needsToRedeploy() {
        // Iterate all source files and config files to determine if anything changed.
        if (!this.workingDir) {
            throw new errors_1.PreconditionError(messages_1.Messages.WorkingDirIsMissing, []);
        }
        const lastBotDeployTime = await this.getLastDeployTime();
        let changed = false;
        await dir_walk_1.forEachFileAndDir(this.workingDir, (itemPath, stats) => {
            const relativePath = path.relative(this.workingDir, itemPath);
            if (relativePath && stats.mtime.getTime() > lastBotDeployTime) {
                changed = true;
                // Return true to stop walking.
                return true;
            }
        }, (itemPath) => {
            return !constants_1.DeployConfigs.WALK_SKIP_PATHS.find((value) => {
                const absolutePathPrefix = path.join(this.workingDir, value);
                return itemPath.startsWith(absolutePathPrefix);
            });
        });
        return changed;
    }
    async updateLastDeployTime(time) {
        if (!this.deploymentDir) {
            throw new errors_1.SomethingMissingError(constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        }
        const configFile = path.join(this.deploymentDir, constants_1.DeployConfigs.DEPLOYMENT_CONFIG_FILE);
        let botDeployJson = {};
        try {
            botDeployJson = await fs.readJSON(configFile);
        }
        catch (e) {
            logger_1.Logger.debug(`readJson ${configFile} failed with error: ${e}.`);
        }
        botDeployJson[this.envName] = {
            time: time,
        };
        try {
            await fs.writeJson(configFile, botDeployJson);
        }
        catch (e) {
            // If anything wrong here, don't throw exception to fail end users.
            logger_1.Logger.debug(`writeJson ${configFile} failed with error: ${e}.`);
        }
    }
    async getLastDeployTime() {
        if (!this.deploymentDir) {
            throw new errors_1.SomethingMissingError(constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        }
        const configFile = path.join(this.deploymentDir, constants_1.DeployConfigs.DEPLOYMENT_CONFIG_FILE);
        let botDeployJson = undefined;
        try {
            botDeployJson = await fs.readJSON(configFile);
        }
        catch (e) {
            logger_1.Logger.debug(`readJson ${configFile} failed with error: ${e}.`);
            return 0;
        }
        if (!botDeployJson ||
            !botDeployJson[this.envName] ||
            !botDeployJson[this.envName].time ||
            typeof botDeployJson[this.envName].time !== constants_1.TypeNames.NUMBER ||
            botDeployJson[this.envName].time < 0) {
            return 0;
        }
        return botDeployJson[this.envName].time;
    }
}
exports.DeployMgr = DeployMgr;
//# sourceMappingURL=deployMgr.js.map