"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsBotV2Impl = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const scaffold_1 = require("./scaffold");
const utils = tslib_1.__importStar(require("../utils/common"));
const path_1 = tslib_1.__importDefault(require("path"));
const hostingFactory_1 = require("../../../../common/azure-hosting/hostingFactory");
const strings_1 = require("../resources/strings");
const errors_1 = require("../errors");
const interfaces_1 = require("../../../../common/azure-hosting/interfaces");
const constants_1 = require("../constants");
const utils_1 = require("../../../../common/azure-hosting/utils");
const ResourcePluginContainer_1 = require("../../../solution/fx-solution/ResourcePluginContainer");
const adaptor_1 = require("../../../solution/fx-solution/v2/adaptor");
const constants_2 = require("../../../../common/constants");
const messages_1 = require("../resources/messages");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const dir_walk_1 = require("../utils/dir-walk");
const logger_1 = require("../logger");
const progressBars_1 = require("../progressBars");
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const hostingConstant_1 = require("../../../../common/azure-hosting/hostingConstant");
const common_1 = require("./common");
const enum_1 = require("./enum");
const mapping_1 = require("./mapping");
class TeamsBotV2Impl {
    constructor() {
        this.name = strings_1.PluginBot.PLUGIN_NAME;
    }
    async scaffoldSourceCode(ctx, inputs) {
        logger_1.Logger.info(messages_1.Messages.ScaffoldingBot);
        const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_1.ProgressBarConstants.SCAFFOLD_TITLE, constants_1.ProgressBarConstants.SCAFFOLD_STEPS_NUM, ctx);
        await (handler === null || handler === void 0 ? void 0 : handler.start(constants_1.ProgressBarConstants.SCAFFOLD_STEP_START));
        const lang = mapping_1.getLanguage(ctx.projectSetting.programmingLanguage);
        const projectPath = errors_1.checkPrecondition(messages_1.Messages.WorkingDirIsMissing, inputs.projectPath);
        const workingPath = TeamsBotV2Impl.getWorkingPath(projectPath, lang);
        const hostType = common_1.resolveHostType(inputs);
        const botCapabilities = common_1.resolveBotCapabilities(inputs);
        utils.checkAndSavePluginSettingV2(ctx, strings_1.PluginBot.HOST_TYPE, hostType);
        utils.checkAndSavePluginSettingV2(ctx, strings_1.PluginBot.BOT_CAPABILITIES, botCapabilities);
        const templateInfos = common_1.getTemplateInfos(ctx, inputs);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_1.ProgressBarConstants.SCAFFOLD_STEP_FETCH_ZIP));
        await Promise.all(templateInfos.map(async (templateInfo) => {
            await scaffold_1.scaffold(templateInfo, workingPath);
        }));
        await progressBars_1.ProgressBarFactory.closeProgressBar(true, constants_1.ProgressBarConstants.SCAFFOLD_TITLE);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyScaffoldedBot);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async generateResourceTemplate(ctx, inputs) {
        logger_1.Logger.info(messages_1.Messages.GeneratingArmTemplatesBot);
        const bicepContext = TeamsBotV2Impl.getBicepContext(ctx, inputs);
        const serviceTypes = [common_1.resolveServiceType(ctx), interfaces_1.ServiceType.BotService];
        const templates = await Promise.all(serviceTypes.map((serviceType) => {
            const hosting = hostingFactory_1.AzureHostingFactory.createHosting(serviceType);
            hosting.setLogger(logger_1.Logger);
            return hosting.generateBicep(bicepContext);
        }));
        const result = utils_1.mergeTemplates(templates);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyGenerateArmTemplatesBot);
        return teamsfx_api_1.ok({ kind: "bicep", template: result });
    }
    async updateResourceTemplate(ctx, inputs) {
        logger_1.Logger.info(messages_1.Messages.UpdatingArmTemplatesBot);
        const bicepContext = TeamsBotV2Impl.getBicepContext(ctx, inputs);
        const serviceTypes = [common_1.resolveServiceType(ctx), interfaces_1.ServiceType.BotService];
        const templates = await Promise.all(serviceTypes.map((serviceType) => {
            const hosting = hostingFactory_1.AzureHostingFactory.createHosting(serviceType);
            hosting.setLogger(logger_1.Logger);
            return hosting.updateBicep(bicepContext);
        }));
        const result = utils_1.mergeTemplates(templates);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyUpdateArmTemplatesBot);
        return teamsfx_api_1.ok({ kind: "bicep", template: result });
    }
    static getBicepContext(ctx, inputs) {
        const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSetting).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p));
        const bicepConfigs = TeamsBotV2Impl.getBicepConfigs(ctx, inputs);
        return {
            plugins: plugins.map((obj) => obj.name),
            configs: bicepConfigs,
            moduleNames: mapping_1.moduleMap,
            moduleAlias: constants_1.Alias.BICEP_MODULE,
            pluginId: constants_2.ResourcePlugins.Bot,
        };
    }
    async configureResource(ctx, inputs, envInfo, tokenProvider) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deploy(ctx, inputs, envInfo, tokenProvider) {
        var _a;
        logger_1.Logger.info(messages_1.Messages.DeployingBot);
        const projectPath = errors_1.checkPrecondition(messages_1.Messages.WorkingDirIsMissing, inputs.projectPath);
        const language = mapping_1.getLanguage(ctx.projectSetting.programmingLanguage);
        const workingPath = TeamsBotV2Impl.getWorkingPath(projectPath, language);
        const projectFileName = mapping_1.getProjectFileName(mapping_1.getRuntime(language), ctx.projectSetting.appName);
        const hostType = common_1.resolveServiceType(ctx);
        const deployDir = path_1.default.join(workingPath, constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        const configFile = TeamsBotV2Impl.configFile(workingPath);
        const deploymentZipCacheFile = path_1.default.join(deployDir, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_ZIP_CACHE_FILE);
        const envName = errors_1.checkAndThrowIfMissing(strings_1.ConfigNames.ENV, inputs.env);
        // list of files that need to be detected for both file changes and uploads
        const generalIgnore = await TeamsBotV2Impl.generateIgnoreRules(await TeamsBotV2Impl.ensureIgnoreFile(hostType, workingPath), workingPath);
        // For backward compatibility, get resource id from both key `botWebAppResourceId` and `resourceId`
        // get Azure resources definition
        const botWebAppResourceId = envInfo.state[this.name][strings_1.PluginBot.BOT_WEB_APP_RESOURCE_ID];
        const resourceId = errors_1.checkPrecondition(messages_1.Messages.SomethingIsMissing(strings_1.PluginBot.RESOURCE_ID), (_a = envInfo.state[this.name][strings_1.PluginBot.RESOURCE_ID]) !== null && _a !== void 0 ? _a : botWebAppResourceId);
        // create config file if not exists
        await fs_extra_1.default.ensureDir(deployDir);
        await TeamsBotV2Impl.initDeployConfig(ctx, configFile, envName);
        if (!(await TeamsBotV2Impl.needDeploy(workingPath, configFile, envName))) {
            logger_1.Logger.warning(messages_1.Messages.SkipDeployNoUpdates);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const progressBarHandler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_1.ProgressBarConstants.DEPLOY_TITLE, constants_1.ProgressBarConstants.DEPLOY_STEPS_NUM, ctx);
        // progress start
        await progressBarHandler.start(constants_1.ProgressBarConstants.DEPLOY_STEP_START);
        // build
        await progressBarHandler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_NPM_INSTALL);
        const zippedPath = await TeamsBotV2Impl.localBuild(language, workingPath, projectFileName);
        // pack
        await progressBarHandler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_ZIP_FOLDER);
        const zipBuffer = await utils.zipFolderAsync(zippedPath, deploymentZipCacheFile, await TeamsBotV2Impl.prepareIgnore(generalIgnore));
        // upload
        const host = hostingFactory_1.AzureHostingFactory.createHosting(hostType);
        host.setLogger(logger_1.Logger);
        await progressBarHandler.next(constants_1.ProgressBarConstants.DEPLOY_STEP_ZIP_DEPLOY);
        await host.deploy(resourceId, tokenProvider, zipBuffer);
        const deployTimeCandidate = Date.now();
        await TeamsBotV2Impl.saveDeploymentInfo(configFile, envName, deployTimeCandidate, deploymentZipCacheFile, zipBuffer);
        // close bar
        await progressBars_1.ProgressBarFactory.closeProgressBar(true, constants_1.ProgressBarConstants.DEPLOY_TITLE);
        logger_1.Logger.info(messages_1.Messages.SuccessfullyDeployedBot);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async provisionLocalResource(ctx, inputs, localSettings, tokenProvider, envInfo) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async configureLocalResource(ctx, inputs, localSettings, tokenProvider, envInfo) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    static getBicepConfigs(ctx, inputs) {
        const bicepConfigs = [];
        const lang = mapping_1.getLanguage(ctx.projectSetting.programmingLanguage);
        bicepConfigs.push(mapping_1.getRuntime(lang));
        bicepConfigs.push("running-on-azure");
        return bicepConfigs;
    }
    static async localBuild(lang, workingPath, projectFileName) {
        // Return the folder path to be zipped and uploaded
        if (lang === enum_1.ProgrammingLanguage.Ts) {
            //Typescript needs tsc build before deploy because of Windows app server. other languages don"t need it.
            try {
                await utils.execute("npm install", workingPath);
                await utils.execute("npm run build", workingPath);
                return workingPath;
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL},${strings_1.Commands.NPM_BUILD}`, workingPath, e);
            }
        }
        if (lang === enum_1.ProgrammingLanguage.Js) {
            try {
                // fail to npm install @microsoft/teamsfx on azure web app, so pack it locally.
                await utils.execute("npm install", workingPath);
                return workingPath;
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}`, workingPath, e);
            }
        }
        if (lang === enum_1.ProgrammingLanguage.Csharp) {
            try {
                await utils.execute(`dotnet publish --output publish --configuration Release`, workingPath);
                return path_1.default.join(workingPath, "publish");
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`dotnet publish`, workingPath, e);
            }
        }
        throw new Error("Invalid programming language");
    }
    /**
     * create deploy log file if not exists
     * @param ctx context
     * @param configFile the config file needed to write
     * @param envName name of the env
     * @private
     */
    static async initDeployConfig(ctx, configFile, envName) {
        if (!(await fs_extra_1.default.pathExists(configFile))) {
            try {
                await fs_extra_1.default.writeJSON(configFile, { [envName]: { time: 0 } });
            }
            catch (e) {
                await logger_1.Logger.debug(`init deploy json failed with target file: ${configFile} with error: ${e}.`);
            }
        }
    }
    /**
     * determine if dir need deploy, or all file are not changed after last deploy
     * @param workingPath base dir
     * @param configFile config file location
     * @param env current env
     */
    static async needDeploy(workingPath, configFile, env) {
        var _a, _b;
        const botDeployJson = await fs_extra_1.default.readJSON(configFile);
        const lastTime = Math.max((_b = (_a = botDeployJson[env]) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : 0, 0);
        // prepare ignore file
        const gitIgnore = await TeamsBotV2Impl.generateIgnoreRules(hostingConstant_1.DeployConfigsConstants.GIT_IGNORE_FILE, workingPath);
        // general ignore will ignore ts file, so source change will not trigger rebuild and redeploy
        // so just use git ignore will be ok
        const totalIgnore = await TeamsBotV2Impl.prepareIgnore(gitIgnore);
        const filter = (itemPath) => path_1.default.basename(itemPath) !== constants_1.FolderNames.NODE_MODULES;
        let changed = false;
        try {
            await dir_walk_1.forEachFileAndDir(workingPath, (itemPath, status) => {
                const relativePath = path_1.default.relative(workingPath, itemPath);
                if (relativePath &&
                    status.mtime.getTime() > lastTime &&
                    !totalIgnore.test(relativePath).ignored) {
                    changed = true;
                    return true;
                }
            }, filter);
            return changed;
        }
        catch (_c) {
            return true;
        }
    }
    static async saveDeploymentInfo(configFile, env, time, deploymentZipCacheFile, zipContent) {
        const botDeployJson = await fs_extra_1.default.readJSON(configFile);
        botDeployJson[env] = {
            time: time,
        };
        try {
            await Promise.all([
                fs_extra_1.default.writeJSON(configFile, botDeployJson),
                fs_extra_1.default.writeFile(deploymentZipCacheFile, zipContent),
            ]);
        }
        catch (e) {
            logger_1.Logger.debug(`writeJson ${configFile} failed with error: ${e}.`);
        }
    }
    static async prepareIgnore(rules) {
        const ig = ignore_1.default().add(constants_1.DeployConfigs.DEPLOYMENT_FOLDER);
        for (const rule of rules) {
            ig.add(rule);
        }
        return ig;
    }
    /**
     * read every line from workDir/filename and return workDir/[lineContent]
     * @param fileName file name
     * @param workingPath base dir
     */
    static async generateIgnoreRules(fileName, workingPath) {
        if (!fileName) {
            return [];
        }
        let result = [];
        const ignoreFilePath = path_1.default.join(workingPath, fileName);
        if (await fs_extra_1.default.pathExists(ignoreFilePath)) {
            const ignoreFileContent = await fs_extra_1.default.readFile(ignoreFilePath);
            result = ignoreFileContent
                .toString()
                .split("\n")
                .map((line) => line.trim());
        }
        return result;
    }
    static async ensureIgnoreFile(hostType, workingPath) {
        const defaultAppIgnore = constants_1.DeployConfigs.WALK_SKIP_PATHS.join("\n");
        switch (hostType) {
            case interfaces_1.ServiceType.Functions:
                return hostingConstant_1.DeployConfigsConstants.FUNC_IGNORE_FILE;
            case interfaces_1.ServiceType.AppService: {
                const fileName = `.${hostType.toString()}ignore`;
                if (!fs_extra_1.default.existsSync(path_1.default.join(workingPath, fileName))) {
                    await fs_extra_1.default.writeFile(path_1.default.join(workingPath, fileName), defaultAppIgnore);
                }
                return fileName;
            }
            default:
                return "";
        }
    }
    static configFile(workingDir) {
        return path_1.default.join(workingDir, constants_1.DeployConfigs.DEPLOYMENT_FOLDER, hostingConstant_1.DeployConfigsConstants.DEPLOYMENT_INFO_FILE);
    }
    /**
     * read dotnet framework version from project file
     * @param projectFilePath project base folder
     */
    static async getFrameworkVersion(projectFilePath) {
        const reg = /(?<=<TargetFramework>)(.*)(?=<)/gim;
        const content = await fs_extra_1.default.readFile(projectFilePath, "utf8");
        const framework = content.match(reg);
        if (framework === null || framework === void 0 ? void 0 : framework.length) {
            return framework[0].trim();
        }
        return constants_1.DEFAULT_DOTNET_FRAMEWORK;
    }
    static getWorkingPath(projectPath, language) {
        return language === enum_1.ProgrammingLanguage.Csharp
            ? projectPath
            : path_1.default.join(projectPath, strings_1.CommonStrings.BOT_WORKING_DIR_NAME);
    }
}
exports.TeamsBotV2Impl = TeamsBotV2Impl;
exports.default = new TeamsBotV2Impl();
//# sourceMappingURL=plugin.js.map