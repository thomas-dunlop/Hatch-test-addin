"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAppServicePlanConfig = exports.convertToTelemetryName = exports.convertToLangKey = exports.isHttpCodeAccepted = exports.isHttpCodeOkOrCreated = exports.convertToConstValues = exports.existsInEnumValues = exports.checkAndSavePluginSettingV2 = exports.checkAndSavePluginSetting = exports.checkAndSaveConfig = exports.execute = exports.isDomainValidForAzureWebApp = exports.isValidBotChannelRegName = exports.isValidAppServicePlanName = exports.isValidWebAppSiteName = exports.zipFolderAsync = exports.zipAFolder = exports.genUUID = exports.toBase64 = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const js_base64_1 = require("js-base64");
const node_ts_uuid_1 = require("node-ts-uuid");
const child_process_1 = require("child_process");
const url_parse_1 = tslib_1.__importDefault(require("url-parse"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const constants_1 = require("../constants");
const programmingLanguage_1 = require("../enums/programmingLanguage");
const strings_1 = require("../resources/strings");
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const fs = tslib_1.__importStar(require("fs-extra"));
const dir_walk_1 = require("./dir-walk");
const path_1 = tslib_1.__importDefault(require("path"));
const hostingConstant_1 = require("../../../../common/azure-hosting/hostingConstant");
function toBase64(source) {
    return js_base64_1.Base64.encode(source);
}
exports.toBase64 = toBase64;
function genUUID() {
    return node_ts_uuid_1.Uuid.generate();
}
exports.genUUID = genUUID;
function zipAFolder(sourceDir, notIncluded, mustIncluded) {
    const zip = buildZip(sourceDir, notIncluded, mustIncluded);
    return zip.toBuffer();
}
exports.zipAFolder = zipAFolder;
/**
 * Asynchronously zip a folder and return buffer
 * @param sourceDir base dir
 * @param notIncluded block list
 * @param cache zip cache file location
 */
async function zipFolderAsync(sourceDir, cache, notIncluded) {
    const normalizeTime = (t) => Math.floor(t / hostingConstant_1.AzureOperationCommonConstants.zipTimeMSGranularity);
    const tasks = [];
    const zipFiles = new Set();
    const ig = notIncluded !== null && notIncluded !== void 0 ? notIncluded : ignore_1.default();
    const zip = (await readZipFromCache(cache)) || new adm_zip_1.default();
    const addFileIntoZip = async (zp, filePath, zipPath, stats) => {
        const content = await fs.readFile(filePath);
        zp.addFile(zipPath, content);
        if (stats) {
            zp.getEntry(zipPath).header.time = stats.mtime;
        }
    };
    await dir_walk_1.forEachFileAndDir(sourceDir, (itemPath, stats) => {
        const relativePath = path_1.default.relative(sourceDir, itemPath);
        if (relativePath && !stats.isDirectory() && ig.filter([relativePath]).length > 0) {
            zipFiles.add(relativePath);
            const entry = zip.getEntry(relativePath);
            if (entry) {
                // The header is an object, the ts declare of adm-zip is wrong.
                const header = entry.header;
                const mtime = header && header.time;
                // Some files' mtime in node_modules are too old, which may be invalid,
                // so we arbitrarily add a limitation to update this kind of files.
                // If mtime is valid and the two mtime is same in two-seconds, we think the two are same file.
                if (mtime >= hostingConstant_1.AzureOperationCommonConstants.latestTrustMtime &&
                    normalizeTime(mtime.getTime()) === normalizeTime(stats.mtime.getTime())) {
                    return;
                }
                // Delete the entry because the file has been updated.
                zip.deleteFile(relativePath);
            }
            // If fail to reuse cached entry, load it from disk.
            const fullPath = path_1.default.join(sourceDir, relativePath);
            const task = addFileIntoZip(zip, fullPath, relativePath, stats);
            tasks.push(task);
        }
    });
    await Promise.all(tasks);
    removeLegacyFileInZip(zip, zipFiles);
    return zip.toBuffer();
}
exports.zipFolderAsync = zipFolderAsync;
async function readZipFromCache(cache) {
    try {
        const content = await fs.readFile(cache);
        return new adm_zip_1.default(content);
    }
    catch (_a) {
        // Failed to load cache, it doesn't block deployment.
    }
    return undefined;
}
function removeLegacyFileInZip(zip, existenceFiles) {
    zip
        .getEntries()
        .filter((entry) => !existenceFiles.has(entry.name))
        .forEach((entry) => {
        zip.deleteFile(entry.name);
    });
}
function buildZip(sourceDir, notIncluded, mustIncluded) {
    const zip = new adm_zip_1.default();
    zip.addLocalFolder(sourceDir, "", (filename) => {
        if (mustIncluded) {
            const hit = mustIncluded.find((mustItem) => {
                return filename.startsWith(mustItem);
            });
            if (hit) {
                return true;
            }
        }
        if (notIncluded) {
            const hit = notIncluded.find((notIncludedItem) => {
                return filename.startsWith(notIncludedItem);
            });
            return !hit;
        }
        return true;
    });
    return zip;
}
function isValidWebAppSiteName(name) {
    return constants_1.RegularExprs.WEB_APP_SITE_NAME.test(name);
}
exports.isValidWebAppSiteName = isValidWebAppSiteName;
function isValidAppServicePlanName(name) {
    return constants_1.RegularExprs.APP_SERVICE_PLAN_NAME.test(name);
}
exports.isValidAppServicePlanName = isValidAppServicePlanName;
function isValidBotChannelRegName(name) {
    return constants_1.RegularExprs.BOT_CHANNEL_REG_NAME.test(name);
}
exports.isValidBotChannelRegName = isValidBotChannelRegName;
function isDomainValidForAzureWebApp(url) {
    return url_parse_1.default(url).hostname.endsWith(constants_1.WebAppConstants.WEB_APP_SITE_DOMAIN);
}
exports.isDomainValidForAzureWebApp = isDomainValidForAzureWebApp;
async function execute(command, workingDir) {
    return new Promise((resolve, reject) => {
        if (!workingDir) {
            workingDir = __dirname;
        }
        child_process_1.exec(command, { cwd: workingDir }, (error, standardOutput) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(standardOutput);
        });
    });
}
exports.execute = execute;
function checkAndSaveConfig(context, key, value) {
    if (!value) {
        return;
    }
    context.config.set(key, value);
}
exports.checkAndSaveConfig = checkAndSaveConfig;
function checkAndSavePluginSetting(context, key, value) {
    if (!value || !context.projectSettings) {
        return;
    }
    if (!context.projectSettings.pluginSettings) {
        context.projectSettings.pluginSettings = {};
    }
    if (!context.projectSettings.pluginSettings[strings_1.PluginBot.PLUGIN_NAME]) {
        context.projectSettings.pluginSettings[strings_1.PluginBot.PLUGIN_NAME] = {};
    }
    context.projectSettings.pluginSettings[strings_1.PluginBot.PLUGIN_NAME][key] = value;
}
exports.checkAndSavePluginSetting = checkAndSavePluginSetting;
function checkAndSavePluginSettingV2(context, key, value) {
    if (!value || !context.projectSetting) {
        return;
    }
    if (!context.projectSetting.pluginSettings) {
        context.projectSetting.pluginSettings = {};
    }
    if (!context.projectSetting.pluginSettings[strings_1.PluginBot.PLUGIN_NAME]) {
        context.projectSetting.pluginSettings[strings_1.PluginBot.PLUGIN_NAME] = {};
    }
    context.projectSetting.pluginSettings[strings_1.PluginBot.PLUGIN_NAME][key] = value;
}
exports.checkAndSavePluginSettingV2 = checkAndSavePluginSettingV2;
function existsInEnumValues(value, targetEnum) {
    return Object.values(targetEnum).find((itemValue) => value === itemValue) !== undefined;
}
exports.existsInEnumValues = existsInEnumValues;
function convertToConstValues(value, targetValues) {
    return Object.values(targetValues).find((itemValue) => value === itemValue);
}
exports.convertToConstValues = convertToConstValues;
function isHttpCodeOkOrCreated(code) {
    return [200, 201].includes(code);
}
exports.isHttpCodeOkOrCreated = isHttpCodeOkOrCreated;
function isHttpCodeAccepted(code) {
    return code === 202;
}
exports.isHttpCodeAccepted = isHttpCodeAccepted;
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case programmingLanguage_1.ProgrammingLanguage.JavaScript: {
            return "js";
        }
        case programmingLanguage_1.ProgrammingLanguage.TypeScript: {
            return "ts";
        }
        default: {
            return "js";
        }
    }
}
exports.convertToLangKey = convertToLangKey;
function convertToTelemetryName(raw) {
    return raw.toLowerCase().replace(/ /g, "-");
}
exports.convertToTelemetryName = convertToTelemetryName;
function generateAppServicePlanConfig(location, skuName) {
    return {
        location: location,
        kind: "app",
        sku: {
            name: skuName,
        },
    };
}
exports.generateAppServicePlanConfig = generateAppServicePlanConfig;
//# sourceMappingURL=common.js.map