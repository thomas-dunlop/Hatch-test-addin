"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CICDProvider = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const errors_1 = require("../errors");
const enums_1 = require("./enums");
const path_1 = tslib_1.__importDefault(require("path"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const folder_1 = require("../../../../folder");
const buildScripts_1 = require("../utils/buildScripts");
const utils_1 = require("../../../../common/utils");
const globalVars_1 = require("../../../../core/globalVars");
const projectSettingsHelperV3_1 = require("../../../../common/projectSettingsHelperV3");
class CICDProvider {
    constructor() {
        this.scaffoldTo = "";
        this.providerName = "";
    }
    async scaffold(projectPath, templateName, envName, context) {
        var _a, _b, _c, _d, _e;
        // 0. Preconditions check.
        if (!(await fs.pathExists(projectPath))) {
            throw new errors_1.NoProjectOpenedError();
        }
        if (!Object.values(enums_1.TemplateKind).includes(templateName)) {
            throw new errors_1.InternalError([
                `${templateName} as template kind was not recognized.`,
                `${templateName} as template kind was not recognized.`,
            ]);
        }
        if (!this.sourceTemplateName || !this.targetTemplateName) {
            throw new errors_1.InternalError([
                "sourceTemplateName or targetTemplateName shoudn't be undefined.",
                "sourceTemplateName or targetTemplateName shoudn't be undefined.",
            ]);
        }
        // 1. Ensure the target path is existing.
        const targetPath = path_1.default.join(projectPath, this.scaffoldTo);
        try {
            await fs.ensureDir(targetPath);
        }
        catch (e) {
            throw new errors_1.FileSystemError([`Fail to create path: ${targetPath}`, `Fail to create path: ${targetPath}`], e);
        }
        // 2. Generate README file.
        const targetReadMePath = path_1.default.join(targetPath, "README.md");
        if (!(await fs.pathExists(targetReadMePath))) {
            const localReadMePath = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "resource", "cicd", this.providerName, "README.md");
            try {
                await fs.copyFile(localReadMePath, targetReadMePath);
            }
            catch (e) {
                throw new errors_1.FileSystemError([`Fail to write file: ${targetReadMePath}`, `Fail to write file: ${targetReadMePath}`], e);
            }
        }
        // 3. Generate template file.
        let replacements;
        if (!globalVars_1.isV3()) {
            const hostType = (_a = context.projectSetting.solutionSettings) === null || _a === void 0 ? void 0 : _a.hostType;
            replacements = {
                env_name: envName,
                build_script: buildScripts_1.generateBuildScript(context.projectSetting),
                hosting_type_contains_spfx: hostType === "SPFx",
                hosting_type_contains_azure: hostType === "Azure",
                cloud_resources_contains_sql: (_c = (_b = context.projectSetting.solutionSettings) === null || _b === void 0 ? void 0 : _b["azureResources"].includes("sql")) !== null && _c !== void 0 ? _c : false,
                api_prefix: utils_1.convertToAlphanumericOnly(context.projectSetting.appName),
                cloud_resources_contains_apim: (_e = (_d = context.projectSetting.solutionSettings) === null || _d === void 0 ? void 0 : _d["azureResources"].includes("apim")) !== null && _e !== void 0 ? _e : false,
            };
        }
        else {
            const projectSettingsV3 = context.projectSetting;
            replacements = {
                env_name: envName,
                build_script: buildScripts_1.generateBuildScript(context.projectSetting),
                hosting_type_contains_spfx: projectSettingsHelperV3_1.hasSPFxTab(projectSettingsV3),
                hosting_type_contains_azure: projectSettingsHelperV3_1.hasAzureResourceV3(projectSettingsV3),
                cloud_resources_contains_sql: projectSettingsHelperV3_1.hasSQL(projectSettingsV3),
                api_prefix: utils_1.convertToAlphanumericOnly(context.projectSetting.appName),
                cloud_resources_contains_apim: projectSettingsHelperV3_1.hasAPIM(projectSettingsV3),
            };
        }
        const targetTemplatePath = path_1.default.join(targetPath, this.targetTemplateName(templateName, envName));
        if (!(await fs.pathExists(targetTemplatePath))) {
            const localTemplatePath = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "resource", "cicd", this.providerName, this.sourceTemplateName(templateName));
            const templateContent = await this.readLocalFile(localTemplatePath);
            const renderedContent = mustache_1.default.render(templateContent, replacements);
            try {
                await fs.writeFile(targetTemplatePath, renderedContent);
            }
            catch (e) {
                throw new errors_1.FileSystemError([
                    `Fail to write file: ${targetTemplatePath}`,
                    `Fail to write file: ${targetTemplatePath}`,
                ], e);
            }
        }
        else {
            return teamsfx_api_1.ok(true); // indicate that the template is existing before this scaffold.
        }
        return teamsfx_api_1.ok(false); // indicate it's newly scaffolded template.
    }
    async readLocalFile(localPath) {
        if (!(await fs.pathExists(localPath))) {
            throw new errors_1.InternalError([
                `local path: ${localPath} not found.`,
                `local path: ${localPath} not found.`,
            ]);
        }
        try {
            return (await fs.readFile(localPath)).toString();
        }
        catch (e) {
            throw new errors_1.FileSystemError([`Fail to read file: ${localPath}`, `Fail to read file: ${localPath}`], e);
        }
    }
}
exports.CICDProvider = CICDProvider;
//# sourceMappingURL=provider.js.map