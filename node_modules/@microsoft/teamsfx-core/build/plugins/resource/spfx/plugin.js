"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const localizeUtils_1 = require("../../../common/localizeUtils");
const tools_1 = require("../../../common/tools");
const spfxTabCode_1 = require("../../../component/code/spfxTabCode");
const error_1 = require("./error");
const spoClient_1 = require("./spoClient");
const constants_1 = require("./utils/constants");
const progress_helper_1 = require("./utils/progress-helper");
const utils_1 = require("./utils/utils");
class SPFxPluginImpl {
    async postScaffold(ctx) {
        ctx.answers.projectPath = ctx.root;
        const workingDir = path.resolve(ctx.root, "SPFx");
        return await spfxTabCode_1.scaffoldSPFx(ctx, ctx.answers, workingDir);
    }
    async buildSPPackage(ctx) {
        var _a, _b, _c, _d;
        const progressHandler = await progress_helper_1.ProgressHelper.startPreDeployProgressHandler(ctx.ui);
        if (((_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.platform) === teamsfx_api_1.Platform.VSCode) {
            ctx.logProvider.outputChannel.show();
        }
        try {
            const workspacePath = `${ctx.root}/SPFx`;
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.NpmInstall));
            await utils_1.Utils.execute(`npm install`, "SPFx", workspacePath, ctx.logProvider, true);
            const gulpCommand = await SPFxPluginImpl.findGulpCommand(workspacePath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpBundle));
            await utils_1.Utils.execute(`${gulpCommand} bundle --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpPackage));
            await utils_1.Utils.execute(`${gulpCommand} package-solution --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
            const sharepointPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(sharepointPackage))) {
                throw error_1.NoSPPackageError(sharepointPackage);
            }
            const dir = path.normalize(path.parse(sharepointPackage).dir);
            if (((_b = ctx.answers) === null || _b === void 0 ? void 0 : _b.platform) === teamsfx_api_1.Platform.CLI) {
                const guidance = [
                    {
                        content: "Success: SharePoint package successfully built at ",
                        color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                    },
                    { content: dir, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", guidance, false);
            }
            else {
                const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.buildNotice", dir);
                (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", guidance, false, "OK");
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            await progress_helper_1.ProgressHelper.endPreDeployProgress(false);
            return teamsfx_api_1.err(error_1.BuildSPPackageError(error));
        }
    }
    async preDeploy(ctx) {
        return this.buildSPPackage(ctx);
    }
    async deploy(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const progressHandler = await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx.ui);
        let success = false;
        try {
            const tenant = await this.getTenant(ctx);
            if (tenant.isErr()) {
                return tenant;
            }
            spoClient_1.SPOClient.setBaseUrl(tenant.value);
            const spoToken = await tools_1.getSPFxToken(ctx.m365TokenProvider);
            if (!spoToken) {
                return teamsfx_api_1.err(error_1.GetSPOTokenFailedError());
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            }
            else {
                const res = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.spfx.createAppCatalogNotice", tenant.value), true, "OK", constants_1.Constants.READ_MORE));
                const confirm = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
                switch (confirm) {
                    case "OK":
                        try {
                            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.CreateSPAppCatalog));
                            await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        }
                        catch (e) {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(e));
                        }
                        let retry = 0;
                        appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                        while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.warning(`No tenant app catalog found, retry: ${retry}`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                            retry += 1;
                        }
                        if (appCatalogSite) {
                            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`Sharepoint tenant app catalog ${appCatalogSite} created, wait for a few minutes to be active.`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
                        }
                        else {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(new Error(localizeUtils_1.getLocalizedString("plugins.spfx,cannotGetAppcatalog"))));
                        }
                        break;
                    case constants_1.Constants.READ_MORE:
                        (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.openUrl(constants_1.Constants.CREATE_APP_CATALOG_GUIDE);
                        return teamsfx_api_1.ok(teamsfx_api_1.UserCancelError);
                    default:
                        return teamsfx_api_1.ok(undefined);
                }
            }
            const appPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(appPackage))) {
                return teamsfx_api_1.err(error_1.NoSPPackageError(appPackage));
            }
            const fileName = path.parse(appPackage).base;
            const bytes = await fs.readFile(appPackage);
            try {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.UploadAndDeploy));
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            }
            catch (e) {
                if (((_e = e.response) === null || _e === void 0 ? void 0 : _e.status) === 403) {
                    (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.showMessage("error", localizeUtils_1.getLocalizedString("plugins.spfx.deployFailedNotice", appCatalogSite), false, "OK");
                    return teamsfx_api_1.err(error_1.InsufficientPermissionError(appCatalogSite));
                }
                else {
                    return teamsfx_api_1.err(error_1.UploadAppPackageFailedError(e));
                }
            }
            const appID = await this.getAppID(ctx.root);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
            if (((_g = ctx.answers) === null || _g === void 0 ? void 0 : _g.platform) === teamsfx_api_1.Platform.CLI) {
                (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", guidance, false);
            }
            else {
                (_j = ctx.ui) === null || _j === void 0 ? void 0 : _j.showMessage("info", guidance, false, "OK");
            }
            success = true;
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            await progress_helper_1.ProgressHelper.endDeployProgress(success);
        }
    }
    async getTenant(ctx) {
        var _a, _b;
        const graphTokenRes = await ((_a = ctx.m365TokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken({ scopes: tools_1.GraphScopes }));
        const graphToken = (graphTokenRes === null || graphTokenRes === void 0 ? void 0 : graphTokenRes.isOk()) ? graphTokenRes.value : undefined;
        if (!graphToken) {
            return teamsfx_api_1.err(error_1.GetGraphTokenFailedError());
        }
        const graphTokenJsonRes = await ((_b = ctx.m365TokenProvider) === null || _b === void 0 ? void 0 : _b.getJsonObject({ scopes: tools_1.GraphScopes }));
        const tokenJson = (graphTokenJsonRes === null || graphTokenJsonRes === void 0 ? void 0 : graphTokenJsonRes.isOk()) ? graphTokenJsonRes.value : undefined;
        const username = tokenJson.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                return teamsfx_api_1.err(error_1.GetTenantFailedError(username));
            }
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.GetTenantFailedError(username, e));
        }
        return teamsfx_api_1.ok(tenant);
    }
    async getPackage(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const sharepointPackage = `${root}/SPFx/sharepoint/${solutionConfig.paths.zippedPackage}`;
        return sharepointPackage;
    }
    async getAppID(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
    static async findGulpCommand(rootPath) {
        let gulpCommand;
        const platform = process.platform;
        if (platform === "win32" &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp.cmd")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp.cmd");
        }
        else if ((platform === "linux" || platform === "darwin") &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp");
        }
        else {
            gulpCommand = "gulp";
        }
        return gulpCommand;
    }
}
exports.SPFxPluginImpl = SPFxPluginImpl;
//# sourceMappingURL=plugin.js.map