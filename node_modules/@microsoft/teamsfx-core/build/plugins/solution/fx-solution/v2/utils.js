"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPluginAndContextArray = exports.checkWetherProvisionSucceeded = exports.fillInSolutionSettings = exports.loadTeamsAppTenantIdForLocal = exports.checkWhetherLocalDebugM365TenantMatches = exports.parseUserName = exports.parseTeamsAppTenantId = exports.ensurePermissionRequest = exports.setActivatedResourcePluginsV2 = exports.extractSolutionInputs = exports.combineRecords = exports.getBotTroubleShootMessage = exports.isBotProject = exports.isAzureProject = exports.getAzureSolutionSettings = exports.getSelectedPlugins = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const tools_1 = require("../../../../common/tools");
const constants_1 = require("../constants");
const question_1 = require("../question");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const util_1 = require("../utils/util");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const backupFiles_1 = require("../utils/backupFiles");
const telemetry_1 = require("../../../../common/telemetry");
function getSelectedPlugins(projectSettings) {
    return ResourcePluginContainer_1.getActivatedV2ResourcePlugins(projectSettings);
}
exports.getSelectedPlugins = getSelectedPlugins;
function getAzureSolutionSettings(ctx) {
    return ctx.projectSetting.solutionSettings;
}
exports.getAzureSolutionSettings = getAzureSolutionSettings;
function isAzureProject(azureSettings) {
    return azureSettings !== undefined && question_1.HostTypeOptionAzure.id === azureSettings.hostType;
}
exports.isAzureProject = isAzureProject;
function isBotProject(azureSettings) {
    var _a, _b;
    return (azureSettings !== undefined &&
        (((_a = azureSettings.capabilities) === null || _a === void 0 ? void 0 : _a.includes(question_1.BotOptionItem.id)) ||
            ((_b = azureSettings.capabilities) === null || _b === void 0 ? void 0 : _b.includes(question_1.MessageExtensionItem.id))));
}
exports.isBotProject = isBotProject;
function getBotTroubleShootMessage(isBot) {
    const botTroubleShootLink = "https://aka.ms/teamsfx-bot-help#how-can-i-troubleshoot-issues-when-teams-bot-isnt-responding-on-azure";
    const botTroubleShootDesc = localizeUtils_1.getLocalizedString("core.deploy.botTroubleShoot");
    const botTroubleShootLearnMore = localizeUtils_1.getLocalizedString("core.deploy.botTroubleShoot.learnMore");
    const botTroubleShootMsg = `${botTroubleShootDesc} ${botTroubleShootLearnMore}: ${botTroubleShootLink}.`;
    return {
        troubleShootLink: botTroubleShootLink,
        textForLogging: isBot ? botTroubleShootMsg : "",
        textForMsgBox: botTroubleShootDesc,
        textForActionButton: botTroubleShootLearnMore,
    };
}
exports.getBotTroubleShootMessage = getBotTroubleShootMessage;
function combineRecords(records) {
    const ret = {};
    for (const record of records) {
        ret[record.name] = record.result;
    }
    return ret;
}
exports.combineRecords = combineRecords;
function extractSolutionInputs(record) {
    return {
        resourceNameSuffix: record["resourceNameSuffix"],
        resourceGroupName: record["resourceGroupName"],
        location: record["location"],
        teamsAppTenantId: record["teamsAppTenantId"],
        remoteTeamsAppId: undefined,
        subscriptionId: record["subscriptionId"],
        provisionSucceeded: record[constants_1.SOLUTION_PROVISION_SUCCEEDED],
        tenantId: record["tenantId"],
    };
}
exports.extractSolutionInputs = extractSolutionInputs;
function setActivatedResourcePluginsV2(projectSettings) {
    const activatedPluginNames = ResourcePluginContainer_1.getAllV2ResourcePlugins()
        .filter((p) => p.activate && p.activate(projectSettings) === true)
        .map((p) => p.name);
    projectSettings.solutionSettings.activeResourcePlugins = activatedPluginNames;
}
exports.setActivatedResourcePluginsV2 = setActivatedResourcePluginsV2;
async function ensurePermissionRequest(solutionSettings, permissionRequestProvider) {
    if (!isAzureProject(solutionSettings)) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.CannotUpdatePermissionForSPFx, "Cannot update permission for SPFx project"));
    }
    if (!tools_1.isAadManifestEnabled()) {
        const result = await permissionRequestProvider.checkPermissionRequest();
        if (result && result.isErr()) {
            return result.map(teamsfx_api_1.err);
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.ensurePermissionRequest = ensurePermissionRequest;
function parseTeamsAppTenantId(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.NoAppStudioToken, "Graph token json is undefined"));
    }
    const teamsAppTenantId = appStudioToken["tid"];
    if (teamsAppTenantId === undefined ||
        !(typeof teamsAppTenantId === "string") ||
        teamsAppTenantId.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
    }
    return teamsfx_api_1.ok(teamsAppTenantId);
}
exports.parseTeamsAppTenantId = parseTeamsAppTenantId;
function parseUserName(appStudioToken) {
    if (appStudioToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", constants_1.SolutionError.NoAppStudioToken, "Graph token json is undefined"));
    }
    const userName = appStudioToken["upn"];
    if (userName === undefined || !(typeof userName === "string") || userName.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", constants_1.SolutionError.NoUserName, "Cannot find user name from App Studio token."));
    }
    return teamsfx_api_1.ok(userName);
}
exports.parseUserName = parseUserName;
async function checkWhetherLocalDebugM365TenantMatches(envInfo, telemetryReporter, localDebugTenantId, m365TokenProvider, projectPath, isLegacyEnv) {
    if (localDebugTenantId) {
        const appStudioTokenJsonRes = await (m365TokenProvider === null || m365TokenProvider === void 0 ? void 0 : m365TokenProvider.getJsonObject({
            scopes: tools_1.AppStudioScopes,
        }));
        const appStudioTokenJson = (appStudioTokenJsonRes === null || appStudioTokenJsonRes === void 0 ? void 0 : appStudioTokenJsonRes.isOk())
            ? appStudioTokenJsonRes.value
            : undefined;
        const maybeM365TenantId = parseTeamsAppTenantId(appStudioTokenJson);
        if (maybeM365TenantId.isErr()) {
            return maybeM365TenantId;
        }
        const maybeM365UserAccount = parseUserName(appStudioTokenJson);
        if (maybeM365UserAccount.isErr()) {
            return maybeM365UserAccount;
        }
        if (maybeM365TenantId.value !== localDebugTenantId) {
            if (projectPath !== undefined &&
                (await fs_extra_1.default.pathExists(`${projectPath}/bot/.notification.localstore.json`))) {
                const errorMessage = localizeUtils_1.getLocalizedString("core.localDebug.tenantConfirmNoticeWhenAllowSwitchAccount", localDebugTenantId, maybeM365UserAccount.value, "bot/.notification.localstore.json");
                return teamsfx_api_1.err(new teamsfx_api_1.UserError("Solution", constants_1.SolutionError.CannotLocalDebugInDifferentTenant, errorMessage));
            }
            else if (envInfo) {
                telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckLocalDebugTenant, {
                    [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: "true",
                    [constants_1.SolutionTelemetryProperty.M365TenantId]: maybeM365TenantId.value,
                    [constants_1.SolutionTelemetryProperty.PreviousM365TenantId]: localDebugTenantId,
                });
                if (!isLegacyEnv) {
                    const keys = Object.keys(envInfo.state);
                    for (const key of keys) {
                        if (key !== "solution") {
                            delete envInfo.state[key];
                        }
                    }
                }
                else {
                    const keys = envInfo.state.keys();
                    for (const key of keys) {
                        envInfo.state.delete(key);
                    }
                }
                if (projectPath !== undefined) {
                    const backupFilesRes = await backupFiles_1.backupFiles(envInfo.envName, projectPath);
                    if (backupFilesRes.isErr()) {
                        return teamsfx_api_1.err(backupFilesRes.error);
                    }
                }
            }
        }
        else {
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckLocalDebugTenant, {
                [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: "false",
                [constants_1.SolutionTelemetryProperty.M365TenantId]: maybeM365TenantId.value,
                [constants_1.SolutionTelemetryProperty.PreviousM365TenantId]: localDebugTenantId,
            });
        }
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.checkWhetherLocalDebugM365TenantMatches = checkWhetherLocalDebugM365TenantMatches;
// Loads teams app tenant id into local settings.
function loadTeamsAppTenantIdForLocal(localSettings, appStudioToken, envInfo) {
    return parseTeamsAppTenantId(appStudioToken).andThen((teamsAppTenantId) => {
        envInfo.state.solution.teamsAppTenantId = teamsAppTenantId;
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    });
}
exports.loadTeamsAppTenantIdForLocal = loadTeamsAppTenantIdForLocal;
function fillInSolutionSettings(projectSettings, answers) {
    const solutionSettings = projectSettings.solutionSettings || {};
    let capabilities = answers[question_1.AzureSolutionQuestionNames.Capabilities] || [];
    if (tools_1.isAadManifestEnabled()) {
        if (capabilities.includes(question_1.TabOptionItem.id)) {
            capabilities.push(question_1.TabSsoItem.id);
        }
        else if (capabilities.includes(question_1.TabNonSsoItem.id)) {
            const index = capabilities.indexOf(question_1.TabNonSsoItem.id);
            capabilities.splice(index, 1);
            capabilities.push(question_1.TabOptionItem.id);
        }
    }
    if (!capabilities || capabilities.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.InternelError, "capabilities is empty"));
    }
    let hostType = answers[question_1.AzureSolutionQuestionNames.HostType];
    if (capabilities.includes(question_1.NotificationOptionItem.id) ||
        capabilities.includes(question_1.CommandAndResponseOptionItem.id) ||
        capabilities.includes(question_1.WorkflowOptionItem.id)) {
        // find and replace "NotificationOptionItem" and "CommandAndResponseOptionItem" to "BotOptionItem", so it does not impact capabilities in projectSettings.json
        const scenarios = [];
        const notificationIndex = capabilities.indexOf(question_1.NotificationOptionItem.id);
        if (notificationIndex !== -1) {
            capabilities[notificationIndex] = question_1.BotOptionItem.id;
            scenarios.push(question_1.BotScenario.NotificationBot);
        }
        const commandAndResponseIndex = capabilities.indexOf(question_1.CommandAndResponseOptionItem.id);
        if (commandAndResponseIndex !== -1) {
            capabilities[commandAndResponseIndex] = question_1.BotOptionItem.id;
            scenarios.push(question_1.BotScenario.CommandAndResponseBot);
        }
        const workflowIndex = capabilities.indexOf(question_1.WorkflowOptionItem.id);
        if (workflowIndex !== -1) {
            capabilities[workflowIndex] = question_1.BotOptionItem.id;
            scenarios.push(question_1.BotScenario.WorkflowBot);
        }
        answers[question_1.AzureSolutionQuestionNames.Scenarios] = scenarios;
        // dedup
        capabilities = [...new Set(capabilities)];
        hostType = question_1.HostTypeOptionAzure.id;
    }
    else if (capabilities.includes(question_1.BotOptionItem.id) ||
        capabilities.includes(question_1.MessageExtensionItem.id) ||
        capabilities.includes(question_1.TabOptionItem.id)) {
        hostType = question_1.HostTypeOptionAzure.id;
    }
    else if (capabilities.includes(question_1.TabSPFxItem.id)) {
        // set capabilities to TabOptionItem in case of TabSPFx item, so donot impact capabilities.includes() check overall
        capabilities = [question_1.TabOptionItem.id];
        hostType = question_1.HostTypeOptionSPFx.id;
    }
    else if (capabilities.includes(question_1.M365SsoLaunchPageOptionItem.id)) {
        capabilities = [question_1.TabOptionItem.id];
        if (tools_1.isAadManifestEnabled()) {
            capabilities.push(question_1.TabSsoItem.id);
        }
        hostType = question_1.HostTypeOptionAzure.id;
    }
    else if (capabilities.includes(question_1.M365SearchAppOptionItem.id)) {
        capabilities = [question_1.MessageExtensionItem.id];
        const scenarios = [question_1.M365SearchAppOptionItem.id];
        answers[question_1.AzureSolutionQuestionNames.Scenarios] = scenarios;
        hostType = question_1.HostTypeOptionAzure.id;
    }
    if (!hostType) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.InternelError, "hostType is undefined"));
    }
    solutionSettings.hostType = hostType;
    let azureResources;
    if (hostType === question_1.HostTypeOptionAzure.id && capabilities.includes(question_1.TabOptionItem.id)) {
        azureResources = answers[question_1.AzureSolutionQuestionNames.AzureResources];
        if (azureResources) {
            if ((azureResources.includes(question_1.AzureResourceSQL.id) ||
                azureResources.includes(question_1.AzureResourceApim.id)) &&
                !azureResources.includes(question_1.AzureResourceFunction.id)) {
                azureResources.push(question_1.AzureResourceFunction.id);
            }
        }
        else
            azureResources = [];
    }
    solutionSettings.azureResources = azureResources || [];
    solutionSettings.capabilities = capabilities || [];
    // fill in activeResourcePlugins
    setActivatedResourcePluginsV2(projectSettings);
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.fillInSolutionSettings = fillInSolutionSettings;
function checkWetherProvisionSucceeded(config) {
    return config[constants_1.GLOBAL_CONFIG] && config[constants_1.GLOBAL_CONFIG][constants_1.SOLUTION_PROVISION_SUCCEEDED];
}
exports.checkWetherProvisionSucceeded = checkWetherProvisionSucceeded;
function getPluginAndContextArray(ctx, selectedPlugins) {
    return selectedPlugins.map((plugin) => [plugin, util_1.getPluginContext(ctx, plugin.name)]);
}
exports.getPluginAndContextArray = getPluginAndContextArray;
//# sourceMappingURL=utils.js.map