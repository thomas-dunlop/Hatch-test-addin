"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../../../common/tools");
const executor_1 = require("./executor");
const utils_1 = require("./utils");
const constants_1 = require("../constants");
const lodash_1 = tslib_1.__importStar(require("lodash"));
const constants_2 = require("../../../../common/constants");
const adaptor_1 = require("./adaptor");
const arm_1 = require("../arm");
const typedi_1 = require("typedi");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const permissionRequest_1 = require("../../../../core/permissionRequest");
const constants_3 = require("../../../resource/appstudio/constants");
const constants_4 = require("../v3/constants");
const ResourceGroupHelper_1 = require("../utils/ResourceGroupHelper");
const solutionGlobalVars_1 = require("../v3/solutionGlobalVars");
const projectSettingsHelper_1 = require("../../../../common/projectSettingsHelper");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const util_1 = require("../utils/util");
const utils_2 = require("../../../../component/utils");
const provisionUtils_1 = require("../../../../component/provisionUtils");
async function provisionResource(ctx, inputs, envInfo, tokenProvider) {
    const env = !inputs.env ? "" : tools_1.getHashedEnv(inputs.env);
    ctx.telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ProvisionStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
        [constants_1.SolutionTelemetryProperty.SubscriptionId]: provisionUtils_1.getSubscriptionId(envInfo.state),
        [constants_1.SolutionTelemetryProperty.Env]: env,
    });
    const result = await provisionResourceImpl(ctx, inputs, envInfo, tokenProvider);
    if (result.isOk()) {
        ctx.telemetryReporter.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.Provision, {
            [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
            [constants_1.SolutionTelemetryProperty.SubscriptionId]: provisionUtils_1.getSubscriptionId(envInfo.state),
            [constants_1.SolutionTelemetryProperty.Env]: env,
            [constants_1.SolutionTelemetryProperty.Success]: "yes",
        });
    }
    else {
        util_1.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.Provision, result.error, ctx.telemetryReporter, {
            [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
            [constants_1.SolutionTelemetryProperty.SubscriptionId]: provisionUtils_1.getSubscriptionId(envInfo.state),
            [constants_1.SolutionTelemetryProperty.Env]: env,
        });
    }
    return result;
}
exports.provisionResource = provisionResource;
async function provisionResourceImpl(ctx, inputs, envInfo, tokenProvider) {
    var _a, _b, _c, _d;
    const azureSolutionSettings = utils_1.getAzureSolutionSettings(ctx);
    // check projectPath
    if (inputs.projectPath === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.InternelError, "projectPath is undefined"));
    }
    // Just to trigger M365 login before the concurrent execution of localDebug.
    // Because concurrent execution of localDebug may getAccessToken() concurrently, which
    // causes 2 M365 logins before the token caching in common lib takes effect.
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const hasBotServiceCreatedBefore = util_1.hasBotServiceCreated(envInfo);
    const inputsNew = inputs;
    const projectPath = inputs.projectPath;
    // check M365 tenant
    if (!envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio])
        envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio] = {};
    const teamsAppResource = envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio];
    if (!envInfo.state.solution)
        envInfo.state.solution = {};
    const solutionConfig = envInfo.state.solution;
    const tenantIdInConfig = teamsAppResource.tenantId;
    const tenantIdInTokenRes = await provisionUtils_1.provisionUtils.getM365TenantId(tokenProvider.m365TokenProvider);
    if (tenantIdInTokenRes.isErr()) {
        return teamsfx_api_1.err(tenantIdInTokenRes.error);
    }
    const tenantIdInToken = tenantIdInTokenRes.value.tenantIdInToken;
    let hasSwitchedM365Tenant = false;
    const isSwitchingM365Tenant = !!tenantIdInConfig && !!tenantIdInToken && tenantIdInToken !== tenantIdInConfig;
    if (isSwitchingM365Tenant) {
        hasSwitchedM365Tenant = true;
        utils_2.resetEnvInfoWhenSwitchM365(envInfo);
    }
    envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio] =
        envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio] || {};
    envInfo.state[constants_4.BuiltInFeaturePluginNames.appStudio].tenantId = tenantIdInToken;
    envInfo.state.solution.teamsAppTenantId = tenantIdInToken;
    solutionConfig.teamsAppTenantId = tenantIdInToken;
    if (utils_1.isAzureProject(azureSolutionSettings) && projectSettingsHelper_1.hasAzureResource(ctx.projectSetting, true)) {
        if (projectSettingsHelper_1.hasAAD(ctx.projectSetting)) {
            if (ctx.permissionRequestProvider === undefined) {
                ctx.permissionRequestProvider = new permissionRequest_1.PermissionRequestFileProvider(inputs.projectPath);
            }
            const result = await utils_1.ensurePermissionRequest(azureSolutionSettings, ctx.permissionRequestProvider);
            if (result.isErr()) {
                return teamsfx_api_1.err(result.error);
            }
        }
        const subscriptionIdInState = envInfo.state.solution.subscriptionId;
        // ask common question and fill in solution config
        const solutionConfigRes = await provisionUtils_1.provisionUtils.fillInAzureConfigs(ctx, inputsNew, envInfo, tokenProvider);
        if (solutionConfigRes.isErr()) {
            return teamsfx_api_1.err(solutionConfigRes.error);
        }
        const consentResult = await provisionUtils_1.provisionUtils.askForProvisionConsent(ctx, tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, tenantIdInTokenRes.value.tenantUserName, true, tenantIdInConfig, subscriptionIdInState);
        if (consentResult.isErr()) {
            return teamsfx_api_1.err(consentResult.error);
        }
        // create resource group if needed
        if (solutionConfig.needCreateResourceGroup) {
            const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(solutionConfig.resourceGroupName, tokenProvider.azureAccountProvider, solutionConfig.subscriptionId, solutionConfig.location);
            if (createRgRes.isErr()) {
                return teamsfx_api_1.err(createRgRes.error);
            }
        }
        if (solutionConfigRes.value.hasSwitchedSubscription || hasSwitchedM365Tenant) {
            const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, hasBotServiceCreatedBefore);
            if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
            }
        }
    }
    else if (hasSwitchedM365Tenant) {
        const consentResult = await provisionUtils_1.provisionUtils.askForProvisionConsent(ctx, tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, false, tenantIdInTokenRes.value.tenantUserName, false, tenantIdInConfig);
        if (consentResult.isErr()) {
            return teamsfx_api_1.err(consentResult.error);
        }
        const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, false, false);
        if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
            return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
        }
    }
    const plugins = utils_1.getSelectedPlugins(ctx.projectSetting);
    if (projectSettingsHelper_1.isExistingTabApp(ctx.projectSetting)) {
        // for existing tab app, enable app studio plugin when solution settings is empty.
        const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
        if (!plugins.find((p) => p.name === appStudioPlugin.name)) {
            plugins.push(appStudioPlugin);
        }
    }
    envInfo.state[constants_1.GLOBAL_CONFIG][constants_1.SOLUTION_PROVISION_SUCCEEDED] = false;
    const solutionInputs = utils_1.extractSolutionInputs(envInfo.state[constants_1.GLOBAL_CONFIG]);
    const provisionThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.provisionResource))
        .map((plugin) => {
        return {
            pluginName: `${plugin.name}`,
            taskName: "provisionResource",
            thunk: () => {
                if (!envInfo.state[plugin.name]) {
                    envInfo.state[plugin.name] = {};
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return plugin.provisionResource(ctx, Object.assign(Object.assign(Object.assign({}, inputs), solutionInputs), { projectPath: projectPath }), envInfo, tokenProvider);
            },
        };
    });
    // call provisionResources
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.provision.StartNotice", constants_2.PluginDisplayName.Solution));
    const provisionResult = await executor_1.executeConcurrently(provisionThunks, ctx.logProvider);
    if (provisionResult.kind === "failure" || provisionResult.kind === "partialSuccess") {
        return teamsfx_api_1.err(provisionResult.error);
    }
    (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString("core.provision.ProvisionFinishNotice", constants_2.PluginDisplayName.Solution));
    const teamsAppId = envInfo.state[constants_1.PluginNames.APPST][constants_3.Constants.TEAMS_APP_ID];
    solutionGlobalVars_1.solutionGlobalVars.TeamsAppId = teamsAppId;
    solutionInputs.remoteTeamsAppId = teamsAppId;
    // call deployArmTemplates
    if (utils_1.isAzureProject(azureSolutionSettings) &&
        !inputs.isForUT &&
        projectSettingsHelper_1.hasAzureResource(ctx.projectSetting, true)) {
        const contextAdaptor = new adaptor_1.ProvisionContextAdapter([ctx, inputs, envInfo, tokenProvider]);
        const armDeploymentResult = await arm_1.deployArmTemplates(contextAdaptor);
        if (armDeploymentResult.isErr()) {
            return teamsfx_api_1.err(armDeploymentResult.error);
        }
        // contextAdaptor deep-copies original JSON into a map. We need to convert it back.
        const update = contextAdaptor.getEnvStateJson();
        lodash_1.default.assign(envInfo.state, update);
    }
    // call aad.setApplicationInContext
    const aadPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
    if (plugins.some((plugin) => plugin.name === aadPlugin.name) && aadPlugin.executeUserTask) {
        const result = await aadPlugin.executeUserTask(ctx, inputs, {
            namespace: `${constants_1.PluginNames.SOLUTION}/${constants_1.PluginNames.AAD}`,
            method: "setApplicationInContext",
            params: { isLocal: false },
        }, {}, envInfo, tokenProvider);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
    }
    const configureResourceThunks = plugins
        .filter((plugin) => !lodash_1.isUndefined(plugin.configureResource))
        .map((plugin) => {
        if (!envInfo.state[plugin.name]) {
            envInfo.state[plugin.name] = {};
        }
        return {
            pluginName: `${plugin.name}`,
            taskName: "configureResource",
            thunk: () => 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            plugin.configureResource(ctx, Object.assign(Object.assign(Object.assign({}, inputs), solutionInputs), { projectPath: projectPath }), envInfo, tokenProvider),
        };
    });
    //call configResource
    const configureResourceResult = await executor_1.executeConcurrently(configureResourceThunks, ctx.logProvider);
    (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(localizeUtils_1.getLocalizedString("core.provision.configurationFinishNotice", constants_2.PluginDisplayName.Solution));
    if (configureResourceResult.kind === "failure" ||
        configureResourceResult.kind === "partialSuccess") {
        const msg = localizeUtils_1.getLocalizedString("core.provision.failNotice", ctx.projectSetting.appName);
        ctx.logProvider.error(msg);
        solutionInputs[constants_1.SOLUTION_PROVISION_SUCCEEDED] = false;
        return teamsfx_api_1.err(configureResourceResult.error);
    }
    else {
        if (envInfo.state[constants_1.GLOBAL_CONFIG] && envInfo.state[constants_1.GLOBAL_CONFIG][constants_1.ARM_TEMPLATE_OUTPUT]) {
            delete envInfo.state[constants_1.GLOBAL_CONFIG][constants_1.ARM_TEMPLATE_OUTPUT];
        }
        const msg = localizeUtils_1.getLocalizedString("core.provision.successNotice", ctx.projectSetting.appName);
        (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.info(msg);
        if (!projectSettingsHelper_1.isExistingTabApp(ctx.projectSetting)) {
            const url = tools_1.getResourceGroupInPortal(solutionInputs.subscriptionId, solutionInputs.tenantId, solutionInputs.resourceGroupName);
            if (url) {
                const title = "View Provisioned Resources";
                if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                    ctx.userInteraction.showMessage("info", [
                        {
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                            content: msg + " View provisioned resources in Azure Portal: ",
                        },
                        { color: teamsfx_api_1.Colors.BRIGHT_MAGENTA, content: url },
                    ], false);
                }
                else {
                    ctx.userInteraction.showMessage("info", msg, false, title).then((result) => {
                        const userSelected = result.isOk() ? result.value : undefined;
                        if (userSelected === title) {
                            ctx.userInteraction.openUrl(url);
                        }
                    });
                }
            }
            else {
                ctx.userInteraction.showMessage("info", msg, false);
            }
        }
        else {
            ctx.userInteraction.showMessage("info", msg, false);
        }
        envInfo.state[constants_1.GLOBAL_CONFIG][constants_1.SOLUTION_PROVISION_SUCCEEDED] = true;
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
//# sourceMappingURL=provision.js.map