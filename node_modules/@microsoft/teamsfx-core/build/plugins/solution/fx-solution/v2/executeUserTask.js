"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAndParseLanguage = exports.createAuthFiles = exports.addSso = exports.extractParamForRegisterTeamsAppAndAad = exports.addFeature = exports.addResource = exports.showUpdateArmTemplateNotice = exports.addCapability = exports.canAddResource = exports.canAddCapability = exports.executeUserTask = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const common_1 = require("../../../../common");
const constants_1 = require("../../../../common/constants");
const projectSettingsHelper_1 = require("../../../../common/projectSettingsHelper");
const error_1 = require("../../../../core/error");
const question_1 = require("../../../../core/question");
const constants_2 = require("../constants");
const scaffolding_1 = require("../debug/scaffolding");
const question_2 = require("../question");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const util_1 = require("../utils/util");
const constants_3 = require("../v3/constants");
const constants_4 = require("./constants");
const generateResourceTemplate_1 = require("./generateResourceTemplate");
const scaffolding_2 = require("./scaffolding");
const utils_1 = require("./utils");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const folder_1 = require("../../../../folder");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const templatesUtils_1 = require("../../../../common/template-utils/templatesUtils");
const constants_5 = require("../../../../component/constants");
async function executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider) {
    const namespace = func.namespace;
    const method = func.method;
    const array = namespace.split("/");
    if (method === "addCapability") {
        return addCapability(ctx, inputs, localSettings);
    }
    if (method === "addResource") {
        return addResource(ctx, inputs, localSettings, func, envInfo, tokenProvider);
    }
    if (method === "addFeature") {
        return addFeature(ctx, inputs, localSettings, func, envInfo, tokenProvider);
    }
    if (method === "addSso") {
        return addSso(ctx, inputs, localSettings);
    }
    if (namespace.includes("solution")) {
        if (method === "registerTeamsAppAndAad") {
            // not implemented for now
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.FeatureNotSupported, "Not implemented"));
        }
        else if (method === "VSpublish") {
            // VSpublish means VS calling cli to do publish. It is different than normal cli work flow
            // It's teamsfx init followed by teamsfx  publish without running provision.
            // Using executeUserTask here could bypass the fx project check.
            if (inputs.platform !== "vs") {
                return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.UnsupportedPlatform, localizeUtils_1.getDefaultString("error.UnsupportedPlatformVS"), localizeUtils_1.getLocalizedString("error.UnsupportedPlatformVS")));
            }
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.publishApplication) {
                return appStudioPlugin.publishApplication(ctx, inputs, envInfo, tokenProvider.m365TokenProvider);
            }
        }
        else if (method === "validateManifest") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return await appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (method === "buildPackage") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return await appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (method === "buildAadManifest") {
            const aadPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
            if (aadPlugin.executeUserTask) {
                return await aadPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (method === "validateManifest") {
            const appStudioPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AppStudioPlugin);
            if (appStudioPlugin.executeUserTask) {
                return appStudioPlugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
        else if (array.length == 2) {
            const pluginName = array[1];
            const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
            const plugin = pluginMap.get(pluginName);
            if (plugin && plugin.executeUserTask) {
                return plugin.executeUserTask(ctx, inputs, func, localSettings, envInfo, tokenProvider);
            }
        }
    }
    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "executeUserTaskRouteFailed", localizeUtils_1.getDefaultString("error.appstudio.executeUserTaskRouteFailed", JSON.stringify(func)), localizeUtils_1.getLocalizedString("error.appstudio.executeUserTaskRouteFailed", JSON.stringify(func))));
}
exports.executeUserTask = executeUserTask;
function canAddCapability(settings, telemetryReporter) {
    if (settings && !(settings.hostType === question_2.HostTypeOptionAzure.id) && !common_1.isSPFxMultiTabEnabled()) {
        const e = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.AddCapabilityNotSupport, localizeUtils_1.getDefaultString("core.addCapability.onlySupportAzure"), localizeUtils_1.getLocalizedString("core.addCapability.onlySupportAzure"));
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddCapability, e, telemetryReporter));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.canAddCapability = canAddCapability;
function canAddResource(projectSetting, telemetryReporter) {
    const isVS = projectSettingsHelper_1.isVSProject(projectSetting);
    if (isVS) {
        const e = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport, localizeUtils_1.getDefaultString("core.addResource.notSupportForVSProject"), localizeUtils_1.getLocalizedString("core.addResource.notSupportForVSProject"));
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, e, telemetryReporter));
    }
    if (projectSettingsHelper_1.isExistingTabApp(projectSetting)) {
        return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.addResource));
    }
    const solutionSettings = projectSetting.solutionSettings;
    if (!(solutionSettings.hostType === question_2.HostTypeOptionAzure.id)) {
        const e = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport, localizeUtils_1.getDefaultString("core.addResource.onlySupportAzure"), localizeUtils_1.getLocalizedString("core.addResource.onlySupportAzure"));
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, e, telemetryReporter));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.canAddResource = canAddResource;
async function addCapability(ctx, inputs, localSettings) {
    var _a, _b;
    ctx.telemetryReporter.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapabilityStart, {
        [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
    });
    // 0. set programming language if it is empty
    const programmingLanguageInputs = inputs[question_1.CoreQuestionNames.ProgrammingLanguage];
    if (!ctx.projectSetting.programmingLanguage && programmingLanguageInputs) {
        ctx.projectSetting.programmingLanguage = programmingLanguageInputs;
    }
    // 1. checking addable
    let solutionSettings = utils_1.getAzureSolutionSettings(ctx);
    let isMiniApp = false;
    if (!solutionSettings) {
        // pure existing app
        solutionSettings = {
            name: constants_4.TeamsAppSolutionNameV2,
            version: "1.0.0",
            hostType: "Azure",
            capabilities: [],
            azureResources: [],
            activeResourcePlugins: [],
        };
        ctx.projectSetting.solutionSettings = solutionSettings;
        if (!common_1.isAadManifestEnabled()) {
            //aad need this file
            await fs_extra_1.default.writeJSON(`${inputs.projectPath}/permissions.json`, constants_2.DEFAULT_PERMISSION_REQUEST, {
                spaces: 4,
            });
        }
        isMiniApp = true;
    }
    const originalSettings = lodash_1.cloneDeep(solutionSettings);
    const inputsNew = Object.assign(Object.assign({}, inputs), { projectPath: inputs.projectPath, existingResources: originalSettings.activeResourcePlugins, existingCapabilities: originalSettings.capabilities });
    const canProceed = canAddCapability(solutionSettings, ctx.telemetryReporter);
    if (canProceed.isErr()) {
        return teamsfx_api_1.err(canProceed.error);
    }
    // 2. check answer
    let capabilitiesAnswer = inputs[question_2.AzureSolutionQuestionNames.Capabilities];
    if (!capabilitiesAnswer || capabilitiesAnswer.length === 0) {
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapability, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
            [constants_2.SolutionTelemetryProperty.Capabilities]: [].join(";"),
        });
        return teamsfx_api_1.ok({});
    }
    const validateRes = question_1.validateCapabilities(capabilitiesAnswer);
    if (validateRes) {
        return teamsfx_api_1.err(error_1.InvalidInputError(validateRes));
    }
    if (!isMiniApp && capabilitiesAnswer.includes(question_2.TabSPFxNewUIItem.id) && !common_1.isSPFxMultiTabEnabled()) {
        return teamsfx_api_1.err(error_1.InvalidInputError(localizeUtils_1.getLocalizedString("core.capability.validation.spfx")));
    }
    // normalize capability answer
    const scenarios = [];
    const notificationIndex = capabilitiesAnswer.indexOf(question_2.NotificationOptionItem.id);
    if (notificationIndex !== -1) {
        capabilitiesAnswer[notificationIndex] = question_2.BotOptionItem.id;
        scenarios.push(question_2.BotScenario.NotificationBot);
    }
    const commandAndResponseIndex = capabilitiesAnswer.indexOf(question_2.CommandAndResponseOptionItem.id);
    if (commandAndResponseIndex !== -1) {
        capabilitiesAnswer[commandAndResponseIndex] = question_2.BotOptionItem.id;
        scenarios.push(question_2.BotScenario.CommandAndResponseBot);
    }
    const workflowIndex = capabilitiesAnswer.indexOf(question_2.WorkflowOptionItem.id);
    if (workflowIndex !== -1) {
        capabilitiesAnswer[workflowIndex] = question_2.BotOptionItem.id;
        scenarios.push(question_2.BotScenario.WorkflowBot);
    }
    inputsNew[question_2.AzureSolutionQuestionNames.Scenarios] = scenarios;
    capabilitiesAnswer = [...new Set(capabilitiesAnswer)];
    // 3. check capability limit
    const alreadyHasTab = solutionSettings.capabilities.includes(question_2.TabOptionItem.id);
    const alreadyHasBot = solutionSettings.capabilities.includes(question_2.BotOptionItem.id);
    const alreadyHasME = solutionSettings.capabilities.includes(question_2.MessageExtensionItem.id);
    const alreadyHasTabSso = common_1.isAadManifestEnabled() && solutionSettings.capabilities.includes(question_2.TabSsoItem.id);
    const toAddTab = capabilitiesAnswer.includes(question_2.TabOptionItem.id);
    const toAddBot = capabilitiesAnswer.includes(question_2.BotOptionItem.id);
    const toAddME = capabilitiesAnswer.includes(question_2.MessageExtensionItem.id);
    const toAddTabNonSso = common_1.isAadManifestEnabled() && capabilitiesAnswer.includes(question_2.TabNonSsoItem.id);
    const toAddSpfx = capabilitiesAnswer.includes(question_2.TabSPFxNewUIItem.id);
    if (common_1.isAadManifestEnabled()) {
        if (alreadyHasTabSso && toAddTabNonSso) {
            const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.InvalidInput, localizeUtils_1.getLocalizedString("core.addSsoFiles.canNotAddNonSsoTabWhenSsoEnabled"));
            return teamsfx_api_1.err(e);
        }
        if (alreadyHasTab && !alreadyHasTabSso && toAddTab) {
            const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.InvalidInput, localizeUtils_1.getLocalizedString("core.addSsoFiles.canNotAddTabWhenSsoNotEnabled"));
            return teamsfx_api_1.err(e);
        }
    }
    const appStudioPlugin = typedi_1.Container.get(constants_5.ComponentNames.AppManifest);
    const inputsWithProjectPath = inputs;
    const tabExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "staticTab");
    if (tabExceedRes.isErr()) {
        return teamsfx_api_1.err(tabExceedRes.error);
    }
    const isTabAddable = !tabExceedRes.value;
    const isTabSPFxAddable = !tabExceedRes.value;
    const botExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "Bot");
    if (botExceedRes.isErr()) {
        return teamsfx_api_1.err(botExceedRes.error);
    }
    const isBotAddable = !botExceedRes.value;
    const meExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "MessageExtension");
    if (meExceedRes.isErr()) {
        return teamsfx_api_1.err(meExceedRes.error);
    }
    const isMEAddable = !meExceedRes.value;
    if (((toAddTab || toAddTabNonSso) && !isTabAddable) ||
        (toAddBot && !isBotAddable) ||
        (toAddME && !isMEAddable) ||
        (toAddSpfx && !isTabSPFxAddable)) {
        const error = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.FailedToAddCapability, localizeUtils_1.getDefaultString("core.addCapability.exceedMaxLimit"), localizeUtils_1.getLocalizedString("core.addCapability.exceedMaxLimit"));
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddCapability, error, ctx.telemetryReporter));
    }
    const capabilitiesToAddManifest = [];
    const pluginNamesToScaffold = new Set();
    const pluginNamesToArm = new Set();
    const newCapabilitySet = new Set();
    solutionSettings.capabilities.forEach((c) => newCapabilitySet.add(c));
    const vsProject = projectSettingsHelper_1.isVSProject(ctx.projectSetting);
    // check SPFx
    if (toAddSpfx) {
        pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.SpfxPlugin);
        newCapabilitySet.add(question_2.TabSPFxNewUIItem.id);
        solutionSettings.hostType = question_2.HostTypeOptionSPFx.id;
    }
    else {
        if (!originalSettings.activeResourcePlugins.includes(constants_3.BuiltInFeaturePluginNames.identity)) {
            pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.IdentityPlugin);
        }
        if (!common_1.isAadManifestEnabled() &&
            !originalSettings.activeResourcePlugins.includes(constants_3.BuiltInFeaturePluginNames.aad)) {
            pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
        }
        // 4. check Tab
        if (toAddTab || toAddTabNonSso) {
            if (vsProject) {
                pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                if (!alreadyHasTab) {
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                }
            }
            else {
                if (!alreadyHasTab) {
                    pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                }
            }
            capabilitiesToAddManifest.push({ name: "staticTab" });
            newCapabilitySet.add(question_2.TabOptionItem.id);
            if (toAddTab && !alreadyHasTabSso) {
                newCapabilitySet.add(question_2.TabSsoItem.id);
                pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
                pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin);
                // Add webapplicationInfo in teams app manifest
                const appStudioPlugin = typedi_1.Container.get(constants_5.ComponentNames.AppManifest);
                await appStudioPlugin.addCapability(inputs, [
                    { name: "WebApplicationInfo" },
                ]);
            }
        }
        // 5. check Bot
        if (toAddBot) {
            if (vsProject) {
                pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                if (!alreadyHasBot && !alreadyHasME) {
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                }
            }
            else {
                if (!alreadyHasBot && !alreadyHasME) {
                    pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                }
            }
            capabilitiesToAddManifest.push({ name: "Bot" });
            newCapabilitySet.add(question_2.BotOptionItem.id);
        }
        // 6. check MessageExtension
        if (toAddME) {
            if (vsProject) {
                pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
                if (!alreadyHasBot && !alreadyHasME) {
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                }
            }
            else {
                if (!alreadyHasBot && !alreadyHasME) {
                    pluginNamesToScaffold.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                    pluginNamesToArm.add(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
                }
            }
            capabilitiesToAddManifest.push({ name: "MessageExtension" });
            newCapabilitySet.add(question_2.MessageExtensionItem.id);
        }
    }
    // 7. update solution settings
    solutionSettings.capabilities = Array.from(newCapabilitySet);
    utils_1.setActivatedResourcePluginsV2(ctx.projectSetting);
    if (!toAddSpfx &&
        !common_1.isAadManifestEnabled() &&
        !solutionSettings.activeResourcePlugins.includes(constants_3.BuiltInFeaturePluginNames.aad)) {
        solutionSettings.activeResourcePlugins.push(constants_3.BuiltInFeaturePluginNames.aad);
    }
    // 8. scaffold and update arm
    const pluginsToScaffold = Array.from(pluginNamesToScaffold).map((name) => typedi_1.Container.get(name));
    const pluginsToArm = Array.from(pluginNamesToArm).map((name) => typedi_1.Container.get(name));
    if (pluginsToScaffold.length > 0) {
        const scaffoldRes = await scaffoldCodeAndResourceTemplate(ctx, inputsNew, localSettings, pluginsToScaffold, pluginsToArm);
        if (scaffoldRes.isErr()) {
            ctx.projectSetting.solutionSettings = originalSettings;
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddCapability, scaffoldRes.error, ctx.telemetryReporter));
        }
    }
    // 4. update manifest
    if (capabilitiesToAddManifest.length > 0) {
        await appStudioPlugin.addCapability(inputsNew, capabilitiesToAddManifest);
    }
    if (capabilitiesAnswer.length > 0) {
        const addNames = capabilitiesAnswer.map((c) => `'${c}'`).join(" and ");
        const single = capabilitiesAnswer.length === 1;
        const template = inputs.platform === teamsfx_api_1.Platform.CLI
            ? single
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilityNoticeForCli")
                : localizeUtils_1.getLocalizedString("core.addCapability.addCapabilitiesNoticeForCli")
            : single
                ? localizeUtils_1.getLocalizedString("core.addCapability.addCapabilityNotice")
                : localizeUtils_1.getLocalizedString("core.addCapability.addCapabilitiesNotice");
        const msg = util.format(template, addNames);
        ctx.userInteraction.showMessage("info", msg, false);
        (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddCapability, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
            [constants_2.SolutionTelemetryProperty.Capabilities]: capabilitiesAnswer.join(";"),
        });
    }
    return teamsfx_api_1.ok({
        solutionSettings: solutionSettings,
        solutionConfig: { provisionSucceeded: false },
    });
}
exports.addCapability = addCapability;
function showUpdateArmTemplateNotice(ui) {
    const msg = localizeUtils_1.getLocalizedString("core.updateArmTemplate.successNotice");
    ui === null || ui === void 0 ? void 0 : ui.showMessage("info", msg, false);
}
exports.showUpdateArmTemplateNotice = showUpdateArmTemplateNotice;
async function scaffoldCodeAndResourceTemplate(ctx, inputs, localSettings, pluginsToScaffold, pluginsToDoArm, concurrent = true) {
    const result = await scaffolding_2.scaffoldByPlugins(ctx, inputs, localSettings, pluginsToScaffold, concurrent);
    if (result.isErr()) {
        return result;
    }
    const scaffoldLocalDebugSettingsResult = await scaffolding_1.scaffoldLocalDebugSettings(ctx, inputs, localSettings);
    if (scaffoldLocalDebugSettingsResult.isErr()) {
        return scaffoldLocalDebugSettingsResult;
    }
    const pluginsToUpdateArm = pluginsToDoArm ? pluginsToDoArm : pluginsToScaffold;
    if (pluginsToUpdateArm.length > 0) {
        return generateResourceTemplate_1.generateResourceTemplateForPlugins(ctx, inputs, pluginsToUpdateArm);
    }
    return teamsfx_api_1.ok(undefined);
}
async function addResource(ctx, inputs, localSettings, func, envInfo, tokenProvider) {
    var _a, _b, _c, _d;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddResourceStart, {
        [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
    });
    // 1. checking addable
    const solutionSettings = utils_1.getAzureSolutionSettings(ctx);
    if (!solutionSettings) {
        return teamsfx_api_1.err(new error_1.OperationNotPermittedError("addResource"));
    }
    const originalSettings = lodash_1.cloneDeep(solutionSettings);
    const inputsNew = Object.assign(Object.assign({}, inputs), { projectPath: inputs.projectPath, existingResources: originalSettings.activeResourcePlugins });
    const canProceed = canAddResource(ctx.projectSetting, ctx.telemetryReporter);
    if (canProceed.isErr()) {
        return teamsfx_api_1.err(canProceed.error);
    }
    // 2. check answer
    const addResourcesAnswer = inputs[question_2.AzureSolutionQuestionNames.AddResources];
    if (!addResourcesAnswer || addResourcesAnswer.length === 0) {
        (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddResource, {
            [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
            [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
            [constants_2.SolutionTelemetryProperty.Resources]: [].join(";"),
        });
        return teamsfx_api_1.ok({});
    }
    const alreadyHaveFunction = solutionSettings.azureResources.includes(question_2.AzureResourceFunction.id);
    const alreadyHaveApim = solutionSettings.azureResources.includes(question_2.AzureResourceApim.id);
    const alreadyHaveKeyVault = solutionSettings.azureResources.includes(question_2.AzureResourceKeyVault.id);
    const addSQL = addResourcesAnswer.includes(question_2.AzureResourceSQL.id);
    const addApim = addResourcesAnswer.includes(question_2.AzureResourceApim.id);
    const addKeyVault = addResourcesAnswer.includes(question_2.AzureResourceKeyVault.id);
    const addFunc = addResourcesAnswer.includes(question_2.AzureResourceFunction.id) ||
        (addApim && !alreadyHaveFunction) ||
        (addSQL && !alreadyHaveFunction);
    // 3. check APIM and KeyVault addable
    if ((alreadyHaveApim && addApim) || (alreadyHaveKeyVault && addKeyVault)) {
        const e = new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.AddResourceNotSupport, "APIM/KeyVault is already added.");
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, e, ctx.telemetryReporter));
    }
    const newResourceSet = new Set();
    solutionSettings.azureResources.forEach((r) => newResourceSet.add(r));
    const addedResources = [];
    const pluginsToScaffold = [];
    const pluginsToDoArm = [];
    let scaffoldApim = false;
    let addSsoRes = {};
    // 4. check Function
    if (addFunc) {
        // AAD plugin needs to be activated when adding function.
        // Since APIM also have dependency on Function, will only add depenedency here.
        if (!common_1.isAADEnabled(solutionSettings)) {
            if (common_1.isAadManifestEnabled()) {
                const res = await addSso(ctx, inputs, localSettings);
                if (res.isErr()) {
                    ctx.projectSetting.solutionSettings = originalSettings;
                    return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, res.error, ctx.telemetryReporter));
                }
                addSsoRes = res.value;
            }
            else {
                (_c = solutionSettings.activeResourcePlugins) === null || _c === void 0 ? void 0 : _c.push(constants_2.PluginNames.AAD);
            }
        }
        const functionPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin);
        pluginsToScaffold.push(functionPlugin);
        if (!alreadyHaveFunction) {
            pluginsToDoArm.push(functionPlugin);
        }
        addedResources.push(question_2.AzureResourceFunction.id);
    }
    // 5. check SQL
    if (addSQL) {
        const sqlPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin);
        const identityPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.IdentityPlugin);
        pluginsToDoArm.push(sqlPlugin);
        if (!solutionSettings.activeResourcePlugins.includes(identityPlugin.name)) {
            // add identity for first time
            pluginsToDoArm.push(identityPlugin);
        }
        addedResources.push(question_2.AzureResourceSQL.id);
    }
    // 6. check APIM
    const apimPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.ApimPlugin);
    if (addApim) {
        // We don't add apimPlugin into pluginsToScaffold because
        // apim plugin needs to modify config output during scaffolding,
        // which is not supported by the scaffoldSourceCode API.
        // The scaffolding will run later as a userTask as a work around.
        addedResources.push(question_2.AzureResourceApim.id);
        pluginsToDoArm.push(apimPlugin);
        scaffoldApim = true;
    }
    if (addKeyVault) {
        const keyVaultPlugin = typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.KeyVaultPlugin);
        pluginsToDoArm.push(keyVaultPlugin);
        addedResources.push(question_2.AzureResourceKeyVault.id);
    }
    // 7. update solution settings
    addedResources.forEach((r) => newResourceSet.add(r));
    solutionSettings.azureResources = Array.from(newResourceSet);
    utils_1.setActivatedResourcePluginsV2(ctx.projectSetting);
    // 8. scaffold and update arm
    if (pluginsToScaffold.length > 0 || pluginsToDoArm.length > 0) {
        let scaffoldRes = await scaffoldCodeAndResourceTemplate(ctx, inputsNew, localSettings, pluginsToScaffold, pluginsToDoArm);
        if (scaffoldApim) {
            if (apimPlugin && apimPlugin.executeUserTask) {
                const result = await apimPlugin.executeUserTask(ctx, inputs, func, {}, envInfo, tokenProvider);
                if (result.isErr()) {
                    scaffoldRes = teamsfx_api_1.combine([scaffoldRes, result]);
                }
            }
        }
        if (scaffoldRes.isErr()) {
            ctx.projectSetting.solutionSettings = originalSettings;
            return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddResource, scaffoldRes.error, ctx.telemetryReporter));
        }
        const addNames = addedResources.map((c) => `'${c}'`).join(" and ");
        const single = addedResources.length === 1;
        const template = inputs.platform === teamsfx_api_1.Platform.CLI
            ? single
                ? localizeUtils_1.getLocalizedString("core.addResource.addResourceNoticeForCli")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourcesNoticeForCli")
            : single
                ? localizeUtils_1.getLocalizedString("core.addResource.addResourceNotice")
                : localizeUtils_1.getLocalizedString("core.addResource.addResourcesNotice");
        ctx.userInteraction.showMessage("info", util.format(template, addNames), false);
    }
    (_d = ctx.telemetryReporter) === null || _d === void 0 ? void 0 : _d.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddResource, {
        [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
        [constants_2.SolutionTelemetryProperty.Resources]: addResourcesAnswer.join(";"),
    });
    return teamsfx_api_1.ok(pluginsToDoArm.length > 0
        ? Object.assign({ solutionSettings: solutionSettings, solutionConfig: { provisionSucceeded: false } }, addSsoRes) : teamsfx_api_1.Void);
}
exports.addResource = addResource;
async function addFeature(ctx, inputs, localSettings, func, envInfo, tokenProvider) {
    const featureAnswer = inputs[question_2.AzureSolutionQuestionNames.Features];
    const capabilityAnswers = new Set([
        question_2.TabOptionItem.id,
        question_2.BotOptionItem.id,
        question_2.CommandAndResponseOptionItem.id,
        question_2.NotificationOptionItem.id,
        question_2.TabNonSsoItem.id,
        question_2.MessageExtensionItem.id,
        question_2.TabSPFxNewUIItem.id,
    ]);
    const resourceAnswers = new Set([
        question_2.AzureResourceFunction.id,
        question_2.AzureResourceSQL.id,
        question_2.AzureResourceApim.id,
        question_2.AzureResourceKeyVault.id,
    ]);
    if (capabilityAnswers.has(featureAnswer)) {
        inputs[question_2.AzureSolutionQuestionNames.Capabilities] = [featureAnswer];
        return addCapability(ctx, inputs, localSettings);
    }
    const settings = ctx.projectSetting.solutionSettings;
    const alreadyHaveFunction = settings === null || settings === void 0 ? void 0 : settings.azureResources.includes(question_2.AzureResourceFunction.id);
    if (resourceAnswers.has(featureAnswer)) {
        inputs[question_2.AzureSolutionQuestionNames.AddResources] = [featureAnswer];
        if ((featureAnswer === question_2.AzureResourceSQL.id || featureAnswer === question_2.AzureResourceApim.id) &&
            !alreadyHaveFunction) {
            inputs[question_2.AzureSolutionQuestionNames.AddResources].push(question_2.AzureResourceFunction.id);
        }
        return addResource(ctx, inputs, localSettings, func, envInfo, tokenProvider);
    }
    if (featureAnswer === question_2.SingleSignOnOptionItem.id) {
        return addSso(ctx, inputs, localSettings);
    }
    else if (featureAnswer === question_2.CicdOptionItem.id) {
        const cicdFunction = {
            namespace: "fx-solution-azure/fx-resource-cicd",
            method: "addCICDWorkflows",
            params: {},
        };
        return executeUserTask(ctx, inputs, cicdFunction, localSettings, envInfo, tokenProvider);
    }
    return teamsfx_api_1.ok({});
}
exports.addFeature = addFeature;
function extractParamForRegisterTeamsAppAndAad(answers) {
    if (answers == undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.FailedToGetParamForRegisterTeamsAppAndAad, "Input is undefined"));
    }
    const param = {
        "app-name": "",
        endpoint: "",
        environment: "local",
        "root-path": "",
    };
    for (const key of Object.keys(param)) {
        const value = answers[key];
        if (value == undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.FailedToGetParamForRegisterTeamsAppAndAad, `${key} not found`));
        }
        param[key] = value;
    }
    return teamsfx_api_1.ok(param);
}
exports.extractParamForRegisterTeamsAppAndAad = extractParamForRegisterTeamsAppAndAad;
async function addSso(ctx, inputs, localSettings) {
    var _a, _b;
    ctx.telemetryReporter.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddSsoStart, {
        [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
    });
    let solutionSettings = utils_1.getAzureSolutionSettings(ctx);
    let existingApp = false;
    if (!solutionSettings) {
        // pure existing app
        solutionSettings = {
            name: constants_4.TeamsAppSolutionNameV2,
            version: "1.0.0",
            hostType: "Azure",
            capabilities: [],
            azureResources: [],
            activeResourcePlugins: [],
        };
        ctx.projectSetting.solutionSettings = solutionSettings;
        existingApp = true;
    }
    // Check whether can add sso
    const canProceed = common_1.canAddSso(ctx.projectSetting, true);
    if (canProceed.isErr()) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddSso, canProceed.error, ctx.telemetryReporter));
    }
    const needsTab = solutionSettings.capabilities.length == 0 ||
        (solutionSettings.capabilities.includes(question_2.TabOptionItem.id) &&
            !solutionSettings.capabilities.includes(question_2.TabSsoItem.id));
    const needsBot = solutionSettings.capabilities.includes(question_2.BotOptionItem.id) &&
        !(((_b = (_a = ctx.projectSetting.pluginSettings) === null || _a === void 0 ? void 0 : _a[constants_1.ResourcePlugins.Bot]) === null || _b === void 0 ? void 0 : _b[common_1.BotHostTypeName]) ===
            common_1.BotHostTypes.AzureFunctions) &&
        !solutionSettings.capabilities.includes(question_2.BotSsoItem.id);
    // Update project settings
    if (!solutionSettings.activeResourcePlugins.includes(constants_2.PluginNames.AAD)) {
        solutionSettings.activeResourcePlugins.push(constants_2.PluginNames.AAD);
    }
    if (solutionSettings.capabilities.length == 0) {
        solutionSettings.capabilities.push(question_2.TabSsoItem.id);
    }
    if (solutionSettings.capabilities.includes(question_2.TabOptionItem.id) &&
        !solutionSettings.capabilities.includes(question_2.TabSsoItem.id)) {
        solutionSettings.capabilities.push(question_2.TabSsoItem.id);
    }
    if (needsBot) {
        solutionSettings.capabilities.push(question_2.BotSsoItem.id);
    }
    const originalSettings = lodash_1.cloneDeep(solutionSettings);
    const inputsNew = Object.assign(Object.assign({}, inputs), { projectPath: inputs.projectPath, existingResources: originalSettings.activeResourcePlugins, existingCapabilities: originalSettings.capabilities });
    const createAuthFilesRes = await createAuthFiles(inputsNew, ctx, needsTab, needsBot, projectSettingsHelper_1.isVSProject(ctx.projectSetting));
    if (createAuthFilesRes.isErr()) {
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddSso, createAuthFilesRes.error, ctx.telemetryReporter));
    }
    // Scaffold aad plugin and arm template
    const scaffoldRes = await scaffoldCodeAndResourceTemplate(ctx, inputsNew, localSettings, [typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin)], existingApp ? [] : [typedi_1.Container.get(ResourcePluginContainer_1.ResourcePluginsV2.AadPlugin)]);
    if (scaffoldRes.isErr()) {
        ctx.projectSetting.solutionSettings = originalSettings;
        return teamsfx_api_1.err(util_1.sendErrorTelemetryThenReturnError(constants_2.SolutionTelemetryEvent.AddSso, scaffoldRes.error, ctx.telemetryReporter));
    }
    // Update manifest
    const appStudioPlugin = typedi_1.Container.get(constants_5.ComponentNames.AppManifest);
    await appStudioPlugin.addCapability(inputs, [
        { name: "WebApplicationInfo" },
    ]);
    if (inputs.platform == teamsfx_api_1.Platform.VSCode) {
        ctx.userInteraction
            .showMessage("info", localizeUtils_1.getLocalizedString("core.addSso.learnMore", constants_2.AddSsoParameters.LearnMore), false, constants_2.AddSsoParameters.LearnMore)
            .then((result) => {
            var _a;
            const userSelected = result.isOk() ? result.value : undefined;
            if (userSelected === constants_2.AddSsoParameters.LearnMore) {
                (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.openUrl(constants_2.AddSsoParameters.LearnMoreUrl);
                ctx.telemetryReporter.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddSsoReadme, {
                    [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
                });
            }
        });
    }
    else if (inputs.platform == teamsfx_api_1.Platform.CLI) {
        await ctx.userInteraction.showMessage("info", localizeUtils_1.getLocalizedString("core.addSso.learnMore", constants_2.AddSsoParameters.LearnMoreUrl), false);
    }
    ctx.telemetryReporter.sendTelemetryEvent(constants_2.SolutionTelemetryEvent.AddSso, {
        [constants_2.SolutionTelemetryProperty.Component]: constants_2.SolutionTelemetryComponentName,
        [constants_2.SolutionTelemetryProperty.Success]: constants_2.SolutionTelemetrySuccess.Yes,
        [constants_2.SolutionTelemetryProperty.AddTabSso]: needsTab
            ? constants_2.SolutionTelemetrySuccess.Yes
            : constants_2.SolutionTelemetrySuccess.No,
        [constants_2.SolutionTelemetryProperty.AddBotSso]: needsBot
            ? constants_2.SolutionTelemetrySuccess.Yes
            : constants_2.SolutionTelemetrySuccess.No,
    });
    return teamsfx_api_1.ok({
        func: constants_2.AddSsoParameters.AddSso,
        capabilities: [
            ...(needsTab ? [constants_2.AddSsoParameters.Tab] : []),
            ...(needsBot ? [constants_2.AddSsoParameters.Bot] : []),
        ],
    });
}
exports.addSso = addSso;
// TODO: use 'isVsProject' for changes in VS
async function createAuthFiles(input, ctx, needTab, needBot, isVsProject = false) {
    var _a;
    const projectPath = input.projectPath;
    if (!projectPath) {
        const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.InvalidProjectPath, localizeUtils_1.getLocalizedString("core.addSsoFiles.emptyProjectPath"));
        return teamsfx_api_1.err(e);
    }
    const language = (_a = ctx.projectSetting.programmingLanguage) !== null && _a !== void 0 ? _a : constants_2.Language.JavaScript;
    const languageFolderResult = validateAndParseLanguage(language);
    if (languageFolderResult.isErr()) {
        return teamsfx_api_1.err(languageFolderResult.error);
    }
    const languageFolderName = languageFolderResult.value;
    const projectFolderExists = await fs_extra_1.default.pathExists(projectPath);
    if (!projectFolderExists) {
        const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.InvalidProjectPath, localizeUtils_1.getLocalizedString("core.addSsoFiles.projectPathNotExists"));
        return teamsfx_api_1.err(e);
    }
    const authFolder = path_1.default.join(projectPath, isVsProject ? "Auth" : "auth");
    const tabFolder = path_1.default.join(authFolder, constants_2.AddSsoParameters.Tab);
    const botFolder = path_1.default.join(authFolder, constants_2.AddSsoParameters.Bot);
    try {
        const authFolderExists = await fs_extra_1.default.pathExists(authFolder);
        if (!authFolderExists) {
            await fs_extra_1.default.ensureDir(authFolder);
        }
        if (needTab) {
            const tabFolderExists = await fs_extra_1.default.pathExists(tabFolder);
            if (!tabFolderExists) {
                await fs_extra_1.default.ensureDir(tabFolder);
            }
            const templateFolder = folder_1.getTemplatesFolder();
            const tabTemplateFolder = path_1.default.join(templateFolder, constants_2.AddSsoParameters.filePath, constants_2.AddSsoParameters.Tab);
            if (isVsProject) {
                // README.md
                const readmeSourcePath = path_1.default.join(tabTemplateFolder, constants_2.AddSsoParameters.ReadmeCSharp);
                const readmeTargetPath = path_1.default.join(tabFolder, constants_2.AddSsoParameters.ReadmeCSharp);
                const readme = await fs_extra_1.default.readFile(readmeSourcePath);
                fs_extra_1.default.writeFile(readmeTargetPath, readme);
                // Sample Code
                const sampleSourceFolder = path_1.default.join(tabTemplateFolder, languageFolderName);
                const sampleZip = new adm_zip_1.default();
                sampleZip.addLocalFolder(sampleSourceFolder);
                await templatesUtils_1.unzip(sampleZip, tabFolder);
                // Update appsettings
                const appSettingsPath = path_1.default.join(projectPath, constants_2.AddSsoParameters.AppSettings);
                const appSettingsDevPath = path_1.default.join(projectPath, constants_2.AddSsoParameters.AppSettingsDev);
                if (await fs_extra_1.default.pathExists(appSettingsPath)) {
                    const appSettings = await fs_extra_1.default.readJson(appSettingsPath);
                    if (!appSettings.TeamsFx) {
                        appSettings.TeamsFx = constants_2.AddSsoParameters.AppSettingsToAdd;
                    }
                    await fs_extra_1.default.writeFile(appSettingsPath, JSON.stringify(appSettings, null, "\t"), "utf-8");
                }
                if (await fs_extra_1.default.pathExists(appSettingsDevPath)) {
                    const appSettings = await fs_extra_1.default.readJson(appSettingsDevPath);
                    if (!appSettings.TeamsFx) {
                        appSettings.TeamsFx = constants_2.AddSsoParameters.AppSettingsToAdd;
                    }
                    await fs_extra_1.default.writeFile(appSettingsDevPath, JSON.stringify(appSettings, null, "\t"), "utf-8");
                }
            }
            else {
                // README.md
                const readmeSourcePath = path_1.default.join(tabTemplateFolder, constants_2.AddSsoParameters.Readme);
                const readmeTargetPath = path_1.default.join(tabFolder, constants_2.AddSsoParameters.Readme);
                const readme = await fs_extra_1.default.readFile(readmeSourcePath);
                fs_extra_1.default.writeFile(readmeTargetPath, readme);
                // Sample Code
                const sampleSourceFolder = path_1.default.join(tabTemplateFolder, languageFolderName);
                const sampleZip = new adm_zip_1.default();
                sampleZip.addLocalFolder(sampleSourceFolder);
                await templatesUtils_1.unzip(sampleZip, tabFolder);
            }
        }
        if (needBot) {
            const botFolderExists = await fs_extra_1.default.pathExists(botFolder);
            if (!botFolderExists) {
                await fs_extra_1.default.ensureDir(botFolder);
            }
            const templateFolder = folder_1.getTemplatesFolder();
            const botTemplateFolder = path_1.default.join(templateFolder, constants_2.AddSsoParameters.filePath, constants_2.AddSsoParameters.Bot);
            if (isVsProject) {
                // README.md
                const readmeSourcePath = path_1.default.join(botTemplateFolder, constants_2.AddSsoParameters.ReadmeCSharp);
                const readmeTargetPath = path_1.default.join(botFolder, constants_2.AddSsoParameters.ReadmeCSharp);
                const readme = await fs_extra_1.default.readFile(readmeSourcePath);
                fs_extra_1.default.writeFile(readmeTargetPath, readme);
                // Sample Code
                const sampleSourceFolder = path_1.default.join(botTemplateFolder, languageFolderName);
                const sampleZip = new adm_zip_1.default();
                sampleZip.addLocalFolder(sampleSourceFolder);
                await templatesUtils_1.unzip(sampleZip, botFolder);
                // Update appsettings
                const appSettingsPath = path_1.default.join(projectPath, constants_2.AddSsoParameters.AppSettings);
                const appSettingsDevPath = path_1.default.join(projectPath, constants_2.AddSsoParameters.AppSettingsDev);
                if (await fs_extra_1.default.pathExists(appSettingsPath)) {
                    const appSettings = await fs_extra_1.default.readJson(appSettingsPath);
                    if (!appSettings.TeamsFx ||
                        !appSettings.TeamsFx.Authentication ||
                        !appSettings.TeamsFx.Authentication.Bot) {
                        appSettings.TeamsFx = constants_2.AddSsoParameters.AppSettingsToAddForBot;
                    }
                    await fs_extra_1.default.writeFile(appSettingsPath, JSON.stringify(appSettings, null, "\t"), "utf-8");
                }
                if (await fs_extra_1.default.pathExists(appSettingsDevPath)) {
                    const appSettings = await fs_extra_1.default.readJson(appSettingsDevPath);
                    if (!appSettings.TeamsFx ||
                        !appSettings.TeamsFx.Authentication ||
                        !appSettings.TeamsFx.Authentication.Bot) {
                        appSettings.TeamsFx = constants_2.AddSsoParameters.AppSettingsToAddForBot;
                    }
                    await fs_extra_1.default.writeFile(appSettingsDevPath, JSON.stringify(appSettings, null, "\t"), "utf-8");
                }
            }
            else {
                // README.md
                const readmeSourcePath = path_1.default.join(botTemplateFolder, constants_2.AddSsoParameters.Readme);
                const readmeTargetPath = path_1.default.join(botFolder, constants_2.AddSsoParameters.Readme);
                const readme = await fs_extra_1.default.readFile(readmeSourcePath);
                fs_extra_1.default.writeFile(readmeTargetPath, readme);
                // Sample Code
                const sampleSourceFolder = path_1.default.join(botTemplateFolder, languageFolderName);
                const sampleZip = new adm_zip_1.default();
                sampleZip.addLocalFolder(sampleSourceFolder);
                await templatesUtils_1.unzip(sampleZip, botFolder);
            }
        }
    }
    catch (error) {
        if (needTab && (await fs_extra_1.default.pathExists(tabFolder))) {
            await fs_extra_1.default.remove(tabFolder);
        }
        if (needBot && (await fs_extra_1.default.pathExists(botFolder))) {
            await fs_extra_1.default.remove(botFolder);
        }
        const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.FailedToCreateAuthFiles, localizeUtils_1.getLocalizedString("core.addSsoFiles.FailedToCreateAuthFiles", error.message));
        return teamsfx_api_1.err(e);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.createAuthFiles = createAuthFiles;
function validateAndParseLanguage(language) {
    if (language.toLowerCase() == constants_2.Language.TypeScript) {
        return teamsfx_api_1.ok("ts");
    }
    if (language.toLowerCase() == constants_2.Language.JavaScript) {
        return teamsfx_api_1.ok("js");
    }
    if (language.toLowerCase() == constants_2.Language.CSharp) {
        return teamsfx_api_1.ok("csharp");
    }
    const e = new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.InvalidInput, localizeUtils_1.getLocalizedString("core.addSsoFiles.invalidLanguage"));
    return teamsfx_api_1.err(e);
}
exports.validateAndParseLanguage = validateAndParseLanguage;
//# sourceMappingURL=executeUserTask.js.map