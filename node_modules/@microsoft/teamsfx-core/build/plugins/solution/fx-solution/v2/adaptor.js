"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamedArmResourcePluginAdaptor = exports.CollaboratorContextAdapter = exports.ProvisionContextAdapter = exports.ScaffoldingContextAdapter = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../constants");
const crypto_1 = require("../../../../core/crypto");
const environment_1 = require("../../../../core/environment");
const utils4v2_1 = require("../../../resource/utils4v2");
const utils_1 = require("./utils");
class BaseSolutionContextAdaptor {
    constructor() {
        this.envInfo = environment_1.newEnvInfo();
        this.root = "";
        this.cryptoProvider = new crypto_1.LocalCrypto("");
    }
}
/**
 * An adpator for making API v2 compatible with legacy api.
 */
class ScaffoldingContextAdapter extends BaseSolutionContextAdaptor {
    constructor(params) {
        super();
        const v2context = params[0];
        const inputs = params[1];
        if (!inputs.projectPath) {
            throw new Error(`invalid project path: ${inputs.projectPath}`);
        }
        this.root = inputs.projectPath;
        this.targetEnvName = inputs.targetEnvName;
        this.logProvider = v2context.logProvider;
        this.telemetryReporter = v2context.telemetryReporter;
        this.azureAccountProvider = undefined;
        this.m365TokenProvider = undefined;
        this.treeProvider = undefined;
        this.answers = inputs;
        this.projectSettings = v2context.projectSetting;
        this.localSettings = undefined;
        this.ui = v2context.userInteraction;
        this.cryptoProvider = v2context.cryptoProvider;
        this.envInfo = environment_1.newEnvInfo(); // tbd
    }
}
exports.ScaffoldingContextAdapter = ScaffoldingContextAdapter;
class ProvisionContextAdapter extends BaseSolutionContextAdaptor {
    constructor(params) {
        super();
        const v2context = params[0];
        const inputs = params[1];
        const envInfo = params[2];
        const tokenProvider = params[3];
        if (!inputs.projectPath) {
            throw new Error(`ivalid project path: ${inputs.projectPath}`);
        }
        this.root = inputs.projectPath;
        this.targetEnvName = inputs.targetEnvName;
        this.logProvider = v2context.logProvider;
        this.telemetryReporter = v2context.telemetryReporter;
        this.azureAccountProvider = tokenProvider.azureAccountProvider;
        this.m365TokenProvider = tokenProvider.m365TokenProvider;
        this.treeProvider = undefined;
        this.answers = inputs;
        this.projectSettings = v2context.projectSetting;
        this.localSettings = undefined;
        this.ui = v2context.userInteraction;
        this.cryptoProvider = v2context.cryptoProvider;
        this.permissionRequestProvider = v2context.permissionRequestProvider;
        const state = teamsfx_api_1.ConfigMap.fromJSON(envInfo.state);
        if (!state) {
            throw new Error(`failed to convert profile ${JSON.stringify(envInfo.state)}`);
        }
        this.envInfo = {
            envName: envInfo.envName,
            config: envInfo.config,
            state: utils4v2_1.flattenConfigMap(state),
        };
    }
    getEnvStateJson() {
        return utils_1.combineRecords([...this.envInfo.state].map(([pluginName, state]) => {
            return { name: pluginName, result: utils4v2_1.legacyConfig2EnvState(state, pluginName) };
        }));
    }
}
exports.ProvisionContextAdapter = ProvisionContextAdapter;
class CollaboratorContextAdapter extends BaseSolutionContextAdaptor {
    constructor(params) {
        super();
        const v2context = params[0];
        const inputs = params[1];
        const envInfo = params[2];
        const tokenProvider = params[3];
        if (!inputs.projectPath) {
            throw new Error(`ivalid project path: ${inputs.projectPath}`);
        }
        this.root = inputs.projectPath;
        this.targetEnvName = inputs.targetEnvName;
        this.logProvider = v2context.logProvider;
        this.telemetryReporter = v2context.telemetryReporter;
        this.azureAccountProvider = tokenProvider.azureAccountProvider;
        this.m365TokenProvider = tokenProvider.m365TokenProvider;
        this.treeProvider = undefined;
        this.answers = inputs;
        this.projectSettings = v2context.projectSetting;
        this.localSettings = undefined;
        this.ui = v2context.userInteraction;
        this.cryptoProvider = v2context.cryptoProvider;
        this.permissionRequestProvider = v2context.permissionRequestProvider;
        const state = teamsfx_api_1.ConfigMap.fromJSON(envInfo.state);
        if (!state) {
            throw new Error(`failed to convert profile ${JSON.stringify(envInfo.state)}`);
        }
        this.envInfo = {
            envName: envInfo.envName,
            config: envInfo.config,
            state: utils4v2_1.flattenConfigMap(state),
        };
    }
}
exports.CollaboratorContextAdapter = CollaboratorContextAdapter;
class NamedArmResourcePluginAdaptor {
    constructor(v2Plugin) {
        this.name = v2Plugin.name;
        if (v2Plugin.generateResourceTemplate) {
            const fn = v2Plugin.generateResourceTemplate.bind(v2Plugin);
            this.generateArmTemplates = this._generateArmTemplates(fn);
        }
        if (v2Plugin.updateResourceTemplate) {
            const fn = v2Plugin.updateResourceTemplate.bind(v2Plugin);
            this.updateArmTemplates = this._updateArmTemplates(fn);
        }
    }
    _generateArmTemplates(fn) {
        return async (ctx) => {
            if (!ctx.ui ||
                !ctx.logProvider ||
                !ctx.telemetryReporter ||
                !ctx.cryptoProvider ||
                !ctx.projectSettings ||
                !ctx.answers) {
                return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.InternelError, "invalid plugin context"));
            }
            const v2ctx = {
                userInteraction: ctx.ui,
                logProvider: ctx.logProvider,
                telemetryReporter: ctx.telemetryReporter,
                cryptoProvider: ctx.cryptoProvider,
                projectSetting: ctx.projectSettings,
            };
            ctx.answers.projectPath = ctx.root;
            const result = await fn(v2ctx, ctx.answers);
            return result.map((r) => r.template);
        };
    }
    _updateArmTemplates(fn) {
        return async (ctx) => {
            if (!ctx.ui ||
                !ctx.logProvider ||
                !ctx.telemetryReporter ||
                !ctx.cryptoProvider ||
                !ctx.projectSettings ||
                !ctx.answers) {
                return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.InternelError, "invalid plugin context"));
            }
            const v2ctx = {
                userInteraction: ctx.ui,
                logProvider: ctx.logProvider,
                telemetryReporter: ctx.telemetryReporter,
                cryptoProvider: ctx.cryptoProvider,
                projectSetting: ctx.projectSettings,
            };
            ctx.answers.projectPath = ctx.root;
            const result = await fn(v2ctx, ctx.answers);
            return result.map((r) => r.template);
        };
    }
}
exports.NamedArmResourcePluginAdaptor = NamedArmResourcePluginAdaptor;
//# sourceMappingURL=adaptor.js.map