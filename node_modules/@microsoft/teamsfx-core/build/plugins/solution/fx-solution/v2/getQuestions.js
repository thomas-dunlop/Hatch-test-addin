"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuestionsForAddFeature = exports.getQuestionsForAddResource = exports.getQuestionsForAddCapability = exports.getQuestionsForUserTask = exports.getQuestions = exports.getPluginCLIName = exports.getTabScaffoldQuestionsV2 = exports.getQuestionsForScaffoldingPreview = exports.getQuestionsForScaffolding = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = tslib_1.__importDefault(require("typedi"));
const constants_1 = require("../../../../common/constants");
const constants_2 = require("../constants");
const question_1 = require("../question");
const ResourcePluginContainer_1 = require("../ResourcePluginContainer");
const utils_1 = require("./utils");
const globalVars_1 = require("../../../../core/globalVars");
const constants_3 = require("./constants");
const executeUserTask_1 = require("./executeUserTask");
const error_1 = require("../../../../core/error");
const projectSettingsHelper_1 = require("../../../../common/projectSettingsHelper");
const tools_1 = require("../../../../common/tools");
const featureFlags_1 = require("../../../../common/featureFlags");
const question_2 = require("../../../../core/question");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const constants_4 = require("../../../resource/aad/constants");
const strings_1 = require("../../../resource/bot/resources/strings");
const constants_5 = require("../../../../component/constants");
async function getQuestionsForScaffolding(ctx, inputs) {
    const node = new teamsfx_api_1.QTreeNode({
        name: "azure-solution-group",
        type: "func",
        func: (inputs) => {
            inputs[question_1.AzureSolutionQuestionNames.Solution] = constants_3.TeamsAppSolutionNameV2;
        },
    });
    if (!globalVars_1.isV3()) {
        node.condition = {
            containsAny: [
                question_1.TabSPFxItem.id,
                question_1.TabOptionItem.id,
                question_1.BotOptionItem.id,
                question_1.NotificationOptionItem.id,
                question_1.CommandAndResponseOptionItem.id,
                question_1.WorkflowOptionItem.id,
                question_1.MessageExtensionItem.id,
                ...(tools_1.isAadManifestEnabled() ? [question_1.TabNonSsoItem.id] : []),
                question_1.M365SsoLaunchPageOptionItem.id,
                question_1.M365SearchAppOptionItem.id,
            ],
        };
        // 1.1.1 SPFX Tab
        const spfxPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SpfxPlugin);
        if (spfxPlugin.getQuestionsForScaffolding) {
            const res = await spfxPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const spfxNode = res.value;
                spfxNode.condition = {
                    validFunc: (input, inputs) => {
                        if (!inputs) {
                            return "Invalid inputs";
                        }
                        const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                        if (cap.includes(question_1.TabSPFxItem.id)) {
                            return undefined;
                        }
                        return "SPFx is not selected";
                    },
                };
                if (spfxNode.data)
                    node.addChild(spfxNode);
            }
        }
    }
    else {
        node.condition = { containsAny: [question_1.TabOptionItem.id, question_1.BotOptionItem.id, question_1.MessageExtensionItem.id] };
    }
    // 1.1.2 Azure Tab
    const tabRes = await getTabScaffoldQuestionsV2(ctx, inputs, !featureFlags_1.isPreviewFeaturesEnabled() && teamsfx_api_1.CLIPlatforms.includes(inputs.platform) // only CLI and CLI_HELP support azure-resources question
    );
    if (tabRes.isErr())
        return tabRes;
    if (tabRes.value) {
        const tabNode = tabRes.value;
        tabNode.condition = {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    return "Invalid inputs";
                }
                const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                if (cap.includes(question_1.TabOptionItem.id) ||
                    (tools_1.isAadManifestEnabled() && cap.includes(question_1.TabNonSsoItem.id))) {
                    return undefined;
                }
                return "Tab is not selected";
            },
        };
        node.addChild(tabNode);
    }
    // 1.2 Bot
    const botPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
    if (botPlugin.getQuestionsForScaffolding) {
        const res = await botPlugin.getQuestionsForScaffolding(ctx, inputs);
        if (res.isErr())
            return res;
        if (res.value) {
            // Create a parent node of the node returned by plugin to prevent overwriting node.condition.
            const botGroup = new teamsfx_api_1.QTreeNode({ type: "group" });
            botGroup.addChild(res.value);
            botGroup.condition = {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        return "Invalid inputs";
                    }
                    const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                    if (cap.includes(question_1.BotOptionItem.id) ||
                        cap.includes(question_1.MessageExtensionItem.id) ||
                        cap.includes(question_1.NotificationOptionItem.id) ||
                        cap.includes(question_1.CommandAndResponseOptionItem.id) ||
                        cap.includes(question_1.WorkflowOptionItem.id)) {
                        return undefined;
                    }
                    return "Bot/Message Extension is not selected";
                },
            };
            node.addChild(botGroup);
        }
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForScaffolding = getQuestionsForScaffolding;
async function getQuestionsForScaffoldingPreview(ctx, inputs) {
    const node = new teamsfx_api_1.QTreeNode({
        name: "azure-solution-group",
        type: "func",
        func: (inputs) => {
            inputs[question_1.AzureSolutionQuestionNames.Solution] = constants_3.TeamsAppSolutionNameV2;
        },
    });
    if (!globalVars_1.isV3()) {
        node.condition = {
            enum: [
                question_1.TabSPFxItem.id,
                question_1.TabOptionItem.id,
                question_1.BotOptionItem.id,
                question_1.NotificationOptionItem.id,
                question_1.CommandAndResponseOptionItem.id,
                question_1.WorkflowOptionItem.id,
                question_1.MessageExtensionItem.id,
                ...(tools_1.isAadManifestEnabled() ? [question_1.TabNonSsoItem.id] : []),
                question_1.M365SsoLaunchPageOptionItem.id,
                question_1.M365SearchAppOptionItem.id,
            ],
        };
        // 1.1.1 SPFX Tab
        const spfxPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SpfxPlugin);
        if (spfxPlugin.getQuestionsForScaffolding) {
            const res = await spfxPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const spfxNode = res.value;
                spfxNode.condition = {
                    validFunc: (input, inputs) => {
                        if (!inputs) {
                            return "Invalid inputs";
                        }
                        const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                        if (cap === question_1.TabSPFxItem.id) {
                            return undefined;
                        }
                        return "SPFx is not selected";
                    },
                };
                if (spfxNode.data)
                    node.addChild(spfxNode);
            }
        }
    }
    else {
        node.condition = { enum: [question_1.TabOptionItem.id, question_1.BotOptionItem.id, question_1.MessageExtensionItem.id] };
    }
    // 1.1.2 Azure Tab
    const tabRes = await getTabScaffoldQuestionsV2(ctx, inputs, !featureFlags_1.isPreviewFeaturesEnabled() && teamsfx_api_1.CLIPlatforms.includes(inputs.platform) // only CLI and CLI_HELP support azure-resources question
    );
    if (tabRes.isErr())
        return tabRes;
    if (tabRes.value) {
        const tabNode = tabRes.value;
        tabNode.condition = {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    return "Invalid inputs";
                }
                const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                if (cap === question_1.TabOptionItem.id || cap === question_1.TabNonSsoItem.id) {
                    return undefined;
                }
                return "Tab is not selected";
            },
        };
        node.addChild(tabNode);
    }
    // 1.2 Bot
    const botPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin);
    if (botPlugin.getQuestionsForScaffolding) {
        const res = await botPlugin.getQuestionsForScaffolding(ctx, inputs);
        if (res.isErr())
            return res;
        if (res.value) {
            // Create a parent node of the node returned by plugin to prevent overwriting node.condition.
            const botGroup = new teamsfx_api_1.QTreeNode({ type: "group" });
            botGroup.addChild(res.value);
            botGroup.condition = {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        return "Invalid inputs";
                    }
                    const cap = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
                    if (cap === question_1.BotOptionItem.id ||
                        cap === question_1.MessageExtensionItem.id ||
                        cap === question_1.NotificationOptionItem.id ||
                        cap === question_1.CommandAndResponseOptionItem.id ||
                        cap === question_1.WorkflowOptionItem.id) {
                        return undefined;
                    }
                    return "Bot/Message Extension is not selected";
                },
            };
            node.addChild(botGroup);
        }
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForScaffoldingPreview = getQuestionsForScaffoldingPreview;
async function getTabScaffoldQuestionsV2(ctx, inputs, addAzureResource) {
    const tabNode = new teamsfx_api_1.QTreeNode({ type: "group" });
    //Frontend plugin
    const fehostPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.FrontendPlugin);
    if (fehostPlugin.getQuestionsForScaffolding) {
        const res = await fehostPlugin.getQuestionsForScaffolding(ctx, inputs);
        if (res.isErr())
            return res;
        if (res.value) {
            const frontendNode = res.value;
            if (frontendNode.data)
                tabNode.addChild(frontendNode);
        }
    }
    if (addAzureResource) {
        const azureResourceNode = new teamsfx_api_1.QTreeNode(question_1.AzureResourcesQuestion);
        tabNode.addChild(azureResourceNode);
        const functionPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin);
        //Azure Function
        if (functionPlugin.getQuestionsForScaffolding) {
            const res = await functionPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_function = res.value;
                azure_function.condition = { minItems: 1 };
                if (azure_function.data)
                    azureResourceNode.addChild(azure_function);
            }
        }
        const sqlPlugin = typedi_1.default.get(ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin);
        //Azure SQL
        if (sqlPlugin.getQuestionsForScaffolding) {
            const res = await sqlPlugin.getQuestionsForScaffolding(ctx, inputs);
            if (res.isErr())
                return res;
            if (res.value) {
                const azure_sql = res.value;
                azure_sql.condition = { contains: question_1.AzureResourceSQL.id };
                if (azure_sql.data)
                    azureResourceNode.addChild(azure_sql);
            }
        }
    }
    return teamsfx_api_1.ok(tabNode);
}
exports.getTabScaffoldQuestionsV2 = getTabScaffoldQuestionsV2;
function getPluginCLIName(name) {
    const pluginPrefix = "fx-resource-";
    if (name === constants_1.ResourcePlugins.Aad) {
        return "aad-manifest";
    }
    else if (name === constants_1.ResourcePlugins.AppStudio) {
        return "manifest";
    }
    else {
        return name.replace(pluginPrefix, "");
    }
}
exports.getPluginCLIName = getPluginCLIName;
async function getQuestions(ctx, inputs, envInfo, tokenProvider) {
    const stage = inputs.stage;
    if (!stage) {
        return teamsfx_api_1.err(new teamsfx_api_1.InvalidInputError(constants_2.SolutionSource, "inputs.stage", "undefined"));
    }
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    const node = new teamsfx_api_1.QTreeNode({ type: "group" });
    const solutionSettings = ctx.projectSetting.solutionSettings;
    if (stage === teamsfx_api_1.Stage.provision) {
        if (isDynamicQuestion) {
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (provisioned)
                return teamsfx_api_1.ok(undefined);
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(ctx.projectSetting);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
            node.addChild(new teamsfx_api_1.QTreeNode(question_1.AskSubscriptionQuestion));
        }
        for (const plugin of plugins) {
            if (plugin.getQuestions) {
                const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                if (getQuestionRes.isErr())
                    return getQuestionRes;
                if (getQuestionRes.value) {
                    const subnode = getQuestionRes.value;
                    node.addChild(subnode);
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.deploy) {
        if (inputs.platform === teamsfx_api_1.Platform.VSCode && inputs[constants_4.Constants.INCLUDE_AAD_MANIFEST] === "yes") {
            return teamsfx_api_1.ok(node);
        }
        if (isDynamicQuestion) {
            const isAzure = utils_1.isAzureProject(solutionSettings);
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (isAzure && !provisioned) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    source: constants_2.SolutionSource,
                    name: constants_2.SolutionError.CannotDeployBeforeProvision,
                    message: localizeUtils_1.getDefaultString("core.deploy.FailedToDeployBeforeProvision"),
                    displayMessage: localizeUtils_1.getLocalizedString("core.deploy.FailedToDeployBeforeProvision"),
                    helpLink: constants_1.HelpLinks.WhyNeedProvision,
                }));
            }
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(ctx.projectSetting);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
        }
        if (tools_1.isDeployManifestEnabled() && inputs.platform === teamsfx_api_1.Platform.VSCode) {
            plugins = plugins.filter((plugin) => plugin.name !== constants_1.ResourcePlugins.AppStudio);
        }
        if (tools_1.isAadManifestEnabled() &&
            (inputs.platform === teamsfx_api_1.Platform.CLI_HELP || inputs.platform === teamsfx_api_1.Platform.CLI)) {
            plugins = plugins.filter((plugin) => !!plugin.deploy);
        }
        else {
            plugins = plugins.filter((plugin) => !!plugin.deploy && plugin.displayName !== "AAD");
        }
        if (plugins.length === 0 && inputs[constants_4.Constants.INCLUDE_AAD_MANIFEST] !== "yes") {
            return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.deploy));
        }
        // On VS, users are not expected to select plugins to deploy.
        if (!projectSettingsHelper_1.isVSProject(ctx.projectSetting)) {
            const options = plugins.map((plugin) => {
                const item = {
                    id: plugin.name,
                    label: plugin.displayName,
                    cliName: getPluginCLIName(plugin.name),
                };
                return item;
            });
            const selectQuestion = question_1.DeployPluginSelectQuestion;
            selectQuestion.staticOptions = options;
            selectQuestion.default = options.map((i) => i.id);
            const pluginSelection = new teamsfx_api_1.QTreeNode(selectQuestion);
            node.addChild(pluginSelection);
            for (const plugin of plugins) {
                if (plugin.getQuestions) {
                    const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                    if (getQuestionRes.isErr())
                        return getQuestionRes;
                    if (getQuestionRes.value) {
                        const subnode = getQuestionRes.value;
                        subnode.condition = { contains: plugin.name };
                        if (subnode.data)
                            pluginSelection.addChild(subnode);
                    }
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.publish) {
        if (isDynamicQuestion) {
            const isAzure = utils_1.isAzureProject(solutionSettings);
            const provisioned = utils_1.checkWetherProvisionSucceeded(envInfo.state);
            if (!provisioned) {
                const errorMsg = isAzure
                    ? localizeUtils_1.getLocalizedString("core.publish.FailedToPublishBeforeProvision")
                    : localizeUtils_1.getLocalizedString("core.publish.SPFxAskProvisionBeforePublish");
                const defaultMsg = isAzure
                    ? localizeUtils_1.getDefaultString("core.publish.FailedToPublishBeforeProvision")
                    : localizeUtils_1.getDefaultString("core.publish.SPFxAskProvisionBeforePublish");
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    source: constants_2.SolutionSource,
                    name: constants_2.SolutionError.CannotPublishBeforeProvision,
                    message: defaultMsg,
                    displayMessage: errorMsg,
                    helpLink: constants_1.HelpLinks.WhyNeedProvision,
                }));
            }
        }
        let plugins = [];
        if (isDynamicQuestion) {
            plugins = utils_1.getSelectedPlugins(ctx.projectSetting);
        }
        else {
            plugins = ResourcePluginContainer_1.getAllV2ResourcePlugins();
        }
        plugins = plugins.filter((plugin) => !!plugin.publishApplication);
        for (const plugin of plugins) {
            if (plugin.getQuestions) {
                const getQuestionRes = await plugin.getQuestions(ctx, inputs, envInfo, tokenProvider);
                if (getQuestionRes.isErr())
                    return getQuestionRes;
                if (getQuestionRes.value) {
                    const subnode = getQuestionRes.value;
                    node.addChild(subnode);
                }
            }
        }
    }
    else if (stage === teamsfx_api_1.Stage.grantPermission) {
        if (isDynamicQuestion) {
            const jsonObjectRes = await tokenProvider.m365TokenProvider.getJsonObject({
                scopes: tools_1.AppStudioScopes,
            });
            const jsonObject = jsonObjectRes.isOk() ? jsonObjectRes.value : undefined;
            node.addChild(new teamsfx_api_1.QTreeNode(question_1.getUserEmailQuestion(jsonObject.upn)));
        }
    }
    return teamsfx_api_1.ok(node);
}
exports.getQuestions = getQuestions;
async function getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider) {
    const namespace = func.namespace;
    const array = namespace.split("/");
    if (func.method === "addCapability") {
        return await getQuestionsForAddCapability(ctx, inputs, func, envInfo, tokenProvider);
    }
    if (func.method === "addResource") {
        return await getQuestionsForAddResource(ctx, inputs, func, envInfo, tokenProvider);
    }
    if (func.method === "addFeature") {
        return await getQuestionsForAddFeature(ctx, inputs, func, envInfo, tokenProvider);
    }
    if (array.length == 2) {
        const pluginName = array[1];
        const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
        const plugin = pluginMap.get(pluginName);
        if (plugin && plugin.getQuestionsForUserTask) {
            return await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.getQuestionsForUserTask = getQuestionsForUserTask;
async function getQuestionsForAddCapability(ctx, inputs, func, envInfo, tokenProvider) {
    var _a;
    if (ctx.projectSetting.isM365) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.AddCapabilityNotSupport, localizeUtils_1.getDefaultString("core.addCapability.notSupportedForM365Project"), localizeUtils_1.getLocalizedString("core.addCapability.notSupportedForM365Project")));
    }
    const settings = ctx.projectSetting.solutionSettings;
    const addCapQuestion = {
        name: question_1.AzureSolutionQuestionNames.Capabilities,
        title: featureFlags_1.isBotNotificationEnabled() ? "Capabilities" : "Choose capabilities",
        type: "multiSelect",
        staticOptions: [],
        default: [],
        validation: {
            validFunc: question_2.validateCapabilities,
        },
        onDidChangeSelection: question_2.onChangeSelectionForCapabilities,
    };
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    if (!isDynamicQuestion) {
        // For CLI_HELP
        addCapQuestion.staticOptions = [
            ...(featureFlags_1.isBotNotificationEnabled() ? [question_1.TabNewUIOptionItem] : [question_1.TabOptionItem]),
            ...[question_1.BotOptionItem],
            ...(featureFlags_1.isBotNotificationEnabled()
                ? [question_1.NotificationOptionItem, question_1.CommandAndResponseOptionItem, question_1.WorkflowOptionItem]
                : []),
            ...(featureFlags_1.isBotNotificationEnabled() ? [question_1.MessageExtensionNewUIItem] : [question_1.MessageExtensionItem]),
            ...(tools_1.isAadManifestEnabled() ? [question_1.TabNonSsoItem] : []),
        ];
        const addCapNode = new teamsfx_api_1.QTreeNode(addCapQuestion);
        if (featureFlags_1.isBotNotificationEnabled()) {
            // Hardcoded to call bot plugin to get notification trigger questions.
            // Originally, v2 solution will not call getQuestionForUserTask of plugins on addCapability.
            // V3 will not need this hardcoding.
            const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
            const plugin = pluginMap.get(constants_2.PluginNames.BOT);
            if (plugin && plugin.getQuestionsForUserTask) {
                const result = await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
                if (result.isErr()) {
                    return result;
                }
                const botQuestionNode = result.value;
                if (botQuestionNode) {
                    addCapNode.addChild(botQuestionNode);
                }
            }
        }
        return teamsfx_api_1.ok(addCapNode);
    }
    const canProceed = executeUserTask_1.canAddCapability(settings, ctx.telemetryReporter);
    if (canProceed.isErr()) {
        return teamsfx_api_1.err(canProceed.error);
    }
    const appStudioPlugin = typedi_1.default.get(constants_5.ComponentNames.AppManifest);
    const tabExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "staticTab");
    if (tabExceedRes.isErr()) {
        return teamsfx_api_1.err(tabExceedRes.error);
    }
    const isTabAddable = !tabExceedRes.value;
    const botExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "Bot");
    if (botExceedRes.isErr()) {
        return teamsfx_api_1.err(botExceedRes.error);
    }
    const isBotAddable = !botExceedRes.value;
    const meExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "MessageExtension");
    if (meExceedRes.isErr()) {
        return teamsfx_api_1.err(meExceedRes.error);
    }
    // for the new bot, messaging extension and other bots are mutally exclusive
    const isMEAddable = !meExceedRes.value && (!featureFlags_1.isBotNotificationEnabled() || isBotAddable);
    if (!(isTabAddable || isBotAddable || isMEAddable)) {
        (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("error", localizeUtils_1.getLocalizedString("core.addCapability.exceedMaxLimit"), false);
        return teamsfx_api_1.ok(undefined);
    }
    const options = [];
    if (isBotAddable) {
        if (featureFlags_1.isBotNotificationEnabled()) {
            options.push(question_1.CommandAndResponseOptionItem);
            options.push(question_1.WorkflowOptionItem);
            options.push(question_1.NotificationOptionItem);
            options.push(question_1.BotOptionItem);
        }
        else {
            options.push(question_1.BotOptionItem);
        }
    }
    const tabOptionItem = featureFlags_1.isBotNotificationEnabled() ? question_1.TabNewUIOptionItem : question_1.TabOptionItem;
    if (isTabAddable) {
        if (!tools_1.isAadManifestEnabled()) {
            options.push(tabOptionItem);
        }
        else {
            if (!(settings === null || settings === void 0 ? void 0 : settings.capabilities.includes(question_1.TabOptionItem.id))) {
                options.push(question_1.TabNonSsoItem, tabOptionItem);
            }
            else {
                options.push((settings === null || settings === void 0 ? void 0 : settings.capabilities.includes(question_1.TabSsoItem.id)) ? tabOptionItem : question_1.TabNonSsoItem);
            }
        }
    }
    if (isMEAddable) {
        options.push(featureFlags_1.isBotNotificationEnabled() ? question_1.MessageExtensionNewUIItem : question_1.MessageExtensionItem);
    }
    addCapQuestion.staticOptions = options;
    const addCapNode = new teamsfx_api_1.QTreeNode(addCapQuestion);
    // // mini app can add SPFx tab
    // if (!settings) {
    //   options.push(TabSPFxItem);
    //   const spfxPlugin = Container.get<v2.ResourcePlugin>(ResourcePluginsV2.SpfxPlugin);
    //   if (spfxPlugin && spfxPlugin.getQuestionsForScaffolding) {
    //     const result = await spfxPlugin.getQuestionsForScaffolding(ctx, inputs);
    //     if (result.isErr()) {
    //       return result;
    //     }
    //     const spfxQuestionNode = result.value;
    //     if (spfxQuestionNode) {
    //       spfxQuestionNode.condition = { contains: TabSPFxItem.id };
    //       addCapNode.addChild(spfxQuestionNode);
    //     }
    //   }
    // }
    if (featureFlags_1.isBotNotificationEnabled()) {
        // Hardcoded to call bot plugin to get notification trigger questions.
        // Originally, v2 solution will not call getQuestionForUserTask of plugins on addCapability.
        // V3 will not need this hardcoding.
        const pluginMap = ResourcePluginContainer_1.getAllV2ResourcePluginMap();
        const plugin = pluginMap.get(constants_2.PluginNames.BOT);
        if (plugin && plugin.getQuestionsForUserTask) {
            const result = await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
            if (result.isErr()) {
                return result;
            }
            const botQuestionNode = result.value;
            if (botQuestionNode) {
                addCapNode.addChild(botQuestionNode);
            }
        }
    }
    if (!ctx.projectSetting.programmingLanguage) {
        // Language
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestion);
        addCapNode.addChild(programmingLanguage);
    }
    return teamsfx_api_1.ok(addCapNode);
}
exports.getQuestionsForAddCapability = getQuestionsForAddCapability;
async function getQuestionsForAddResource(ctx, inputs, func, envInfo, tokenProvider) {
    const settings = ctx.projectSetting.solutionSettings;
    const isDynamicQuestion = teamsfx_api_1.DynamicPlatforms.includes(inputs.platform);
    let addQuestion;
    if (!isDynamicQuestion) {
        addQuestion = question_1.createAddAzureResourceQuestion(false, false, false, false);
    }
    else {
        if (!settings) {
            return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.addResource));
        }
        const alreadyHaveFunction = settings.azureResources.includes(question_1.AzureResourceFunction.id);
        const alreadyHaveSQL = settings.azureResources.includes(question_1.AzureResourceSQL.id);
        const alreadyHaveAPIM = settings.azureResources.includes(question_1.AzureResourceApim.id);
        const alreadyHaveKeyVault = settings.azureResources.includes(question_1.AzureResourceKeyVault.id);
        addQuestion = question_1.createAddAzureResourceQuestion(alreadyHaveFunction, alreadyHaveSQL, alreadyHaveAPIM, alreadyHaveKeyVault);
        const canProceed = executeUserTask_1.canAddResource(ctx.projectSetting, ctx.telemetryReporter);
        if (canProceed.isErr()) {
            return teamsfx_api_1.err(canProceed.error);
        }
    }
    const addAzureResourceNode = new teamsfx_api_1.QTreeNode(addQuestion);
    //traverse plugins' getQuestionsForUserTask
    const pluginsWithResources = [
        [ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin, question_1.AzureResourceFunction.id],
        [ResourcePluginContainer_1.ResourcePluginsV2.SqlPlugin, question_1.AzureResourceSQL.id],
        [ResourcePluginContainer_1.ResourcePluginsV2.ApimPlugin, question_1.AzureResourceApim.id],
        [ResourcePluginContainer_1.ResourcePluginsV2.KeyVaultPlugin, question_1.AzureResourceKeyVault.id],
    ];
    for (const pair of pluginsWithResources) {
        const pluginName = pair[0];
        const resourceName = pair[1];
        const plugin = typedi_1.default.get(pluginName);
        if (plugin.getQuestionsForUserTask) {
            const res = await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
            if (res.isErr())
                return res;
            if (res.value) {
                const node = res.value;
                node.condition = { contains: resourceName };
                if (node.data)
                    addAzureResourceNode.addChild(node);
            }
        }
    }
    return teamsfx_api_1.ok(addAzureResourceNode);
}
exports.getQuestionsForAddResource = getQuestionsForAddResource;
async function getStaticOptionsForAddCapability(ctx, inputs, settings) {
    var _a, _b, _c;
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        const options = [];
        options.push(question_1.NotificationOptionItem);
        options.push(question_1.CommandAndResponseOptionItem);
        options.push(question_1.WorkflowOptionItem);
        options.push(question_1.TabNewUIOptionItem, question_1.TabNonSsoItem);
        options.push(question_1.BotNewUIOptionItem);
        options.push(question_1.MessageExtensionNewUIItem);
        return teamsfx_api_1.ok(options);
    }
    const appStudioPlugin = typedi_1.default.get(constants_5.ComponentNames.AppManifest);
    const tabExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "staticTab");
    if (tabExceedRes.isErr()) {
        return teamsfx_api_1.err(tabExceedRes.error);
    }
    const isTabSPFxAddable = !tabExceedRes.value && tools_1.isSPFxProject(ctx.projectSetting) && featureFlags_1.isSPFxMultiTabEnabled();
    if (isTabSPFxAddable) {
        return teamsfx_api_1.ok([question_1.TabSPFxNewUIItem]);
    }
    const isTabAddable = !tabExceedRes.value;
    const botExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "Bot");
    if (botExceedRes.isErr()) {
        return teamsfx_api_1.err(botExceedRes.error);
    }
    const hasMe = settings === null || settings === void 0 ? void 0 : settings.capabilities.includes(question_1.MessageExtensionItem.id);
    const isScenarioBotAddable = !botExceedRes.value && !hasMe;
    const isDefaultBotAddable = !botExceedRes.value;
    const meExceedRes = await appStudioPlugin.capabilityExceedLimit(inputs, "MessageExtension");
    if (meExceedRes.isErr()) {
        return teamsfx_api_1.err(meExceedRes.error);
    }
    // For the new bot, messaging extension and other bots are mutally exclusive.
    // For the old bot, messaging extension can be added when bot exists.
    const botCapabilities = (_b = (_a = ctx.projectSetting.pluginSettings) === null || _a === void 0 ? void 0 : _a[constants_2.PluginNames.BOT]) === null || _b === void 0 ? void 0 : _b[strings_1.PluginBot.BOT_CAPABILITIES];
    const hasNewBot = Array.isArray(botCapabilities) && botCapabilities.length > 0;
    const isMEAddable = featureFlags_1.isBotNotificationEnabled()
        ? !meExceedRes.value && !hasNewBot
        : !meExceedRes.value;
    if (!(isTabAddable || isDefaultBotAddable || isScenarioBotAddable || isMEAddable)) {
        (_c = ctx.userInteraction) === null || _c === void 0 ? void 0 : _c.showMessage("error", localizeUtils_1.getLocalizedString("core.addCapability.exceedMaxLimit"), false);
        return teamsfx_api_1.ok([]);
    }
    const options = [];
    if (isScenarioBotAddable) {
        options.push(question_1.NotificationOptionItem);
        options.push(question_1.CommandAndResponseOptionItem);
        options.push(question_1.WorkflowOptionItem);
    }
    if (isTabAddable) {
        if (!(settings === null || settings === void 0 ? void 0 : settings.capabilities.includes(question_1.TabOptionItem.id))) {
            options.push(question_1.TabNewUIOptionItem, question_1.TabNonSsoItem);
        }
        else {
            options.push((settings === null || settings === void 0 ? void 0 : settings.capabilities.includes(question_1.TabSsoItem.id)) ? question_1.TabNewUIOptionItem : question_1.TabNonSsoItem);
        }
    }
    if (isDefaultBotAddable) {
        options.push(question_1.BotNewUIOptionItem);
    }
    if (isMEAddable) {
        options.push(question_1.MessageExtensionNewUIItem);
    }
    return teamsfx_api_1.ok(options);
}
/**
 * Combines the options of AddCapability and AddResource.
 * Only works for VS Code new UI with Preview feature flag enabled.
 */
async function getQuestionsForAddFeature(ctx, inputs, func, envInfo, tokenProvider) {
    const settings = ctx.projectSetting.solutionSettings;
    const options = [];
    const addFeatureQuestion = {
        name: question_1.AzureSolutionQuestionNames.Features,
        title: localizeUtils_1.getLocalizedString("core.addFeatureQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
    };
    // check and generate capability options
    const canAddCapabilityResult = executeUserTask_1.canAddCapability(settings, ctx.telemetryReporter);
    if (canAddCapabilityResult.isOk() && !ctx.projectSetting.isM365) {
        const optionsResult = await getStaticOptionsForAddCapability(ctx, inputs, settings);
        if (optionsResult.isErr()) {
            return teamsfx_api_1.err(optionsResult.error);
        }
        options.push(...optionsResult.value);
    }
    // check and generate cloud resource options
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        options.push(...question_1.createAddCloudResourceOptions(false, false));
    }
    else {
        const canAddResourceResult = executeUserTask_1.canAddResource(ctx.projectSetting, ctx.telemetryReporter);
        if (canAddResourceResult.isOk()) {
            // resources
            if (!settings) {
                return teamsfx_api_1.err(new error_1.NoCapabilityFoundError(teamsfx_api_1.Stage.addResource));
            }
            const alreadyHaveAPIM = settings.azureResources.includes(question_1.AzureResourceApim.id);
            const alreadyHaveKeyVault = settings.azureResources.includes(question_1.AzureResourceKeyVault.id);
            const addResourceOptions = question_1.createAddCloudResourceOptions(alreadyHaveAPIM, alreadyHaveKeyVault);
            options.push(...addResourceOptions);
        }
    }
    // check and generate additional feature options
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP || tools_1.canAddSso(ctx.projectSetting)) {
        options.push(question_1.SingleSignOnOptionItem);
    }
    const isApiConnectionAddable = tools_1.canAddApiConnection(settings);
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP || isApiConnectionAddable) {
        options.push(question_1.ApiConnectionOptionItem);
    }
    const isCicdAddable = await tools_1.canAddCICDWorkflows(inputs, ctx);
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP || isCicdAddable) {
        options.push(question_1.CicdOptionItem);
    }
    addFeatureQuestion.staticOptions = options;
    const addFeatureNode = new teamsfx_api_1.QTreeNode(addFeatureQuestion);
    if (inputs.platform !== teamsfx_api_1.Platform.CLI_HELP && !ctx.projectSetting.programmingLanguage) {
        // Language
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_2.ProgrammingLanguageQuestion);
        programmingLanguage.condition = {
            enum: [
                question_1.NotificationOptionItem.id,
                question_1.CommandAndResponseOptionItem.id,
                question_1.WorkflowOptionItem.id,
                question_1.TabNewUIOptionItem.id,
                question_1.TabNonSsoItem.id,
                question_1.BotNewUIOptionItem.id,
                question_1.MessageExtensionItem.id,
                question_1.SingleSignOnOptionItem.id,
            ],
        };
        addFeatureNode.addChild(programmingLanguage);
    }
    // traverse plugins' getQuestionsForUserTask
    const pluginsWithResources = [
        [ResourcePluginContainer_1.ResourcePluginsV2.BotPlugin, question_1.BotNewUIOptionItem.id],
        [ResourcePluginContainer_1.ResourcePluginsV2.FunctionPlugin, question_1.AzureResourceFunction.id],
    ];
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP || isCicdAddable) {
        pluginsWithResources.push([ResourcePluginContainer_1.ResourcePluginsV2.CICDPlugin, question_1.CicdOptionItem.id]);
    }
    if (featureFlags_1.isSPFxMultiTabEnabled()) {
        pluginsWithResources.push([ResourcePluginContainer_1.ResourcePluginsV2.SpfxPlugin, question_1.TabSPFxNewUIItem.id]);
    }
    const alreadyHaveFunction = settings === null || settings === void 0 ? void 0 : settings.azureResources.includes(question_1.AzureResourceFunction.id);
    for (const pair of pluginsWithResources) {
        const pluginName = pair[0];
        const resourceName = pair[1];
        const plugin = typedi_1.default.get(pluginName);
        if (plugin.getQuestionsForUserTask) {
            const res = await plugin.getQuestionsForUserTask(ctx, inputs, func, envInfo, tokenProvider);
            if (res.isErr())
                return res;
            if (res.value) {
                const node = res.value;
                if (!node.condition) {
                    if (resourceName !== question_1.AzureResourceFunction.id) {
                        node.condition = { equals: resourceName };
                    }
                    else {
                        // Azure Function question is related to APIM and SQL
                        node.condition = {
                            validFunc: (input, inputs) => {
                                if (input === question_1.AzureResourceFunction.id) {
                                    return undefined;
                                }
                                if (!alreadyHaveFunction &&
                                    (input === question_1.AzureResourceSQL.id || input === question_1.AzureResourceApim.id)) {
                                    return undefined;
                                }
                                return "Function related is not selected";
                            },
                        };
                    }
                }
                if (node.data) {
                    addFeatureNode.addChild(node);
                }
            }
        }
    }
    return teamsfx_api_1.ok(addFeatureNode);
}
exports.getQuestionsForAddFeature = getQuestionsForAddFeature;
//# sourceMappingURL=getQuestions.js.map