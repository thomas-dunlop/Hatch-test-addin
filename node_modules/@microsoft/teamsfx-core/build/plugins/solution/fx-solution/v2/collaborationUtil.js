"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollaborationUtil = void 0;
const tslib_1 = require("tslib");
// This file contains reusable pieces for collaboration apis
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const lodash_1 = require("lodash");
const common_1 = require("../../../../common");
const constants_1 = require("../constants");
class CollaborationUtil {
    static async getCurrentUserInfo(m365TokenProvider) {
        const user = await CollaborationUtil.getUserInfo(m365TokenProvider);
        if (!user) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.FailedToRetrieveUserInfo, "Failed to retrieve current user info from graph token."));
        }
        return teamsfx_api_1.ok(user);
    }
    static async getUserInfo(m365TokenProvider, email) {
        const currentUserRes = await (m365TokenProvider === null || m365TokenProvider === void 0 ? void 0 : m365TokenProvider.getJsonObject({ scopes: common_1.GraphScopes }));
        const currentUser = (currentUserRes === null || currentUserRes === void 0 ? void 0 : currentUserRes.isOk()) ? currentUserRes.value : undefined;
        if (!currentUser) {
            return undefined;
        }
        const tenantId = currentUser["tid"];
        let aadId = currentUser["oid"];
        let userPrincipalName = currentUser["unique_name"];
        let displayName = currentUser["name"];
        const isAdministrator = true;
        if (email) {
            const graphTokenRes = await (m365TokenProvider === null || m365TokenProvider === void 0 ? void 0 : m365TokenProvider.getAccessToken({ scopes: common_1.GraphScopes }));
            const graphToken = (graphTokenRes === null || graphTokenRes === void 0 ? void 0 : graphTokenRes.isOk()) ? graphTokenRes.value : undefined;
            const instance = axios_1.default.create({
                baseURL: "https://graph.microsoft.com/v1.0",
            });
            instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
            const res = await instance.get(`/users?$filter=startsWith(mail,'${email}') or startsWith(userPrincipalName, '${email}')`);
            if (!res || !res.data || !res.data.value) {
                return undefined;
            }
            const collaborator = res.data.value.find((user) => user.mail.toLowerCase() === email.toLowerCase() ||
                user.userPrincipalName.toLowerCase() === email.toLowerCase());
            if (!collaborator) {
                return undefined;
            }
            aadId = collaborator.id;
            userPrincipalName = collaborator.userPrincipalName;
            displayName = collaborator.displayName;
        }
        return {
            tenantId,
            aadId,
            userPrincipalName,
            displayName,
            isAdministrator,
        };
    }
    static checkWetherProvisionSucceeded(solutionConfig) {
        var _a;
        return !!((_a = solutionConfig.get(constants_1.GLOBAL_CONFIG)) === null || _a === void 0 ? void 0 : _a.getBoolean(constants_1.SOLUTION_PROVISION_SUCCEEDED));
    }
    static getCurrentCollaborationState(envState, user) {
        var _a;
        const provisioned = CollaborationUtil.checkWetherProvisionSucceeded(envState);
        if (!provisioned) {
            const warningMsg = "The resources have not been provisioned yet. Please provision the resources first.";
            return {
                state: common_1.CollaborationState.NotProvisioned,
                message: warningMsg,
            };
        }
        const aadAppTenantId = (_a = envState.get(constants_1.PluginNames.SOLUTION)) === null || _a === void 0 ? void 0 : _a.get(constants_1.REMOTE_TEAMS_APP_TENANT_ID);
        if (!aadAppTenantId || user.tenantId != aadAppTenantId) {
            const warningMsg = "Tenant id of your account and the provisioned Azure AD app does not match. Please check whether you logined with wrong account.";
            return {
                state: common_1.CollaborationState.M365TenantNotMatch,
                message: warningMsg,
            };
        }
        return {
            state: common_1.CollaborationState.OK,
        };
    }
    static getProjectSettings(ctx) {
        var _a;
        let solutionSettings;
        if ("projectSettings" in ctx) {
            solutionSettings = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.solutionSettings;
        }
        else {
            solutionSettings = ctx.projectSetting.solutionSettings;
        }
        return solutionSettings;
    }
    static isSpfxProject(ctx) {
        const solutionSettings = this.getProjectSettings(ctx);
        if (solutionSettings) {
            const selectedPlugins = solutionSettings.activeResourcePlugins;
            return selectedPlugins && selectedPlugins.indexOf("fx-resource-spfx") !== -1;
        }
        return false;
    }
    static AadResourcePluginsActivated(ctx) {
        const solutionSettings = this.getProjectSettings(ctx);
        if (solutionSettings) {
            const selectedPlugins = solutionSettings.activeResourcePlugins;
            return selectedPlugins && selectedPlugins.indexOf("fx-resource-aad-app-for-teams") !== -1;
        }
        return false;
    }
    static collectPermissionsAndErrors(executionResult) {
        const results = executionResult;
        const permissions = [];
        let errors = [];
        if (results.kind === "success" || results.kind === "partialSuccess") {
            for (const r of results.output) {
                if (r && r.result && lodash_1.isArray(r.result)) {
                    for (const res of r.result) {
                        permissions.push(res);
                    }
                }
            }
        }
        if (results.kind === "partialSuccess" || results.kind === "failure") {
            errors = [teamsfx_api_1.err(results.error)];
        }
        return [permissions, errors];
    }
}
exports.CollaborationUtil = CollaborationUtil;
//# sourceMappingURL=collaborationUtil.js.map