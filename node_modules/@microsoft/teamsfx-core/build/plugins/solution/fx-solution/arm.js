"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.armV2 = exports.formattedDeploymentError = exports.wrapGetDeploymentError = exports.generateResourceBaseName = exports.ArmTemplateRenderContext = exports.getParameterJsonV3 = exports.getParameterJson = exports.updateAzureParameters = exports.copyParameterJson = exports.deployArmTemplatesV3 = exports.deployArmTemplates = exports.doDeployArmTemplatesV3 = exports.doDeployArmTemplates = exports.pollDeploymentStatus = exports.getRequiredOperation = exports.generateBicep = exports.generateArmTemplate = void 0;
const tslib_1 = require("tslib");
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const typedi_1 = require("typedi");
const util_1 = require("util");
const constants_1 = require("./constants");
const environment_1 = require("../../../core/environment");
const common_1 = require("../../../common");
const constants_2 = require("../../../common/constants");
const cpUtils_1 = require("../../../common/cpUtils");
const tools_1 = require("../../../common/tools");
const folder_1 = require("../../../folder");
const ResourcePluginContainer_1 = require("./ResourcePluginContainer");
const bicepChecker_1 = require("./utils/depsChecker/bicepChecker");
const progressHelper_1 = require("./utils/progressHelper");
const util_2 = require("./utils/util");
const adaptor_1 = require("./v2/adaptor");
const localizeUtils_1 = require("../../../common/localizeUtils");
const utils_1 = require("../../../common/utils");
const core_1 = require("../../../core");
const migrate_1 = require("../../../component/migrate");
const bicepOrchestrationFileName = "main.bicep";
const bicepOrchestrationProvisionMainFileName = "mainProvision.bicep";
const bicepOrchestrationConfigMainFileName = "mainConfig.bicep";
const bicepOrchestrationProvisionFileName = "provision.bicep";
const bicepOrchestrationConfigFileName = "config.bicep";
const configsFolder = `.${teamsfx_api_1.ConfigFolderName}/configs`;
const parameterFileNameTemplate = `azure.parameters.${teamsfx_api_1.EnvNamePlaceholder}.json`;
const pollWaitSeconds = 10;
const maxRetryTimes = 4;
// constant string
const resourceBaseName = "resourceBaseName";
const parameterName = "parameters";
const solutionName = "solution";
const InvalidTemplateErrorCode = "InvalidTemplate";
// Get ARM template content from each resource plugin and output to project folder
async function generateArmTemplate(ctx, selectedPlugins = []) {
    var _a, _b;
    let result;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplateStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doGenerateArmTemplate(ctx, selectedPlugins);
        if (result.isOk()) {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(new teamsfx_api_1.SystemError(error, constants_1.SolutionSource, constants_1.SolutionError.FailedToGenerateArmTemplates));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
    }
    return result;
}
exports.generateArmTemplate = generateArmTemplate;
async function generateBicep(ctx, inputs, addedPlugins, existingPlugins) {
    var _a, _b;
    let result;
    (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplateStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doGenerateBicep(ctx, inputs, addedPlugins, existingPlugins);
        if (result.isOk()) {
            (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
        }
    }
    catch (error) {
        result = teamsfx_api_1.err(new teamsfx_api_1.SystemError({
            error,
            source: constants_1.SolutionSource,
            name: constants_1.SolutionError.FailedToGenerateArmTemplates,
        }));
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.GenerateArmTemplate, result.error, ctx.telemetryReporter);
    }
    return result;
}
exports.generateBicep = generateBicep;
class DeploymentErrorMessage {
    constructor(value) {
        this.value = value;
    }
}
function getRequiredOperation(operation, deployCtx) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (((_b = (_a = operation.properties) === null || _a === void 0 ? void 0 : _a.targetResource) === null || _b === void 0 ? void 0 : _b.resourceName) &&
        ((_d = (_c = operation.properties) === null || _c === void 0 ? void 0 : _c.targetResource) === null || _d === void 0 ? void 0 : _d.id) &&
        operation.properties.provisioningState &&
        ((_e = operation.properties) === null || _e === void 0 ? void 0 : _e.timestamp) &&
        operation.properties.timestamp.getTime() > deployCtx.deploymentStartTime) {
        try {
            const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(operation.properties.targetResource.id);
            const subscriptionId = tools_1.getSubscriptionIdFromResourceId(operation.properties.targetResource.id);
            return {
                resourceName: (_g = (_f = operation.properties) === null || _f === void 0 ? void 0 : _f.targetResource) === null || _g === void 0 ? void 0 : _g.resourceName,
                resourceGroupName: resourceGroupName,
                subscriptionId: subscriptionId,
                resourceType: operation.properties.targetResource.resourceType,
                status: operation.properties.provisioningState,
            };
        }
        catch (error) {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.getRequiredOperation = getRequiredOperation;
async function pollDeploymentStatus(deployCtx) {
    var _a, _b, _c;
    let tryCount = 0;
    let previousStatus = {};
    let polledOperations = [];
    (_a = deployCtx.ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PollDeploymentStatusNotice", constants_2.PluginDisplayName.Solution));
    while (!deployCtx.finished) {
        await tools_1.waitSeconds(pollWaitSeconds);
        try {
            const operations = await deployCtx.client.deploymentOperations.list(deployCtx.resourceGroupName, deployCtx.deploymentName);
            if (deployCtx.finished) {
                return;
            }
            const currentStatus = {};
            await Promise.all(operations.map(async (o) => {
                var _a;
                const operation = getRequiredOperation(o, deployCtx);
                if (operation) {
                    currentStatus[operation.resourceName] = operation.status;
                    if (!polledOperations.includes(operation.resourceName)) {
                        polledOperations.push(operation.resourceName);
                        // get sub operations when resource type is deployments.
                        if (operation.resourceType === constants_2.ConstantString.DeploymentResourceType) {
                            let client = deployCtx.client;
                            if (operation.subscriptionId !== deployCtx.client.subscriptionId) {
                                const azureToken = await ((_a = deployCtx.ctx.azureAccountProvider) === null || _a === void 0 ? void 0 : _a.getAccountCredentialAsync());
                                client = new arm_resources_1.ResourceManagementClient(azureToken, operation.subscriptionId);
                            }
                            const subOperations = await client.deploymentOperations.list(operation.resourceGroupName, operation.resourceName);
                            subOperations.forEach((sub) => {
                                const subOperation = getRequiredOperation(sub, deployCtx);
                                if (subOperation) {
                                    currentStatus[subOperation.resourceName] = subOperation.status;
                                }
                            });
                        }
                    }
                }
            }));
            for (const key in currentStatus) {
                if (currentStatus[key] !== previousStatus[key]) {
                    (_b = deployCtx.ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(`[${constants_2.PluginDisplayName.Solution}] ${key} -> ${currentStatus[key]}`);
                }
            }
            previousStatus = currentStatus;
            polledOperations = [];
        }
        catch (error) {
            tryCount++;
            if (tryCount < maxRetryTimes) {
                (_c = deployCtx.ctx.logProvider) === null || _c === void 0 ? void 0 : _c.warning(localizeUtils_1.getLocalizedString("core.deployArmTemplates.RetryGetDeploymentStatus", deployCtx.deploymentName, tryCount));
            }
            else if (tryCount === maxRetryTimes) {
                const pollError = new teamsfx_api_1.SystemError({
                    error,
                    source: constants_1.SolutionSource,
                    name: constants_1.SolutionError.FailedToPollArmDeploymentStatus,
                });
                util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, pollError, deployCtx.ctx.telemetryReporter);
            }
        }
    }
}
exports.pollDeploymentStatus = pollDeploymentStatus;
async function doDeployArmTemplates(ctx) {
    var _a, _b, _c;
    const progressHandler = await progressHelper_1.ProgressHelper.startDeployArmTemplatesProgressHandler(ctx.ui);
    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("core.deployArmTemplates.Progress.ExecuteDeployment")));
    // update parameters
    const parameterJson = await getParameterJson(ctx);
    const resourceGroupName = (_a = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _a === void 0 ? void 0 : _a.getString(constants_1.RESOURCE_GROUP_NAME);
    if (!resourceGroupName) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, "NoResourceGroupFound", localizeUtils_1.getDefaultString("core.deployArmTemplates.FailedToReadResourceGroup"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToReadResourceGroup")));
    }
    const bicepCommand = await bicepChecker_1.ensureBicep(ctx, ctx.answers);
    // Compile bicep file to json
    const templateDir = path_1.default.join(await utils_1.getProjectTemplatesFolderPath(ctx.root), "azure");
    const bicepOrchestrationFilePath = path_1.default.join(templateDir, bicepOrchestrationFileName);
    const armTemplateJson = await compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, ctx.logProvider);
    (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.CompileBicepSuccessNotice", constants_2.PluginDisplayName.Solution));
    // deploy arm templates to azure
    const subscriptionId = (_c = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _c === void 0 ? void 0 : _c.get(constants_1.SUBSCRIPTION_ID);
    const client = await getResourceManagementClientForArmDeployment(ctx.azureAccountProvider, subscriptionId);
    const deploymentName = `${constants_2.PluginDisplayName.Solution}_deployment`.replace(" ", "_").toLowerCase();
    const deploymentParameters = {
        properties: {
            parameters: parameterJson.parameters,
            template: armTemplateJson,
            mode: "Incremental",
        },
    };
    const deployCtx = {
        ctx: ctx,
        finished: false,
        deploymentStartTime: Date.now(),
        client: client,
        resourceGroupName: resourceGroupName,
        deploymentName: deploymentName,
    };
    try {
        const result = client.deployments
            .createOrUpdate(resourceGroupName, deploymentName, deploymentParameters)
            .then((result) => {
            var _a, _b;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.SuccessNotice", constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName));
            syncArmOutput(ctx.envInfo, (_b = result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
            return result;
        })
            .finally(() => {
            deployCtx.finished = true;
        });
        await pollDeploymentStatus(deployCtx);
        await result;
        return teamsfx_api_1.ok(undefined);
    }
    catch (error) {
        // return the error if the template is invalid
        if (error.code === InvalidTemplateErrorCode) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToValidateArmTemplates,
            }));
        }
        // try to get deployment error
        const result = await wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName);
        if (result.isOk()) {
            const deploymentError = result.value;
            // return thrown error if deploymentError is empty
            if (!deploymentError) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    error,
                    source: constants_1.SolutionSource,
                    name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
                }));
            }
            const deploymentErrorObj = formattedDeploymentError(deploymentError);
            const deploymentErrorMessage = JSON.stringify(deploymentErrorObj, undefined, 2);
            let errorMessage = localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailNotice", constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName);
            errorMessage += localizeUtils_1.getLocalizedString("core.deployArmTemplates.DeploymentErrorWithHelplink", error.message, deploymentErrorMessage, constants_2.HelpLinks.ArmHelpLink);
            const notificationMessage = getNotificationMessage(deploymentError, deploymentName);
            const returnError = new teamsfx_api_1.UserError({
                source: constants_1.SolutionSource,
                message: errorMessage,
                displayMessage: notificationMessage,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
                helpLink: constants_2.HelpLinks.ArmHelpLink,
            });
            returnError.innerError = new DeploymentErrorMessage(JSON.stringify(deploymentErrorObj));
            return teamsfx_api_1.err(returnError);
        }
        else {
            return result;
        }
    }
}
exports.doDeployArmTemplates = doDeployArmTemplates;
async function doDeployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider) {
    var _a;
    const progressHandler = await progressHelper_1.ProgressHelper.startDeployArmTemplatesProgressHandler(ctx.userInteraction);
    await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(localizeUtils_1.getLocalizedString("core.deployArmTemplates.Progress.ExecuteDeployment")));
    // update parameters
    const parameterJson = await getParameterJsonV3(ctx, inputs.projectPath, envInfo);
    const envState = envInfo.state;
    const resourceGroupName = envState.solution.resourceGroupName;
    if (!resourceGroupName) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, "NoResourceGroupFound", localizeUtils_1.getDefaultString("core.deployArmTemplates.FailedToReadResourceGroup"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToReadResourceGroup")));
    }
    const bicepCommand = await bicepChecker_1.ensureBicep(ctx, inputs);
    // Compile bicep file to json
    const templateDir = path_1.default.join(await utils_1.getProjectTemplatesFolderPath(inputs.projectPath), "azure");
    const bicepOrchestrationFilePath = path_1.default.join(templateDir, bicepOrchestrationFileName);
    const armTemplateJson = await compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, ctx.logProvider);
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.CompileBicepSuccessNotice", constants_2.PluginDisplayName.Solution));
    // deploy arm templates to azure
    const client = await getResourceManagementClientForArmDeployment(azureAccountProvider, envState.solution.subscriptionId);
    const deploymentName = `${constants_2.PluginDisplayName.Solution}_deployment`.replace(" ", "_").toLowerCase();
    const deploymentParameters = {
        properties: {
            parameters: parameterJson.parameters,
            template: armTemplateJson,
            mode: "Incremental",
        },
    };
    const deployCtx = {
        ctx: ctx,
        finished: false,
        deploymentStartTime: Date.now(),
        client: client,
        resourceGroupName: resourceGroupName,
        deploymentName: deploymentName,
    };
    try {
        const result = client.deployments
            .createOrUpdate(resourceGroupName, deploymentName, deploymentParameters)
            .then((result) => {
            var _a, _b;
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.SuccessNotice", constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName));
            syncArmOutput(envInfo, (_b = result.properties) === null || _b === void 0 ? void 0 : _b.outputs);
            return result;
        })
            .finally(() => {
            deployCtx.finished = true;
        });
        await pollDeploymentStatus(deployCtx);
        await result;
        return teamsfx_api_1.ok(undefined);
    }
    catch (error) {
        // return the error if the template is invalid
        if (error.code === InvalidTemplateErrorCode) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToValidateArmTemplates,
            }));
        }
        // try to get deployment error
        const result = await wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName);
        if (result.isOk()) {
            const deploymentError = result.value;
            // return thrown error if deploymentError is empty
            if (!deploymentError) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                    error,
                    source: constants_1.SolutionSource,
                    name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
                }));
            }
            const deploymentErrorObj = formattedDeploymentError(deploymentError);
            const deploymentErrorMessage = JSON.stringify(deploymentErrorObj, undefined, 2);
            let errorMessage = localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailNotice", constants_2.PluginDisplayName.Solution, resourceGroupName, deploymentName);
            errorMessage += localizeUtils_1.getLocalizedString("core.deployArmTemplates.DeploymentErrorWithHelplink", error.message, deploymentErrorMessage, constants_2.HelpLinks.ArmHelpLink);
            const notificationMessage = getNotificationMessage(deploymentError, deploymentName);
            const returnError = new teamsfx_api_1.UserError({
                message: errorMessage,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
                helpLink: constants_2.HelpLinks.ArmHelpLink,
                displayMessage: notificationMessage,
            });
            returnError.innerError = new DeploymentErrorMessage(JSON.stringify(deploymentErrorObj));
            return teamsfx_api_1.err(returnError);
        }
        else {
            return result;
        }
    }
}
exports.doDeployArmTemplatesV3 = doDeployArmTemplatesV3;
function syncArmOutput(envInfo, armOutput) {
    var _a;
    if (armOutput instanceof Object) {
        const armOutputKeys = Object.keys(armOutput);
        for (const armOutputKey of armOutputKeys) {
            const moduleOutput = armOutput[armOutputKey].value;
            if (moduleOutput instanceof Object) {
                const moduleOutputKeys = Object.keys(moduleOutput);
                for (const moduleOutputKey of moduleOutputKeys) {
                    const pluginOutput = moduleOutput[moduleOutputKey].value;
                    if (pluginOutput instanceof Object) {
                        let pluginId = pluginOutput[constants_1.TEAMS_FX_RESOURCE_ID_KEY];
                        if (pluginId) {
                            if (core_1.isV3()) {
                                pluginId = migrate_1.pluginName2ComponentName(pluginId);
                            }
                            const pluginOutputKeys = Object.keys(pluginOutput);
                            for (const pluginOutputKey of pluginOutputKeys) {
                                if (pluginOutputKey != constants_1.TEAMS_FX_RESOURCE_ID_KEY) {
                                    if (envInfo.state instanceof Map) {
                                        (_a = envInfo.state
                                            .get(pluginId)) === null || _a === void 0 ? void 0 : _a.set(pluginOutputKey, pluginOutput[pluginOutputKey]);
                                    }
                                    else {
                                        if (!envInfo.state[pluginId])
                                            envInfo.state[pluginId] = {};
                                        envInfo.state[pluginId][pluginOutputKey] = pluginOutput[pluginOutputKey];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
async function deployArmTemplates(ctx) {
    var _a, _b, _c;
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.StartNotice", constants_2.PluginDisplayName.Solution));
    let result;
    (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeploymentStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doDeployArmTemplates(ctx);
        if (result.isOk()) {
            (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeployment, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            const errorProperties = {};
            // If the innerError is a DeploymentErrorMessage value, we will set it in telemetry.
            if (result.error.innerError && result.error.innerError instanceof DeploymentErrorMessage) {
                errorProperties[constants_1.SolutionTelemetryProperty.ArmDeploymentError] =
                    result.error.innerError.value;
            }
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter, errorProperties);
        }
    }
    catch (error) {
        if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
            result = teamsfx_api_1.err(error);
        }
        else if (error instanceof Error) {
            result = teamsfx_api_1.err(new teamsfx_api_1.SystemError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
            }));
        }
        else {
            result = teamsfx_api_1.err(new teamsfx_api_1.SystemError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
            }));
        }
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter);
    }
    await progressHelper_1.ProgressHelper.endDeployArmTemplatesProgress(result.isOk());
    return result;
}
exports.deployArmTemplates = deployArmTemplates;
async function deployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider) {
    var _a, _b, _c;
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.StartNotice", constants_2.PluginDisplayName.Solution));
    let result;
    (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeploymentStart, {
        [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
    });
    try {
        result = await doDeployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider);
        if (result.isOk()) {
            (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(constants_1.SolutionTelemetryEvent.ArmDeployment, {
                [constants_1.SolutionTelemetryProperty.Component]: constants_1.SolutionTelemetryComponentName,
                [constants_1.SolutionTelemetryProperty.Success]: constants_1.SolutionTelemetrySuccess.Yes,
            });
        }
        else {
            const errorProperties = {};
            // If the innerError is a DeploymentErrorMessage value, we will set it in telemetry.
            if (result.error.innerError && result.error.innerError instanceof DeploymentErrorMessage) {
                errorProperties[constants_1.SolutionTelemetryProperty.ArmDeploymentError] =
                    result.error.innerError.value;
            }
            util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter, errorProperties);
        }
    }
    catch (error) {
        if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
            result = teamsfx_api_1.err(error);
        }
        else if (error instanceof Error) {
            result = teamsfx_api_1.err(new teamsfx_api_1.SystemError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
            }));
        }
        else {
            result = teamsfx_api_1.err(new teamsfx_api_1.SystemError({
                error,
                source: constants_1.SolutionSource,
                name: constants_1.SolutionError.FailedToDeployArmTemplatesToAzure,
            }));
        }
        util_2.sendErrorTelemetryThenReturnError(constants_1.SolutionTelemetryEvent.ArmDeployment, result.error, ctx.telemetryReporter);
    }
    await progressHelper_1.ProgressHelper.endDeployArmTemplatesProgress(result.isOk());
    return result;
}
exports.deployArmTemplatesV3 = deployArmTemplatesV3;
async function copyParameterJson(projectPath, appName, targetEnvName, sourceEnvName) {
    var _a, _b, _c;
    if (!targetEnvName || !sourceEnvName) {
        return;
    }
    const parameterFolderPath = path_1.default.join(projectPath, configsFolder);
    const targetParameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, targetEnvName);
    const sourceParameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, sourceEnvName);
    const targetParameterFilePath = path_1.default.join(parameterFolderPath, targetParameterFileName);
    const sourceParameterFilePath = path_1.default.join(parameterFolderPath, sourceParameterFileName);
    const targetParameterContent = await fs.readJson(sourceParameterFilePath);
    if ((_c = (_b = (_a = targetParameterContent[parameterName]) === null || _a === void 0 ? void 0 : _a.provisionParameters) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.resourceBaseName) {
        targetParameterContent[parameterName].provisionParameters.value.resourceBaseName =
            generateResourceBaseName(appName, targetEnvName);
    }
    await fs.ensureDir(parameterFolderPath);
    await fs.writeFile(targetParameterFilePath, JSON.stringify(targetParameterContent, undefined, 2).replace(/\r?\n/g, os_1.default.EOL));
}
exports.copyParameterJson = copyParameterJson;
async function updateAzureParameters(projectPath, appName, envName, hasSwitchedM365Tenant, hasSwitchedSubscription, hasBotServiceCreatedBefore) {
    if (!envName ||
        !appName ||
        !projectPath ||
        (!hasSwitchedM365Tenant && !hasSwitchedSubscription) ||
        (hasSwitchedM365Tenant && !hasBotServiceCreatedBefore)) {
        return teamsfx_api_1.ok(undefined);
    }
    const parameterFolderPath = path_1.default.join(projectPath, configsFolder);
    const targetParameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envName);
    const targetParameterFilePath = path_1.default.join(parameterFolderPath, targetParameterFileName);
    try {
        const targetParameterContent = await fs.readJson(targetParameterFilePath);
        if (hasSwitchedSubscription) {
            targetParameterContent[parameterName].provisionParameters.value.resourceBaseName =
                generateResourceBaseName(appName, envName);
        }
        else if (hasSwitchedM365Tenant && hasBotServiceCreatedBefore) {
            targetParameterContent[parameterName].provisionParameters.value.botServiceName =
                generateResourceBaseName(appName, envName);
        }
        await fs.ensureDir(parameterFolderPath);
        await fs.writeFile(targetParameterFilePath, JSON.stringify(targetParameterContent, undefined, 2).replace(/\r?\n/g, os_1.default.EOL));
        return teamsfx_api_1.ok(undefined);
    }
    catch (exception) {
        const error = new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToUpdateAzureParameters, localizeUtils_1.getDefaultString("core.handleConfigFile.FailedToUpdateAzureParameters", envName), localizeUtils_1.getLocalizedString("core.handleConfigFile.FailedToUpdateAzureParameters", envName));
        return teamsfx_api_1.err(error);
    }
}
exports.updateAzureParameters = updateAzureParameters;
async function getParameterJson(ctx) {
    var _a;
    if (!ctx.envInfo.envName) {
        throw new teamsfx_api_1.SystemError("Solution", "FailedToGetEnvironmentName", localizeUtils_1.getDefaultString("core.deployArmTemplates.FailedToGetEnvironmentName"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToGetEnvironmentName"));
    }
    const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, ctx.envInfo.envName);
    const parameterFolderPath = path_1.default.join(ctx.root, configsFolder);
    const parameterFilePath = path_1.default.join(parameterFolderPath, parameterFileName);
    try {
        await fs.stat(parameterFilePath);
    }
    catch (err) {
        const error = new teamsfx_api_1.UserError(constants_1.SolutionSource, "ParameterFileNotExist", localizeUtils_1.getDefaultString("core.deployArmTemplates.ParameterNotExist", parameterFilePath), localizeUtils_1.getLocalizedString("core.deployArmTemplates.ParameterNotExist", parameterFilePath));
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(error.message);
        throw error;
    }
    const parameterJson = await getExpandedParameter(ctx, parameterFilePath); // only expand secrets in memory
    return parameterJson;
}
exports.getParameterJson = getParameterJson;
async function getParameterJsonV3(ctx, projectPath, envInfo) {
    var _a;
    if (!(envInfo === null || envInfo === void 0 ? void 0 : envInfo.envName)) {
        throw new Error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToGetEnvironmentName"));
    }
    const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName);
    const parameterFolderPath = path_1.default.join(projectPath, configsFolder);
    const parameterFilePath = path_1.default.join(parameterFolderPath, parameterFileName);
    try {
        await fs.stat(parameterFilePath);
    }
    catch (err) {
        const error = new teamsfx_api_1.UserError(constants_1.SolutionSource, "ParameterFileNotExist", localizeUtils_1.getDefaultString("core.deployArmTemplates.ParameterNotExist", parameterFilePath), localizeUtils_1.getLocalizedString("core.deployArmTemplates.ParameterNotExist", parameterFilePath));
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(error.message);
        throw error;
    }
    const parameterJson = await getExpandedParameterV3(ctx, envInfo, parameterFilePath); // only expand secrets in memory
    return parameterJson;
}
exports.getParameterJsonV3 = getParameterJsonV3;
function generateArmFromResult(result, bicepOrchestrationTemplate, pluginName, moduleProvisionFiles, moduleConfigFiles) {
    var _a, _b;
    bicepOrchestrationTemplate.applyTemplate(pluginName, result);
    if ((_a = result === null || result === void 0 ? void 0 : result.Configuration) === null || _a === void 0 ? void 0 : _a.Modules) {
        for (const module of Object.entries(result.Configuration.Modules)) {
            const moduleName = module[0];
            const moduleValue = module[1];
            moduleConfigFiles.set(generateBicepModuleConfigFilePath(moduleName), moduleValue);
        }
    }
    if ((_b = result === null || result === void 0 ? void 0 : result.Provision) === null || _b === void 0 ? void 0 : _b.Modules) {
        for (const module of Object.entries(result.Provision.Modules)) {
            const moduleName = module[0];
            const moduleValue = module[1];
            moduleProvisionFiles.set(generateBicepModuleProvisionFilePath(moduleName), moduleValue);
        }
    }
}
async function doGenerateArmTemplate(ctx, selectedPlugins) {
    var _a, _b, _c;
    const baseName = generateResourceBaseName(utils_1.convertToAlphanumericOnly(ctx.projectSettings.appName), ctx.envInfo.envName);
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p)); // This function ensures return result won't be empty
    const bicepOrchestrationTemplate = new BicepOrchestrationContent(plugins.map((p) => p.name), baseName);
    const moduleProvisionFiles = new Map();
    const moduleConfigFiles = new Map();
    // In existing app scenario, arm template will not be added when adding sso
    // Thus here if main.bicep does not exist, will try to scaffold all
    const templateFolderPath = path_1.default.join(await utils_1.getProjectTemplatesFolderPath(ctx.root), "azure");
    if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationFileName)))) {
        selectedPlugins = plugins;
    }
    // Get bicep content from each resource plugin
    for (const plugin of plugins) {
        const pluginWithArm = plugin; // Temporary solution before adding it to teamsfx-api
        const pluginContext = util_2.getPluginContext(ctx, pluginWithArm.name);
        let result;
        let errMessage = "";
        let method = "";
        if (pluginWithArm.updateArmTemplates &&
            !selectedPlugins.find((pluginItem) => pluginItem.name === pluginWithArm.name)) {
            method = "updateArmTemplates";
            result = (await pluginWithArm.updateArmTemplates(pluginContext));
            errMessage = localizeUtils_1.getLocalizedString("core.updateArmTemplate.failNotice");
        }
        else if (pluginWithArm.generateArmTemplates &&
            selectedPlugins.find((pluginItem) => pluginItem.name === pluginWithArm.name)) {
            method = "generateArmTemplates";
            result = (await pluginWithArm.generateArmTemplates(pluginContext));
            errMessage = localizeUtils_1.getLocalizedString("core.generateArmTemplate.failNotice");
        }
        else {
            continue;
        }
        if (result.isOk()) {
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PluginOperationSuccess", plugin.name, method));
            generateArmFromResult(result.value, bicepOrchestrationTemplate, pluginWithArm.name, moduleProvisionFiles, moduleConfigFiles);
        }
        else {
            const msg = util_1.format(errMessage, (_b = ctx.projectSettings) === null || _b === void 0 ? void 0 : _b.appName);
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.error(msg);
            return result;
        }
    }
    await persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, ctx.root, common_1.isVSProject(ctx.projectSettings));
    return teamsfx_api_1.ok(undefined); // Nothing to return when success
}
async function doGenerateBicep(ctx, inputs, addedPlugins, existingPlugins) {
    const baseName = generateResourceBaseName(utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName), "");
    const allPlugins = addedPlugins.concat(existingPlugins);
    const bicepOrchestrationTemplate = new BicepOrchestrationContent(allPlugins, baseName);
    const moduleProvisionFiles = new Map();
    const moduleConfigFiles = new Map();
    // generateBicep
    const addFeatureInputs = Object.assign(Object.assign({}, inputs), { allPluginsAfterAdd: allPlugins });
    for (const pluginName of addedPlugins) {
        const selectedPlugin = await typedi_1.Container.get(pluginName);
        if (!selectedPlugin.generateBicep)
            continue;
        const res = await selectedPlugin.generateBicep(ctx, addFeatureInputs);
        if (res.isErr()) {
            ctx.logProvider.error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PluginOperationFail", pluginName, "generateBicep()"));
            return teamsfx_api_1.err(res.error);
        }
        if (res.value) {
            for (const template of res.value) {
                const armTemplate = template;
                generateArmFromResult(armTemplate, bicepOrchestrationTemplate, pluginName, moduleProvisionFiles, moduleConfigFiles);
            }
        }
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PluginOperationSuccess", pluginName, "generateBicep()"));
    }
    //updateBicep
    const updateInputs = Object.assign(Object.assign({}, addFeatureInputs), { newPlugins: addedPlugins });
    for (const pluginName of existingPlugins) {
        const existingPlugin = await typedi_1.Container.get(pluginName);
        if (!existingPlugin.updateBicep)
            continue;
        const res = await existingPlugin.updateBicep(ctx, updateInputs);
        if (res.isErr()) {
            ctx.logProvider.error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PluginOperationFail", pluginName, "updateBicep()"));
            return teamsfx_api_1.err(res.error);
        }
        if (res.value) {
            for (const template of res.value) {
                const armTemplate = template;
                generateArmFromResult(armTemplate, bicepOrchestrationTemplate, pluginName, moduleProvisionFiles, moduleConfigFiles);
            }
        }
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.PluginOperationSuccess", pluginName, "updateBicep()"));
    }
    const persistRes = await persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, inputs.projectPath, common_1.isVSProject(ctx.projectSetting));
    if (persistRes.isErr()) {
        return teamsfx_api_1.err(persistRes.error);
    }
    return teamsfx_api_1.ok(undefined); // Nothing to return when success
}
async function persistBicepTemplates(bicepOrchestrationTemplate, moduleProvisionFiles, moduleConfigFiles, projectPath, isVs) {
    // Write bicep content to project folder
    if (bicepOrchestrationTemplate.needsGenerateTemplate()) {
        // Output parameter file
        const envListResult = await environment_1.environmentManager.listRemoteEnvConfigs(projectPath);
        if (envListResult.isErr()) {
            return teamsfx_api_1.err(envListResult.error);
        }
        const parameterEnvFolderPath = path_1.default.join(projectPath, configsFolder);
        await fs.ensureDir(parameterEnvFolderPath);
        for (const env of envListResult.value) {
            const parameterFileName = parameterFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, env);
            const parameterEnvFilePath = path_1.default.join(parameterEnvFolderPath, parameterFileName);
            let parameterFileContent = "";
            if (await fs.pathExists(parameterEnvFilePath)) {
                try {
                    const parameterFile = await fs.readJson(parameterEnvFilePath);
                    const parameterObj = parameterFile.parameters.provisionParameters.value;
                    const appendParam = bicepOrchestrationTemplate.getAppendedParameters();
                    const duplicateParam = Object.keys(parameterObj).filter((val) => Object.keys(appendParam).includes(val));
                    if (duplicateParam && duplicateParam.length != 0) {
                        return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                            name: constants_1.SolutionError.FailedToUpdateArmParameters,
                            source: constants_1.SolutionSource,
                            helpLink: constants_2.HelpLinks.ArmHelpLink,
                            message: localizeUtils_1.getDefaultString("core.generateArmTemplates.DuplicateParameter", parameterEnvFilePath, duplicateParam),
                            displayMessage: localizeUtils_1.getLocalizedString("core.generateArmTemplates.DuplicateParameter", parameterEnvFilePath, duplicateParam),
                        }));
                    }
                    parameterFile.parameters.provisionParameters.value = Object.assign(parameterObj, appendParam);
                    parameterFileContent = JSON.stringify(parameterFile, undefined, 2);
                }
                catch (error) {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError({
                        name: constants_1.SolutionError.FailedToUpdateArmParameters,
                        source: constants_1.SolutionSource,
                        helpLink: constants_2.HelpLinks.ArmHelpLink,
                        message: localizeUtils_1.getDefaultString("core.generateArmTemplates.InvalidParameterFile", parameterEnvFilePath, error.message),
                        displayMessage: localizeUtils_1.getLocalizedString("core.generateArmTemplates.InvalidParameterFile", parameterEnvFilePath, error.message),
                    }));
                }
            }
            else {
                parameterFileContent = bicepOrchestrationTemplate.getParameterFileContent();
            }
            await fs.writeFile(parameterEnvFilePath, parameterFileContent.replace(/\r?\n/g, os_1.default.EOL));
        }
        const templateFolderPath = path_1.default.join(await utils_1.getProjectTemplatesFolderPath(projectPath), "azure");
        await fs.ensureDir(templateFolderPath);
        const templateSolitionPath = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution");
        // Generate provision.bicep and module provision bicep files
        let bicepOrchestrationProvisionContent = "";
        if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationProvisionFileName)))) {
            bicepOrchestrationProvisionContent = await fs.readFile(path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution", "provision.bicep"), constants_2.ConstantString.UTF8Encoding);
        }
        bicepOrchestrationProvisionContent +=
            os_1.default.EOL + bicepOrchestrationTemplate.getOrchestractionProvisionContent();
        await fs.appendFile(path_1.default.join(templateFolderPath, bicepOrchestrationProvisionFileName), bicepOrchestrationProvisionContent.replace(/\r?\n/g, os_1.default.EOL));
        // Generate provision part to main.bicep files.
        if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationFileName)))) {
            await fs.copyFile(path_1.default.join(templateSolitionPath, bicepOrchestrationProvisionMainFileName), path_1.default.join(templateFolderPath, bicepOrchestrationFileName));
        }
        // Generate provision.biceps.
        await fs.ensureDir(path_1.default.join(templateFolderPath, "provision"));
        // Generate module provision bicep files
        for (const module of moduleProvisionFiles) {
            const res = bicepOrchestrationTemplate.applyReference(module[1]);
            await fs.appendFile(path_1.default.join(templateFolderPath, module[0]), res.replace(/\r?\n/g, os_1.default.EOL));
        }
        // Skip if no any config part in orchestration.
        if (bicepOrchestrationTemplate.getOrchestractionConfigContent() !== "") {
            // Generate config.bicep and module configuration bicep files.
            let bicepOrchestrationConfigContent = "";
            // Configuration Biceps.
            if (!(await fs.pathExists(path_1.default.join(templateFolderPath, bicepOrchestrationConfigFileName)))) {
                bicepOrchestrationConfigContent = await fs.readFile(path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "solution", "config.bicep"), constants_2.ConstantString.UTF8Encoding);
                const mainConfig = await fs.readFile(path_1.default.join(templateSolitionPath, bicepOrchestrationConfigMainFileName), constants_2.ConstantString.UTF8Encoding);
                await fs.appendFile(path_1.default.join(templateFolderPath, bicepOrchestrationFileName), mainConfig.replace(/\r?\n/g, os_1.default.EOL));
            }
            bicepOrchestrationConfigContent +=
                os_1.default.EOL + bicepOrchestrationTemplate.getOrchestractionConfigContent();
            await fs.appendFile(path_1.default.join(templateFolderPath, bicepOrchestrationConfigFileName), bicepOrchestrationConfigContent.replace(/\r?\n/g, os_1.default.EOL));
        }
        // Skip if no module configuration bicep update.
        if (moduleConfigFiles.size != 0) {
            await fs.ensureDir(path_1.default.join(templateFolderPath, "teamsFx"));
            for (const module of moduleConfigFiles) {
                const res = bicepOrchestrationTemplate.applyReference(module[1]);
                await fs.writeFile(path_1.default.join(templateFolderPath, module[0]), res.replace(/\r?\n/g, os_1.default.EOL));
            }
        }
    }
    return teamsfx_api_1.ok(undefined);
}
async function getExpandedParameter(ctx, filePath) {
    var _a;
    try {
        const parameterTemplate = await fs.readFile(filePath, constants_2.ConstantString.UTF8Encoding);
        const parameterJsonString = expandParameterPlaceholders(ctx, parameterTemplate);
        return JSON.parse(parameterJsonString);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToExpandParameter", filePath));
        throw err;
    }
}
async function getExpandedParameterV3(ctx, envInfo, filePath) {
    var _a;
    try {
        const parameterTemplate = await fs.readFile(filePath, constants_2.ConstantString.UTF8Encoding);
        const parameterJsonString = expandParameterPlaceholdersV3(ctx, envInfo, parameterTemplate);
        return JSON.parse(parameterJsonString);
    }
    catch (err) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToExpandParameter", filePath));
        throw err;
    }
}
async function getResourceManagementClientForArmDeployment(azureAccountProvider, subscriptionId) {
    const azureToken = await azureAccountProvider.getAccountCredentialAsync();
    if (!azureToken) {
        throw new teamsfx_api_1.SystemError(constants_2.PluginDisplayName.Solution, constants_1.SolutionError.FailedToGetAzureCredential, localizeUtils_1.getDefaultString("core.deployArmTemplates.InvalidAzureCredential"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.InvalidAzureCredential"));
    }
    if (!subscriptionId) {
        throw new teamsfx_api_1.SystemError(constants_2.PluginDisplayName.Solution, constants_1.SolutionError.NoSubscriptionSelected, localizeUtils_1.getDefaultString("core.deployArmTemplates.FailedToGetSubsId"), localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToGetSubsId"));
    }
    return new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
}
async function compileBicepToJson(bicepCommand, bicepOrchestrationFilePath, logger) {
    try {
        const result = await cpUtils_1.executeCommand(bicepCommand, ["build", bicepOrchestrationFilePath, "--stdout"], logger, { shell: false });
        return JSON.parse(result);
    }
    catch (err) {
        throw new Error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.CompileBicepFailed", err.message));
    }
}
// Context used by handlebars to render the main.bicep file
class ArmTemplateRenderContext {
    constructor(pluginNames) {
        this.Plugins = {};
        for (const plugin of pluginNames) {
            this.Plugins[plugin] = {};
        }
    }
    addPluginOutput(pluginName, armResult) {
        var _a, _b;
        const PluginContext = {
            Provision: {},
            Configuration: {},
            References: {},
        };
        const provision = (_a = armResult === null || armResult === void 0 ? void 0 : armResult.Provision) === null || _a === void 0 ? void 0 : _a.Modules;
        const references = armResult === null || armResult === void 0 ? void 0 : armResult.Reference;
        const configs = (_b = armResult === null || armResult === void 0 ? void 0 : armResult.Configuration) === null || _b === void 0 ? void 0 : _b.Modules;
        if (provision) {
            for (const module of Object.entries(provision)) {
                const moduleFileName = module[0];
                PluginContext.Provision[moduleFileName] = {
                    path: generateBicepModuleProvisionFilePath(moduleFileName),
                };
            }
        }
        if (configs) {
            for (const module of Object.entries(configs)) {
                const moduleFileName = module[0];
                PluginContext.Configuration[moduleFileName] = {
                    path: generateBicepModuleConfigFilePath(moduleFileName),
                };
            }
        }
        if (references) {
            for (const output of Object.entries(references)) {
                const outputKey = output[0];
                const outputValue = output[1];
                PluginContext.References[outputKey] = outputValue;
            }
        }
        this.Plugins[pluginName] = PluginContext;
    }
}
exports.ArmTemplateRenderContext = ArmTemplateRenderContext;
// Stores the bicep orchestration information for all resource plugins
class BicepOrchestrationContent {
    constructor(pluginNames, baseName) {
        this.ParameterJsonTemplate = {};
        this.TemplateAdded = false;
        this.ProvisionTemplate = "";
        this.ConfigTemplate = "";
        this.ParameterJsonTemplate[resourceBaseName] = baseName;
        this.RenderContext = new ArmTemplateRenderContext(pluginNames);
    }
    applyTemplate(pluginName, armResult) {
        var _a, _b;
        this.ProvisionTemplate += this.normalizeTemplateSnippet((_a = armResult === null || armResult === void 0 ? void 0 : armResult.Provision) === null || _a === void 0 ? void 0 : _a.Orchestration);
        this.ConfigTemplate += this.normalizeTemplateSnippet((_b = armResult === null || armResult === void 0 ? void 0 : armResult.Configuration) === null || _b === void 0 ? void 0 : _b.Orchestration);
        this.RenderContext.addPluginOutput(pluginName, armResult);
        Object.assign(this.ParameterJsonTemplate, armResult === null || armResult === void 0 ? void 0 : armResult.Parameters);
        if ((armResult === null || armResult === void 0 ? void 0 : armResult.Parameters) && Object.keys(armResult === null || armResult === void 0 ? void 0 : armResult.Parameters).length > 0)
            this.TemplateAdded = true;
    }
    applyReference(configContent) {
        return common_1.compileHandlebarsTemplateString(configContent, this.RenderContext.Plugins);
    }
    getOrchestractionProvisionContent() {
        const orchestrationTemplate = this.normalizeTemplateSnippet(this.ProvisionTemplate, false) + os_1.default.EOL;
        return common_1.compileHandlebarsTemplateString(orchestrationTemplate, this.RenderContext.Plugins).trim();
    }
    getOrchestractionConfigContent() {
        const orchestrationTemplate = this.normalizeTemplateSnippet(this.ConfigTemplate, false) + os_1.default.EOL;
        return common_1.compileHandlebarsTemplateString(orchestrationTemplate, this.RenderContext.Plugins).trim();
    }
    getParameterFileContent() {
        const parameterObject = {
            $schema: "https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#",
            contentVersion: "1.0.0.0",
            parameters: { provisionParameters: { value: this.ParameterJsonTemplate } },
        };
        return JSON.stringify(parameterObject, undefined, 2);
    }
    getAppendedParameters() {
        const res = this.ParameterJsonTemplate;
        if (res.resourceBaseName) {
            delete res.resourceBaseName;
        }
        return res;
    }
    needsGenerateTemplate() {
        return this.TemplateAdded;
    }
    normalizeTemplateSnippet(snippet, updateTemplateChangeFlag = true) {
        if (snippet) {
            if (updateTemplateChangeFlag) {
                this.TemplateAdded = true;
            }
            return snippet.trim() + os_1.default.EOL;
        }
        return "";
    }
}
function generateBicepModuleProvisionFilePath(moduleFileName) {
    return `./provision/${moduleFileName}.bicep`;
}
function generateBicepModuleConfigFilePath(moduleFileName) {
    return `./teamsFx/${moduleFileName}.bicep`;
}
function expandParameterPlaceholders(ctx, parameterContent) {
    const plugins = ResourcePluginContainer_1.getActivatedV2ResourcePlugins(ctx.projectSettings).map((p) => new adaptor_1.NamedArmResourcePluginAdaptor(p)); // This function ensures return result won't be empty
    const stateVariables = {};
    const availableVariables = { state: stateVariables };
    // Add plugin contexts to available variables
    for (const plugin of plugins) {
        const pluginContext = util_2.getPluginContext(ctx, plugin.name);
        const pluginVariables = {};
        for (const configItem of pluginContext.config) {
            if (typeof configItem[1] === "string") {
                // Currently we only config with string type
                pluginVariables[configItem[0]] = configItem[1];
            }
        }
        stateVariables[plugin.name] = pluginVariables;
    }
    // Add solution config to available variables
    const solutionConfig = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG);
    if (solutionConfig) {
        const solutionVariables = {};
        for (const configItem of solutionConfig) {
            if (typeof configItem[1] === "string") {
                // Currently we only config with string type
                solutionVariables[configItem[0]] = configItem[1];
            }
        }
        stateVariables[solutionName] = solutionVariables;
    }
    // Add environment variable to available variables
    const processVariables = Object.keys(process.env).reduce((obj, key) => {
        obj[key] = process.env[key];
        return obj;
    }, {});
    availableVariables["$env"] = processVariables;
    return common_1.compileHandlebarsTemplateString(parameterContent, availableVariables);
}
function expandParameterPlaceholdersV3(ctx, envInfo, parameterContent) {
    const projectSettingsV3 = ctx.projectSetting;
    const componentNames = projectSettingsV3.components.map((c) => c.name);
    const stateVariables = {};
    const availableVariables = { state: stateVariables };
    const envState = envInfo.state;
    // Add plugin contexts to available variables
    for (const componentName of componentNames) {
        const resourceState = envState[componentName] || {};
        // const pluginContext = getPluginContext(ctx, plugin.name);
        const pluginVariables = {};
        for (const key of Object.keys(resourceState)) {
            if (typeof resourceState[key] === "string") {
                // Currently we only config with string type
                pluginVariables[key] = resourceState[key];
            }
        }
        stateVariables[componentName] = pluginVariables;
    }
    // Add solution config to available variables
    const solutionConfig = envState.solution;
    if (solutionConfig) {
        const solutionVariables = {};
        for (const key of Object.keys(solutionConfig)) {
            if (typeof solutionConfig[key] === "string") {
                // Currently we only config with string type
                solutionVariables[key] = solutionConfig[key];
            }
        }
        stateVariables[solutionName] = solutionVariables;
    }
    // Add environment variable to available variables
    const processVariables = Object.keys(process.env).reduce((obj, key) => {
        obj[key] = process.env[key];
        return obj;
    }, {});
    availableVariables["$env"] = processVariables;
    parameterContent = migrate_1.convertManifestTemplateToV3(parameterContent);
    return common_1.compileHandlebarsTemplateString(parameterContent, availableVariables);
}
function generateResourceBaseName(appName, envName) {
    const maxAppNameLength = 10;
    const maxEnvNameLength = 4;
    const normalizedAppName = appName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    const normalizedEnvName = envName.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
    return (normalizedAppName.substr(0, maxAppNameLength) +
        normalizedEnvName.substr(0, maxEnvNameLength) +
        tools_1.getUuid().substr(0, 6));
}
exports.generateResourceBaseName = generateResourceBaseName;
async function wrapGetDeploymentError(deployCtx, resourceGroupName, deploymentName) {
    var _a;
    try {
        const deploymentError = await getDeploymentError(deployCtx, resourceGroupName, deploymentName);
        return teamsfx_api_1.ok(deploymentError);
    }
    catch (error) {
        (_a = deployCtx.ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToGetDeploymentError", error.message));
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, "GetDeploymentErrorFailed", localizeUtils_1.getDefaultString("core.deployArmTemplates.FailedToGetDeploymentErrorNotification", deployCtx.deploymentName, deployCtx.resourceGroupName), localizeUtils_1.getLocalizedString("core.deployArmTemplates.FailedToGetDeploymentErrorNotification", deployCtx.deploymentName, deployCtx.resourceGroupName)));
    }
}
exports.wrapGetDeploymentError = wrapGetDeploymentError;
async function getDeploymentError(deployCtx, resourceGroupName, deploymentName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let deployment;
    try {
        deployment = await deployCtx.client.deployments.get(resourceGroupName, deploymentName);
    }
    catch (error) {
        if (deploymentName !== deployCtx.deploymentName &&
            error.code === constants_2.ConstantString.DeploymentNotFound) {
            return undefined;
        }
        throw error;
    }
    // The root deployment error name is deployCtx.deploymentName.
    // If we find the root error has a timestamp less than startTime, it is an old error to be ignored.
    // Other erros will be ignored as well.
    if (deploymentName === deployCtx.deploymentName &&
        ((_a = deployment.properties) === null || _a === void 0 ? void 0 : _a.timestamp) &&
        deployment.properties.timestamp.getTime() < deployCtx.deploymentStartTime) {
        return undefined;
    }
    if (!((_b = deployment.properties) === null || _b === void 0 ? void 0 : _b.error)) {
        return undefined;
    }
    const deploymentError = {
        error: (_c = deployment.properties) === null || _c === void 0 ? void 0 : _c.error,
    };
    const operations = await deployCtx.client.deploymentOperations.list(resourceGroupName, deploymentName);
    for (const operation of operations) {
        if ((_e = (_d = operation.properties) === null || _d === void 0 ? void 0 : _d.statusMessage) === null || _e === void 0 ? void 0 : _e.error) {
            if (!deploymentError.subErrors) {
                deploymentError.subErrors = {};
            }
            const name = (_g = (_f = operation.properties.targetResource) === null || _f === void 0 ? void 0 : _f.resourceName) !== null && _g !== void 0 ? _g : operation.id;
            deploymentError.subErrors[name] = {
                error: operation.properties.statusMessage.error,
            };
            if (((_h = operation.properties.targetResource) === null || _h === void 0 ? void 0 : _h.resourceType) ===
                constants_2.ConstantString.DeploymentResourceType &&
                ((_j = operation.properties.targetResource) === null || _j === void 0 ? void 0 : _j.resourceName) &&
                ((_k = operation.properties.targetResource) === null || _k === void 0 ? void 0 : _k.id)) {
                const resourceGroupName = tools_1.getResourceGroupNameFromResourceId(operation.properties.targetResource.id);
                const subError = await getDeploymentError(deployCtx, resourceGroupName, (_l = operation.properties.targetResource) === null || _l === void 0 ? void 0 : _l.resourceName);
                if (subError) {
                    deploymentError.subErrors[name].inner = subError;
                }
            }
        }
    }
    return deploymentError;
}
function getNotificationMessage(deploymentError, deploymentName) {
    let failedDeployments = [];
    if (deploymentError.subErrors) {
        failedDeployments = Object.keys(deploymentError.subErrors);
    }
    else {
        failedDeployments.push(deploymentName);
    }
    const format = failedDeployments.map((deployment) => deployment + " module");
    return localizeUtils_1.getLocalizedString("core.deployArmTemplates.DeploymentFailedNotification", format.join(", "));
}
function formattedDeploymentError(deploymentError) {
    var _a, _b, _c;
    if (deploymentError.subErrors) {
        const result = {};
        for (const key in deploymentError.subErrors) {
            const subError = deploymentError.subErrors[key];
            if (subError.inner) {
                result[key] = formattedDeploymentError(subError.inner);
            }
            else {
                const needFilter = ((_b = (_a = subError.error) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes("Template output evaluation skipped")) &&
                    ((_c = subError.error) === null || _c === void 0 ? void 0 : _c.code) === "DeploymentOperationFailed";
                if (!needFilter) {
                    result[key] = subError.error;
                }
            }
        }
        return result;
    }
    else {
        return deploymentError.error;
    }
}
exports.formattedDeploymentError = formattedDeploymentError;
class ArmV2 {
    async generateArmTemplate(ctx, selectedPlugins = []) {
        return generateArmTemplate(ctx, selectedPlugins);
    }
    async deployArmTemplates(ctx) {
        return deployArmTemplates(ctx);
    }
}
class Arm {
    async generateBicep(ctx, inputs, addedPlugins, existingPlugins) {
        return generateBicep(ctx, inputs, addedPlugins, existingPlugins);
    }
    async deployArmTemplates(ctx, inputs, envInfo, azureAccountProvider) {
        return deployArmTemplatesV3(ctx, inputs, envInfo, azureAccountProvider);
    }
}
const arm = new Arm();
exports.armV2 = new ArmV2();
exports.default = arm;
//# sourceMappingURL=arm.js.map