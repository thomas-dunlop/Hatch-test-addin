import { AzureSolutionSettings, Func, FxError, Plugin, QTreeNode, Result, Solution, SolutionContext, Stage } from "@microsoft/teamsfx-api";
import { ListCollaboratorResult, PermissionsResult } from "../../../common/permissionInterface";
import { Void } from "./constants";
import { AppStudioPlugin } from "../../resource/appstudio";
import { LoadedPlugin, SolutionRunningState } from "./types";
export declare class TeamsAppSolution implements Solution {
    SpfxPlugin: Plugin;
    AppStudioPlugin: AppStudioPlugin;
    BotPlugin: Plugin;
    AadPlugin: Plugin;
    FrontendPlugin: Plugin;
    FunctionPlugin: Plugin;
    SqlPlugin: Plugin;
    ApimPlugin: Plugin;
    KeyVaultPlugin: Plugin;
    LocalDebugPlugin: Plugin;
    CICDPlugin: Plugin;
    name: string;
    runningState: SolutionRunningState;
    constructor();
    private getPluginAndContextArray;
    init(ctx: SolutionContext): Promise<Result<any, FxError>>;
    assertSettingsNotEmpty<T>(settings: T | undefined, key: string): Result<T, FxError>;
    /**
     * create
     */
    create(ctx: SolutionContext): Promise<Result<any, FxError>>;
    reloadPlugins(solutionSettings: AzureSolutionSettings): Plugin[];
    private spfxSelected;
    private isAzureProject;
    update(ctx: SolutionContext): Promise<Result<any, FxError>>;
    private getSelectedPlugins;
    /**
     * scaffold
     */
    scaffold(ctx: SolutionContext): Promise<Result<any, FxError>>;
    doScaffold(ctx: SolutionContext, pluginsToScaffold: LoadedPlugin[], generateResourceTemplate: boolean, pluginsToDoArm?: LoadedPlugin[]): Promise<Result<any, FxError>>;
    createEnv(ctx: SolutionContext): Promise<Result<any, FxError>>;
    /**
     * Checks whether solution's state is idle
     */
    private checkWhetherSolutionIsIdle;
    private checkWetherProvisionSucceeded;
    /**
     * Provision resources. It can only run in a non-SPFx project when solution's running state is Idle.
     * Solution's provisionSucceeded config value will be set to true if provision succeeds, to false otherwise.
     *
     */
    provision(ctx: SolutionContext): Promise<Result<any, FxError>>;
    /**
     * provision
     */
    doProvision(ctx: SolutionContext): Promise<Result<any, FxError>>;
    deploy(ctx: SolutionContext): Promise<Result<any, FxError>>;
    /**
     * deploy
     */
    private doDeploy;
    publish(ctx: SolutionContext): Promise<Result<any, FxError>>;
    getTabScaffoldQuestions(ctx: SolutionContext, addAzureResource: boolean): Promise<Result<QTreeNode | undefined, FxError>>;
    /**
     * collect solution level question
     * @param ctx
     */
    getQuestions(stage: Stage, ctx: SolutionContext): Promise<Result<QTreeNode | undefined, FxError>>;
    localDebug(ctx: SolutionContext): Promise<Result<any, FxError>>;
    doLocalDebug(ctx: SolutionContext): Promise<Result<any, FxError>>;
    grantPermission(ctx: SolutionContext): Promise<Result<PermissionsResult, FxError>>;
    checkPermission(ctx: SolutionContext): Promise<Result<PermissionsResult, FxError>>;
    listCollaborator(ctx: SolutionContext): Promise<Result<ListCollaboratorResult, FxError>>;
    private loadTeamsAppTenantId;
    getAzureSolutionSettings(ctx: SolutionContext): AzureSolutionSettings;
    getQuestionsForAddResource(func: Func, ctx: SolutionContext): Promise<Result<QTreeNode | undefined, FxError>>;
    getQuestionsForAddCapability(ctx: SolutionContext): Promise<Result<QTreeNode | undefined, FxError>>;
    /**
     * user questions for customized task
     */
    getQuestionsForUserTask(func: Func, ctx: SolutionContext): Promise<Result<QTreeNode | undefined, FxError>>;
    executeAddResource(ctx: SolutionContext): Promise<Result<any, FxError>>;
    executeAddCapability(ctx: SolutionContext): Promise<Result<any, FxError>>;
    /**
     * execute user task
     */
    executeUserTask(func: Func, ctx: SolutionContext): Promise<Result<any, FxError>>;
    private prepareConfigForRegisterTeamsAppAndAad;
    private extractConfigForRegisterTeamsAppAndAad;
    /**
     * This function is only called by cli: teamsfx init. The context may be different from that of vsc: no .${ConfigFolderName} folder, no permissions.json
     * In order to reuse aad plugin, we need to pretend we are still in vsc context. Currently, we don't support icons, because icons are not included in the
     * current contract.
     */
    private registerTeamsAppAndAad;
}
export declare function askForProvisionConsent(ctx: SolutionContext): Promise<Result<Void, FxError>>;
//# sourceMappingURL=solution.d.ts.map