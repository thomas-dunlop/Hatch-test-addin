"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkResourceGroupExistence = exports.createNewResourceGroup = exports.fillInCommonQuestions = exports.getResourceGroupInfo = exports.askResourceGroupInfo = exports.checkM365Tenant = exports.checkSubscription = exports.CommonQuestions = exports.DefaultResourceGroupLocation = void 0;
/* eslint-disable @typescript-eslint/ban-types */
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("./constants");
const uuid_1 = require("uuid");
const arm_resources_1 = require("@azure/arm-resources");
const arm_subscriptions_1 = require("@azure/arm-subscriptions");
const constants_2 = require("../../../common/constants");
const question_1 = require("../../../core/question");
const tools_1 = require("../../../common/tools");
const questionModel_1 = require("../../../core/middleware/questionModel");
const constants_3 = require("../../resource/localdebug/constants");
const telemetry_1 = require("../../../common/telemetry");
const ms_rest_js_1 = require("@azure/ms-rest-js");
const localizeUtils_1 = require("../../../common/localizeUtils");
const MsResources = "Microsoft.Resources";
const ResourceGroups = "resourceGroups";
exports.DefaultResourceGroupLocation = "East US";
// TODO: use the emoji plus sign like Azure Functions extension
const newResourceGroupOption = "+ New resource group";
class CommonQuestions {
    constructor() {
        this.needCreateResourceGroup = true;
        this.resourceNameSuffix = "";
        this.resourceGroupName = "";
        this.tenantId = "";
        this.subscriptionId = "";
        this.subscriptionName = "";
        // default to East US for now
        this.location = "East US";
        this.teamsAppTenantId = "";
    }
}
exports.CommonQuestions = CommonQuestions;
/**
 * make sure subscription is correct
 *
 */
async function checkSubscription(envInfo, azureAccountProvider) {
    var _a, _b, _c, _d, _e;
    const subscriptionId = envInfo.version === 1
        ? (_b = (_a = envInfo.data.state) === null || _a === void 0 ? void 0 : _a.get(constants_1.PluginNames.SOLUTION)) === null || _b === void 0 ? void 0 : _b.get(constants_1.SUBSCRIPTION_ID)
        : envInfo.data.state[constants_1.PluginNames.SOLUTION][constants_1.SUBSCRIPTION_ID];
    if (!subscriptionId) {
        const askSubRes = await azureAccountProvider.getSelectedSubscription(true);
        return teamsfx_api_1.ok(askSubRes);
    }
    let subscriptionName = (_e = (envInfo.version === 1
        ? (_d = (_c = envInfo.data.state) === null || _c === void 0 ? void 0 : _c.get(constants_1.PluginNames.SOLUTION)) === null || _d === void 0 ? void 0 : _d.get(constants_1.SUBSCRIPTION_NAME)
        : envInfo.data.state[constants_1.PluginNames.SOLUTION][constants_1.SUBSCRIPTION_NAME])) !== null && _e !== void 0 ? _e : "";
    if (subscriptionName.length > 0) {
        subscriptionName = `(${subscriptionName})`;
    }
    // make sure the user is logged in
    await azureAccountProvider.getAccountCredentialAsync(true);
    // verify valid subscription (permission)
    const subscriptions = await azureAccountProvider.listSubscriptions();
    const targetSubInfo = subscriptions.find((item) => item.subscriptionId === subscriptionId);
    if (!targetSubInfo) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.SubscriptionNotFound, `The subscription '${subscriptionId}'${subscriptionName} for '${envInfo.data.envName}' environment is not found in the current account, please use the right Azure account or check the '${teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.data.envName)}' file.`));
    }
    return teamsfx_api_1.ok(targetSubInfo);
}
exports.checkSubscription = checkSubscription;
/**
 * check m365 tenant is right
 *
 */
async function checkM365Tenant(envInfo, appStudioJson) {
    var _a, _b;
    const m365TenantId = envInfo.version === 1
        ? (_b = (_a = envInfo.data.state) === null || _a === void 0 ? void 0 : _a.get(constants_1.PluginNames.SOLUTION)) === null || _b === void 0 ? void 0 : _b.get(constants_3.SolutionPlugin.TeamsAppTenantId)
        : envInfo.data.state[constants_1.PluginNames.SOLUTION][constants_3.SolutionPlugin.TeamsAppTenantId];
    if (!m365TenantId) {
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    if (appStudioJson.tid && appStudioJson.tid != m365TenantId) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError("Solution", constants_1.SolutionError.TeamsAppTenantIdNotRight, localizeUtils_1.getLocalizedString("error.M365AccountNotMatch", envInfo.data.envName)));
    }
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.checkM365Tenant = checkM365Tenant;
async function getQuestionsForResourceGroup(defaultResourceGroupName, existingResourceGroupNameLocations, availableLocations, rmClient) {
    const selectResourceGroup = question_1.QuestionSelectResourceGroup;
    const staticOptions = [
        { id: newResourceGroupOption, label: newResourceGroupOption },
    ];
    selectResourceGroup.staticOptions = staticOptions.concat(existingResourceGroupNameLocations.map((item) => {
        return {
            id: item[0],
            label: item[0],
            description: item[1],
        };
    }));
    const node = new teamsfx_api_1.QTreeNode(selectResourceGroup);
    const inputNewResourceGroupName = question_1.newResourceGroupNameQuestion(rmClient);
    inputNewResourceGroupName.default = defaultResourceGroupName;
    const newResourceGroupNameNode = new teamsfx_api_1.QTreeNode(inputNewResourceGroupName);
    newResourceGroupNameNode.condition = { equals: newResourceGroupOption };
    node.addChild(newResourceGroupNameNode);
    const selectLocation = question_1.QuestionNewResourceGroupLocation;
    // TODO: maybe lazily load locations
    selectLocation.staticOptions = availableLocations;
    const newResourceGroupLocationNode = new teamsfx_api_1.QTreeNode(selectLocation);
    newResourceGroupNameNode.addChild(newResourceGroupLocationNode);
    return node.trim();
}
/**
 * Ask user to create a new resource group or use an exsiting resource group
 */
async function askResourceGroupInfo(ctx, azureAccountProvider, rmClient, inputs, ui, defaultResourceGroupName) {
    var _a, _b, _c;
    // TODO: support pagination
    let resourceGroupResults;
    try {
        resourceGroupResults = await rmClient.resourceGroups.list();
    }
    catch (error) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`Failed to list resource group: error '${error}'`);
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.FailedToListResourceGroup, "Failed to list resource group"));
    }
    const resourceGroupNameLocations = resourceGroupResults
        .filter((item) => item.name)
        .map((item) => [item.name, item.location]);
    const locations = await getLocations(azureAccountProvider, rmClient);
    if (locations.isErr()) {
        return teamsfx_api_1.err(locations.error);
    }
    const node = await getQuestionsForResourceGroup(defaultResourceGroupName, resourceGroupNameLocations, locations.value, rmClient);
    if (node) {
        const res = await teamsfx_api_1.traverse(node, inputs, ui);
        if (res.isErr()) {
            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.debug(`[${constants_2.PluginDisplayName.Solution}] failed to run question model for target resource group.`);
            return teamsfx_api_1.err(res.error);
        }
        const desensitized = questionModel_1.desensitize(node, inputs);
        (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`[${constants_2.PluginDisplayName.Solution}] success to run question model for resource group, answers:${JSON.stringify(desensitized)}`);
    }
    const resourceGroupName = inputs.targetResourceGroupName;
    if (resourceGroupName === newResourceGroupOption) {
        return teamsfx_api_1.ok({
            name: inputs[question_1.CoreQuestionNames.NewResourceGroupName],
            location: inputs[question_1.CoreQuestionNames.NewResourceGroupLocation],
            createNewResourceGroup: true,
        });
    }
    else {
        const targetResourceGroupName = inputs.targetResourceGroupName;
        if (typeof targetResourceGroupName !== "string") {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.FailedToListResourceGroup, "Failed to get user input for resource group info"));
        }
        const target = resourceGroupNameLocations.find((item) => item[0] == targetResourceGroupName);
        const location = target[1]; // location must exist because the user can only select from this list.
        return teamsfx_api_1.ok({
            createNewResourceGroup: false,
            name: targetResourceGroupName,
            location: location,
        });
    }
}
exports.askResourceGroupInfo = askResourceGroupInfo;
async function getLocations(azureAccountProvider, rmClient) {
    var _a;
    const credential = await azureAccountProvider.getAccountCredentialAsync();
    let subscriptionClient = undefined;
    if (credential) {
        subscriptionClient = new arm_subscriptions_1.SubscriptionClient(credential);
    }
    else {
        throw new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToGetAzureCredential, "Failed to get azure credential");
    }
    const askSubRes = await azureAccountProvider.getSelectedSubscription(true);
    const listLocations = await subscriptionClient.subscriptions.listLocations(askSubRes.subscriptionId);
    const locations = listLocations.map((item) => item.displayName);
    const providerData = await rmClient.providers.get(MsResources);
    const resourceTypeData = (_a = providerData.resourceTypes) === null || _a === void 0 ? void 0 : _a.find((rt) => { var _a; return ((_a = rt.resourceType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ResourceGroups.toLowerCase(); });
    const resourceLocations = resourceTypeData === null || resourceTypeData === void 0 ? void 0 : resourceTypeData.locations;
    const rgLocations = resourceLocations === null || resourceLocations === void 0 ? void 0 : resourceLocations.filter((item) => locations.includes(item));
    if (!rgLocations || rgLocations.length == 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToListResourceGroupLocation, "Failed to list resource group locations"));
    }
    return teamsfx_api_1.ok(rgLocations);
}
async function getResourceGroupInfo(ctx, rmClient, resourceGroupName) {
    var _a;
    try {
        const getRes = await rmClient.resourceGroups.get(resourceGroupName);
        if (getRes.name) {
            return {
                createNewResourceGroup: false,
                name: getRes.name,
                location: getRes.location,
            };
        }
    }
    catch (error) {
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(`[${constants_2.PluginDisplayName.Solution}] failed to get resource group '${resourceGroupName}'. error = '${error}'`);
    }
    return undefined;
}
exports.getResourceGroupInfo = getResourceGroupInfo;
/**
 * Asks common questions and puts the answers in the global namespace of SolutionConfig
 *
 */
async function askCommonQuestions(ctx, appName, config, azureAccountProvider, appstudioTokenJson) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    if (!azureAccountProvider) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", constants_1.SolutionError.InternelError, "azureAccountProvider is undefined"));
    }
    const commonQuestions = new CommonQuestions();
    //1. check subscriptionId
    const subscriptionResult = await checkSubscription({ version: 1, data: ctx.envInfo }, azureAccountProvider);
    if (subscriptionResult.isErr()) {
        return teamsfx_api_1.err(subscriptionResult.error);
    }
    const subscriptionId = subscriptionResult.value.subscriptionId;
    commonQuestions.subscriptionId = subscriptionId;
    commonQuestions.subscriptionName = subscriptionResult.value.subscriptionName;
    commonQuestions.tenantId = subscriptionResult.value.tenantId;
    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions, step 1 - check subscriptionId pass!`);
    // Note setSubscription here will change the token returned by getAccountCredentialAsync according to the subscription selected.
    // So getting azureToken needs to precede setSubscription.
    const azureToken = await (azureAccountProvider === null || azureAccountProvider === void 0 ? void 0 : azureAccountProvider.getAccountCredentialAsync());
    if (azureToken === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.NotLoginToAzure, "Login to Azure using the Azure Account extension"));
    }
    //2. check resource group
    (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroupStart, ((_c = ctx.answers) === null || _c === void 0 ? void 0 : _c.env) ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(ctx.answers.env) } : {});
    const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
    // Resource group info precedence are:
    //   1. ctx.answers, for CLI --resource-group argument, only support existing resource group
    //   2. env config (config.{envName}.json), for user customization, only support existing resource group
    //   3. states (state.{envName}.json), for reprovision
    //   4. asking user with a popup
    const resourceGroupNameFromEnvConfig = (_d = ctx.envInfo.config.azure) === null || _d === void 0 ? void 0 : _d.resourceGroupName;
    const resourceGroupNameFromState = (_e = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _e === void 0 ? void 0 : _e.get(constants_1.RESOURCE_GROUP_NAME);
    const resourceGroupLocationFromState = (_f = ctx.envInfo.state.get(constants_1.GLOBAL_CONFIG)) === null || _f === void 0 ? void 0 : _f.get(constants_1.LOCATION);
    const defaultResourceGroupName = `${appName.replace(" ", "_")}-${ctx.envInfo.envName}-rg`;
    let resourceGroupInfo;
    const telemetryProperties = {};
    if ((_g = ctx.answers) === null || _g === void 0 ? void 0 : _g.env) {
        telemetryProperties[telemetry_1.TelemetryProperty.Env] = tools_1.getHashedEnv(ctx.answers.env);
    }
    if ((_h = ctx.answers) === null || _h === void 0 ? void 0 : _h.targetResourceGroupName) {
        const maybeResourceGroupInfo = await getResourceGroupInfo(ctx, rmClient, ctx.answers.targetResourceGroupName);
        if (!maybeResourceGroupInfo) {
            // Currently we do not support creating resource group from command line arguments
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.ResourceGroupNotFound, localizeUtils_1.getDefaultString("error.ResourceGroupNotFound1", (_j = ctx.answers) === null || _j === void 0 ? void 0 : _j.targetResourceGroupName), localizeUtils_1.getLocalizedString("error.ResourceGroupNotFound1", (_k = ctx.answers) === null || _k === void 0 ? void 0 : _k.targetResourceGroupName)));
        }
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.CommandLine;
        resourceGroupInfo = maybeResourceGroupInfo;
    }
    else if (resourceGroupNameFromEnvConfig) {
        const resourceGroupName = resourceGroupNameFromEnvConfig;
        const maybeResourceGroupInfo = await getResourceGroupInfo(ctx, rmClient, resourceGroupName);
        if (!maybeResourceGroupInfo) {
            // Currently we do not support creating resource group by input config, so just throw an error.
            const envFile = teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, ctx.envInfo.envName);
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.ResourceGroupNotFound, localizeUtils_1.getDefaultString("error.ResourceGroupNotFound2", resourceGroupName, envFile), localizeUtils_1.getLocalizedString("error.ResourceGroupNotFound2", resourceGroupName, envFile)));
        }
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.EnvConfig;
        resourceGroupInfo = maybeResourceGroupInfo;
    }
    else if (resourceGroupNameFromState && resourceGroupLocationFromState) {
        const maybeExist = await checkResourceGroupExistence(rmClient, resourceGroupNameFromState, subscriptionResult.value.subscriptionId, subscriptionResult.value.subscriptionName);
        if (maybeExist.isErr()) {
            return teamsfx_api_1.err(maybeExist.error);
        }
        const exist = maybeExist.value;
        resourceGroupInfo = {
            createNewResourceGroup: !exist,
            name: resourceGroupNameFromState,
            location: resourceGroupLocationFromState,
        };
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.EnvState;
    }
    else if (ctx.answers && ctx.ui) {
        const resourceGroupInfoResult = await askResourceGroupInfo(ctx, ctx.azureAccountProvider, rmClient, ctx.answers, ctx.ui, defaultResourceGroupName);
        if (resourceGroupInfoResult.isErr()) {
            return teamsfx_api_1.err(resourceGroupInfoResult.error);
        }
        resourceGroupInfo = resourceGroupInfoResult.value;
        if (resourceGroupInfo.createNewResourceGroup) {
            if (resourceGroupInfo.name === defaultResourceGroupName) {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveCreateDefault;
            }
            else {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveCreateCustomized;
            }
        }
        else {
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.InteractiveUseExisting;
        }
    }
    else {
        // fall back to default values when user interaction is not available
        resourceGroupInfo = {
            createNewResourceGroup: true,
            name: defaultResourceGroupName,
            location: exports.DefaultResourceGroupLocation,
        };
        telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
            telemetry_1.CustomizeResourceGroupType.FallbackDefault;
    }
    (_l = ctx.telemetryReporter) === null || _l === void 0 ? void 0 : _l.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroup, telemetryProperties);
    commonQuestions.needCreateResourceGroup = resourceGroupInfo.createNewResourceGroup;
    commonQuestions.resourceGroupName = resourceGroupInfo.name;
    commonQuestions.location = resourceGroupInfo.location;
    (_m = ctx.logProvider) === null || _m === void 0 ? void 0 : _m.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions, step 2 - check resource group pass!`);
    // teamsAppTenantId
    const teamsAppTenantId = appstudioTokenJson.tid;
    if (teamsAppTenantId === undefined ||
        !(typeof teamsAppTenantId === "string") ||
        teamsAppTenantId.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
    }
    else {
        commonQuestions.teamsAppTenantId = teamsAppTenantId;
    }
    (_o = ctx.logProvider) === null || _o === void 0 ? void 0 : _o.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions, step 3 - check teamsAppTenantId pass!`);
    //resourceNameSuffix
    const resourceNameSuffix = (_p = config.get(constants_1.GLOBAL_CONFIG)) === null || _p === void 0 ? void 0 : _p.getString("resourceNameSuffix");
    if (!resourceNameSuffix)
        commonQuestions.resourceNameSuffix = uuid_1.v4().substr(0, 6);
    else
        commonQuestions.resourceNameSuffix = resourceNameSuffix;
    (_q = ctx.logProvider) === null || _q === void 0 ? void 0 : _q.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions, step 4 - check resourceNameSuffix pass!`);
    (_r = ctx.logProvider) === null || _r === void 0 ? void 0 : _r.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions, step 5 - check tenantId pass!`);
    return teamsfx_api_1.ok(commonQuestions);
}
/**
 * Asks for userinput and fills the answers in global config.
 *
 * @param config reference to solution config
 * @param dialog communication channel to Core Module
 */
async function fillInCommonQuestions(ctx, appName, config, azureAccountProvider, 
// eslint-disable-next-line @typescript-eslint/ban-types
appStudioJson) {
    const result = await askCommonQuestions(ctx, appName, config, azureAccountProvider, appStudioJson);
    if (result.isOk()) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const globalConfig = config.get(constants_1.GLOBAL_CONFIG);
        result.map((commonQuestions) => {
            for (const [k, v] of Object.entries(commonQuestions)) {
                globalConfig.set(k, v);
            }
        });
    }
    return result;
}
exports.fillInCommonQuestions = fillInCommonQuestions;
async function createNewResourceGroup(azureAccountProvider, subscriptionId, subscriptionName, resourceGroupName, location, logProvider) {
    const azureToken = await azureAccountProvider.getAccountCredentialAsync();
    const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
    const maybeExist = await checkResourceGroupExistence(rmClient, resourceGroupName, subscriptionId, subscriptionName);
    if (maybeExist.isErr()) {
        return teamsfx_api_1.err(maybeExist.error);
    }
    if (maybeExist.value) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToCreateResourceGroup, localizeUtils_1.getDefaultString("error.FailedToCreateResourceGroup"), localizeUtils_1.getLocalizedString("error.FailedToCreateResourceGroup")));
    }
    let response;
    try {
        response = await rmClient.resourceGroups.createOrUpdate(resourceGroupName, {
            location: location,
            tags: { "created-by": "teamsfx" },
        });
    }
    catch (e) {
        let param;
        if (e instanceof Error) {
            param = `${e.name}:${e.message}`;
        }
        else {
            param = `unknown error ${JSON.stringify(e)}`;
        }
        return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_1.SolutionSource, constants_1.SolutionError.FailedToCreateResourceGroup, localizeUtils_1.getDefaultString("error.FailedToCreateResourceGroup2", param), localizeUtils_1.getLocalizedString("error.FailedToCreateResourceGroup2", param)));
    }
    if (response.name === undefined) {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_1.SolutionSource, constants_1.SolutionError.FailedToCreateResourceGroup, localizeUtils_1.getDefaultString("error.FailedToCreateResourceGroup3"), localizeUtils_1.getLocalizedString("error.FailedToCreateResourceGroup3")));
    }
    logProvider === null || logProvider === void 0 ? void 0 : logProvider.info(`[${constants_2.PluginDisplayName.Solution}] askCommonQuestions - resource group:'${response.name}' created!`);
    return teamsfx_api_1.ok(response.name);
}
exports.createNewResourceGroup = createNewResourceGroup;
function handleRestError(restError, resourceGroupName, subscriptionId, subscriptionName) {
    // ARM API will return 403 with empty body when users does not have permission to access the resource group
    if (restError.statusCode === 403) {
        return teamsfx_api_1.err(new constants_1.UnauthorizedToCheckResourceGroupError(resourceGroupName, subscriptionId, subscriptionName));
    }
    else {
        return teamsfx_api_1.err(new constants_1.FailedToCheckResourceGroupExistenceError(restError, resourceGroupName, subscriptionId, subscriptionName));
    }
}
async function checkResourceGroupExistence(rmClient, resourceGroupName, subscriptionId, subscriptionName) {
    try {
        const checkRes = await rmClient.resourceGroups.checkExistence(resourceGroupName);
        return teamsfx_api_1.ok(!!checkRes.body);
    }
    catch (e) {
        if (e instanceof ms_rest_js_1.RestError) {
            return handleRestError(e, resourceGroupName, subscriptionId, subscriptionName);
        }
        else {
            return teamsfx_api_1.err(new constants_1.FailedToCheckResourceGroupExistenceError(e, resourceGroupName, subscriptionId, subscriptionName));
        }
    }
}
exports.checkResourceGroupExistence = checkResourceGroupExistence;
//# sourceMappingURL=commonQuestions.js.map