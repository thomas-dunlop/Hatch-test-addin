"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeLifecycles = exports.executeConcurrently = exports.executeSequentially = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../../../common/constants");
/**
 * Execute plugin lifecycles one by one with its associated context.
 *
 */
async function executeSequentially(step, lifecycleAndContext) {
    var _a;
    let logger;
    const results = [];
    for (const pair of lifecycleAndContext) {
        const lifecycle = pair[0];
        const context = pair[1];
        logger = context.logProvider;
        if (lifecycle) {
            const result = await lifecycle(context);
            results.push(result);
            if (result.isErr()) {
                break;
            }
        }
        else {
            results.push(undefined);
        }
    }
    if (logger)
        logger === null || logger === void 0 ? void 0 : logger.info(`${`[${constants_1.PluginDisplayName.Solution}] Execute ${step}Task summary`.padEnd(64, "-")}`);
    for (let i = 0; i < results.length; ++i) {
        const pair = lifecycleAndContext[i];
        const lifecycle = pair[0];
        const context = pair[1];
        const pluginName = pair[2];
        const result = results[i];
        if (!result || !lifecycle)
            continue;
        const taskname = lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.name.replace("bound ", "");
        (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(`${(pluginName + "." + taskname).padEnd(60, ".")} ${result.isOk() ? "[ok]" : "[failed]"}`);
        if (result.isErr()) {
            if (logger)
                logger === null || logger === void 0 ? void 0 : logger.info(`${`[${constants_1.PluginDisplayName.Solution}] ${step}Task overall result`.padEnd(60, ".")}[failed]`);
            return result;
        }
    }
    if (logger)
        logger === null || logger === void 0 ? void 0 : logger.info(`${`[${constants_1.PluginDisplayName.Solution}] ${step}Task overall result`.padEnd(60, ".")}[ok]`);
    return teamsfx_api_1.ok(undefined);
}
exports.executeSequentially = executeSequentially;
/**
 * ConcurrentExecutor will concurrently run the plugin lifecycles with
 * its associated context.
 *
 * Currently, on success, return value is discarded by returning undefined on sucess.
 */
async function executeConcurrently(step, lifecycleAndContext) {
    var _a;
    let logger;
    const promises = lifecycleAndContext.map(async (pair) => {
        const lifecycle = pair[0];
        const context = pair[1];
        const pluginName = pair[2];
        const taskname = lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.name.replace("bound ", "");
        logger = context.logProvider;
        if (lifecycle) {
            try {
                const res = lifecycle(context);
                return res;
            }
            catch (e) {
                if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                    return teamsfx_api_1.err(e);
                }
                return teamsfx_api_1.err(new teamsfx_api_1.SystemError("Solution", "UnknownError", `[Solution.executeConcurrently part 1] unknown error from plugin: ${pluginName}, taskName:${taskname}, error: ${JSON.stringify(e)}`));
            }
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    });
    try {
        const results = await Promise.all(promises);
        if (logger)
            logger === null || logger === void 0 ? void 0 : logger.info(`${`[${constants_1.PluginDisplayName.Solution}] Execute ${step}Task summary`.padEnd(64, "-")}`);
        let failed = false;
        for (let i = 0; i < results.length; ++i) {
            const pair = lifecycleAndContext[i];
            const lifecycle = pair[0];
            const context = pair[1];
            const pluginName = pair[2];
            const result = results[i];
            if (!result || !lifecycle)
                continue;
            const taskname = lifecycle === null || lifecycle === void 0 ? void 0 : lifecycle.name.replace("bound ", "");
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(`${(pluginName + "." + taskname).padEnd(60, ".")} ${result.isOk() ? "[ok]" : "[failed]"}`);
            if (result.isErr()) {
                failed = true;
            }
        }
        if (logger)
            logger === null || logger === void 0 ? void 0 : logger.info(`${`[${constants_1.PluginDisplayName.Solution}] ${step}Task overall result`.padEnd(60, ".")}${failed ? "[failed]" : "[ok]"}`);
        return results;
    }
    catch (e) {
        if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
            throw e;
        }
        throw new teamsfx_api_1.SystemError("Solution", "UnknownError", `[Solution.executeConcurrently part 2] unknown error: ${JSON.stringify(e)}`);
    }
}
exports.executeConcurrently = executeConcurrently;
/**
 * Executes preLifecycles, lifecycles, postCycles in order. If one of the steps failes, following steps won't run.
 *
 * @param preLifecycles
 * @param lifecycles
 * @param postLifecycles
 */
async function executeLifecycles(preLifecycles, lifecycles, postLifecycles, onPreLifecycleFinished, onLifecycleFinished, onPostLifecycleFinished) {
    // Questions are asked sequentially during preLifecycles.
    const preResult = await executeSequentially("pre", preLifecycles);
    if (preResult.isErr()) {
        return preResult;
    }
    if (onPreLifecycleFinished) {
        const result = await onPreLifecycleFinished();
        if (result.isErr()) {
            return result;
        }
    }
    const results = await executeConcurrently("", lifecycles);
    if (onLifecycleFinished) {
        const onLifecycleFinishedResult = await onLifecycleFinished(results);
        if (onLifecycleFinishedResult.isErr()) {
            return onLifecycleFinishedResult;
        }
    }
    else {
        for (const result of results) {
            if (result.isErr()) {
                return result;
            }
        }
    }
    const postResults = await executeConcurrently("post", postLifecycles);
    for (const result of postResults) {
        if (result.isErr()) {
            return result;
        }
    }
    if (onPostLifecycleFinished) {
        const result = await onPostLifecycleFinished();
        if (result.isErr()) {
            return result;
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.executeLifecycles = executeLifecycles;
//# sourceMappingURL=executor.js.map