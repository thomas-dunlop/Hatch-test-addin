import { ResourceManagementClient } from "@azure/arm-resources";
import { DeploymentOperation } from "@azure/arm-resources/esm/models";
import { AzureAccountProvider, FxError, Result, SolutionContext, v2, v3 } from "@microsoft/teamsfx-api";
import { ArmTemplateResult, NamedArmResourcePlugin } from "../../../common/armInterface";
export declare function generateArmTemplate(ctx: SolutionContext, selectedPlugins?: NamedArmResourcePlugin[]): Promise<Result<any, FxError>>;
export declare function generateBicep(ctx: v3.ContextWithManifestProvider, inputs: v2.InputsWithProjectPath, addedPlugins: string[], existingPlugins: string[]): Promise<Result<any, FxError>>;
declare type DeployContext = {
    ctx: SolutionContext;
    finished: boolean;
    client: ResourceManagementClient;
    resourceGroupName: string;
    deploymentStartTime: number;
    deploymentName: string;
};
declare type OperationStatus = {
    resourceName: string;
    resourceGroupName: string;
    subscriptionId: string;
    resourceType?: string;
    status: string;
};
export declare function getRequiredOperation(operation: DeploymentOperation, deployCtx: DeployContext): OperationStatus | undefined;
export declare function pollDeploymentStatus(deployCtx: DeployContext): Promise<void>;
export declare function doDeployArmTemplates(ctx: SolutionContext): Promise<Result<void, FxError>>;
export declare function doDeployArmTemplatesV3(ctx: v2.Context, inputs: v2.InputsWithProjectPath, envInfo: v3.EnvInfoV3, azureAccountProvider: AzureAccountProvider): Promise<Result<undefined, FxError>>;
export declare function deployArmTemplates(ctx: SolutionContext): Promise<Result<void, FxError>>;
export declare function deployArmTemplatesV3(ctx: v2.Context, inputs: v2.InputsWithProjectPath, envInfo: v3.EnvInfoV3, azureAccountProvider: AzureAccountProvider): Promise<Result<undefined, FxError>>;
export declare function copyParameterJson(projectPath: string, appName: string, targetEnvName: string, sourceEnvName: string): Promise<void>;
export declare function updateAzureParameters(projectPath: string, appName: string, envName: string, hasSwitchedM365Tenant: boolean, hasSwitchedSubscription: boolean, hasBotServiceCreatedBefore: boolean): Promise<Result<undefined, FxError>>;
export declare function getParameterJson(ctx: SolutionContext): Promise<any>;
export declare function getParameterJsonV3(ctx: v2.Context, projectPath: string, envInfo: v3.EnvInfoV3): Promise<any>;
export declare class ArmTemplateRenderContext {
    Plugins: Record<string, PluginContext>;
    constructor(pluginNames: string[]);
    addPluginOutput(pluginName: string, armResult: ArmTemplateResult): void;
}
interface PluginContext {
    Provision?: {
        [ModuleName: string]: PluginModuleProperties;
    };
    Configuration?: {
        [ModuleName: string]: PluginModuleProperties;
    };
    References?: {
        [Key: string]: string;
    };
}
interface PluginModuleProperties {
    path: string;
}
export declare function generateResourceBaseName(appName: string, envName: string): string;
export declare function wrapGetDeploymentError(deployCtx: DeployContext, resourceGroupName: string, deploymentName: string): Promise<Result<any, FxError>>;
export declare function formattedDeploymentError(deploymentError: any): any;
declare class ArmV2 {
    generateArmTemplate(ctx: SolutionContext, selectedPlugins?: NamedArmResourcePlugin[]): Promise<Result<any, FxError>>;
    deployArmTemplates(ctx: SolutionContext): Promise<Result<void, FxError>>;
}
declare class Arm {
    generateBicep(ctx: v3.ContextWithManifestProvider, inputs: v2.InputsWithProjectPath, addedPlugins: string[], existingPlugins: string[]): Promise<Result<any, FxError>>;
    deployArmTemplates(ctx: v2.Context, inputs: v2.InputsWithProjectPath, envInfo: v3.EnvInfoV3, azureAccountProvider: AzureAccountProvider): Promise<Result<undefined, FxError>>;
}
declare const arm: Arm;
export declare const armV2: ArmV2;
export default arm;
//# sourceMappingURL=arm.d.ts.map