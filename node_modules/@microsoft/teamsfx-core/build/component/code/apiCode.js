"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiCodeProvider = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const depsChecker_1 = require("../../common/deps-checker/depsChecker");
const checkerFactory_1 = require("../../common/deps-checker/checkerFactory");
const question_1 = require("../../core/question");
const constants_1 = require("../../plugins/resource/function/constants");
const enums_1 = require("../../plugins/resource/function/enums");
const deploy_1 = require("../../plugins/resource/function/ops/deploy");
const scaffold_1 = require("../../plugins/resource/function/ops/scaffold");
const funcHelper_1 = require("../../plugins/resource/function/utils/depsChecker/funcHelper");
const constants_2 = require("../constants");
const error_1 = require("../error");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const workflow_1 = require("../workflow");
const telemetry_helper_1 = require("../../plugins/resource/function/utils/telemetry-helper");
const logger_1 = require("../../plugins/resource/function/utils/logger");
const funcPluginLogger_1 = require("../../plugins/resource/function/utils/depsChecker/funcPluginLogger");
const funcPluginTelemetry_1 = require("../../plugins/resource/function/utils/depsChecker/funcPluginTelemetry");
const depsError_1 = require("../../common/deps-checker/depsError");
const message_1 = require("../../plugins/resource/function/resources/message");
const language_strategy_1 = require("../../plugins/resource/function/language-strategy");
const utils_1 = require("./utils");
/**
 * api scaffold
 */
let ApiCodeProvider = class ApiCodeProvider {
    constructor() {
        this.name = "api-code";
    }
    async generate(context, inputs, actionContext) {
        var _a;
        const projectSettings = context.projectSetting;
        const appName = projectSettings.appName;
        const language = inputs[question_1.CoreQuestionNames.ProgrammingLanguage];
        const folder = inputs.folder || constants_1.FunctionPluginPathInfo.solutionFolderName;
        const workingDir = path.join(inputs.projectPath, folder);
        const functionName = inputs[enums_1.QuestionKey.functionName];
        const variables = {
            appName: appName,
            functionName: functionName,
        };
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.scaffoldApi));
        await scaffold_1.FunctionScaffold.scaffoldFunction(workingDir, language, constants_1.DefaultValues.functionTriggerType, functionName, variables);
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        const teamsApi = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsApi);
        if (!teamsApi)
            return teamsfx_api_1.ok(undefined);
        if (teamsApi.folder == undefined)
            throw new error_1.BadComponent("api", this.name, "folder");
        const language = context.projectSetting.programmingLanguage;
        if (!language || !Object.values(enums_1.FunctionLanguage).includes(language))
            throw new error_1.invalidProjectSettings(messages_1.ErrorMessage.programmingLanguageInvalid);
        const buildPath = path.resolve(inputs.projectPath, teamsApi.folder);
        await this.handleDotnetChecker(context, inputs);
        try {
            await deploy_1.FunctionDeploy.installFuncExtensions(buildPath, language);
        }
        catch (error) {
            if (error instanceof Error) {
                // wrap the original error to UserError so the extensibility model will pop-up a dialog correctly
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            else {
                throw error;
            }
        }
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.buildingApi));
        for (const commandItem of language_strategy_1.LanguageStrategyFactory.getStrategy(language)
            .buildCommands) {
            const command = commandItem.command;
            const relativePath = commandItem.relativePath;
            const absolutePath = path.join(buildPath, relativePath);
            await utils_1.execute(command, absolutePath, context.logProvider);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async handleDotnetChecker(ctx, inputs) {
        logger_1.Logger.setLogger(ctx.logProvider);
        telemetry_helper_1.TelemetryHelper.setContext(ctx);
        const dotnetChecker = checkerFactory_1.CheckerFactory.createChecker(depsChecker_1.DepsType.Dotnet, funcPluginLogger_1.funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        try {
            if (!(await funcHelper_1.funcDepsHelper.dotnetCheckerEnabled(inputs))) {
                return;
            }
            await dotnetChecker.resolve();
        }
        catch (error) {
            if (error instanceof depsError_1.LinuxNotSupportedError) {
                return;
            }
            if (error instanceof Error) {
                funcPluginLogger_1.funcDepsLogger.error(message_1.InfoMessages.failedToInstallDotnet(error));
                await funcPluginLogger_1.funcDepsLogger.printDetailLog();
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            else {
                throw error;
            }
        }
        finally {
            funcPluginLogger_1.funcDepsLogger.cleanup();
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.scaffoldApi,
            progressSteps: 1,
            errorSource: "api",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ApiCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.buildingApi,
            progressSteps: 1,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ApiCodeProvider.prototype, "build", null);
ApiCodeProvider = tslib_1.__decorate([
    typedi_1.Service("api-code")
], ApiCodeProvider);
exports.ApiCodeProvider = ApiCodeProvider;
//# sourceMappingURL=apiCode.js.map