"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabCodeProvider = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../common/template-utils/templatesActions");
const utils_1 = require("../../common/utils");
const question_1 = require("../../core/question");
const error_1 = require("../../plugins/resource/bot/v3/error");
const constants_1 = require("../../plugins/resource/frontend/constants");
const deploy_1 = require("../../plugins/resource/frontend/ops/deploy");
const errors_1 = require("../../plugins/resource/frontend/resources/errors");
const messages_1 = require("../../plugins/resource/frontend/resources/messages");
const constants_2 = require("../constants");
const workflow_1 = require("../workflow");
const utils_2 = require("./utils");
const env_1 = require("../../plugins/resource/frontend/env");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const constants_3 = require("../../plugins/resource/frontend/dotnet/constants");
const errors_2 = require("../../plugins/resource/bot/errors");
const steps_1 = require("../../plugins/resource/frontend/resources/steps");
const messages_2 = require("../messages");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const question_2 = require("../../plugins/solution/fx-solution/question");
const error_2 = require("../error");
const appSettingUtils_1 = require("./appSettingUtils");
const baseAppSettings_json_1 = tslib_1.__importDefault(require("./appSettings/baseAppSettings.json"));
const ssoBlazorAppSettings_json_1 = tslib_1.__importDefault(require("./appSettings/ssoBlazorAppSettings.json"));
/**
 * tab scaffold
 */
let TabCodeProvider = class TabCodeProvider {
    constructor() {
        this.name = "tab-code";
    }
    async generate(ctx, inputs, actionContext) {
        var _a, _b;
        inputs.folder =
            inputs.folder ||
                (inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === constants_2.ProgrammingLanguage.CSharp
                    ? ""
                    : constants_1.FrontendPathInfo.WorkingDir);
        const langKey = utils_2.convertToLangKey(inputs[question_1.CoreQuestionNames.ProgrammingLanguage]);
        const workingDir = path.join(inputs.projectPath, inputs.folder);
        inputs.safeProjectName =
            (_a = inputs.safeProjectName) !== null && _a !== void 0 ? _a : utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName);
        const variables = {
            ProjectName: ctx.projectSetting.appName,
            SafeProjectName: inputs.safeProjectName,
        };
        const scenario = featureToScenario.get(inputs[question_1.CoreQuestionNames.Features]);
        await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(messages_2.ProgressMessages.scaffoldTab));
        await templatesActions_1.scaffoldFromTemplates({
            group: "tab",
            lang: langKey,
            scenario: scenario,
            dst: workingDir,
            fileNameReplaceFn: (name, data) => name.replace(/ProjectName/, ctx.projectSetting.appName).replace(/\.tpl/, ""),
            fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    ctx.logProvider.info(messages_1.Messages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : constants_1.Constants.EmptyString));
                }
            },
            onActionError: async (action, context, error) => {
                ctx.logProvider.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        ctx.logProvider.info(messages_1.Messages.FailedFetchTemplate);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new error_1.TemplateZipFallbackError();
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new errors_1.UnzipTemplateError();
                    default:
                        throw new errors_1.UnknownScaffoldError();
                }
            },
        });
        return teamsfx_api_1.ok(inputs.folder);
    }
    async configure(context, inputs) {
        const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
        const tabDir = teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.folder;
        // Non-sso tab do not need to be configured
        if (tabDir == undefined || !(teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.sso))
            return teamsfx_api_1.ok(undefined);
        if (projectSettingsHelper_1.isVSProject(context.projectSetting) && context.envInfo.envName === "local") {
            const appSettingsPath = path.resolve(inputs.projectPath, tabDir, appSettingUtils_1.AppSettingConstants.DevelopmentFileName);
            let appSettings;
            if (!(await fs.pathExists(appSettingsPath))) {
                // if appsetting file not exist, generate a new one
                appSettings = JSON.stringify(Object.assign(Object.assign({}, baseAppSettings_json_1.default), ssoBlazorAppSettings_json_1.default), null, 2);
            }
            else {
                appSettings = await fs.readFile(appSettingsPath, "utf-8");
            }
            await fs.writeFile(appSettingsPath, appSettingUtils_1.replaceBlazorAppSettings(context, appSettings), "utf-8");
        }
        else {
            const envFile = env_1.envFilePath(context.envInfo.envName, path.join(inputs.projectPath, tabDir));
            const envs = this.collectEnvs(context);
            await env_1.saveEnvFile(envFile, { teamsfxRemoteEnvs: envs, customizedRemoteEnvs: {} });
        }
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        const ctx = context;
        const teamsTab = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsTab);
        if (!teamsTab)
            return teamsfx_api_1.ok(undefined);
        if (teamsTab.folder == undefined)
            throw new error_2.BadComponent("tab", this.name, "folder");
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_2.ProgressMessages.buildingTab));
        const tabPath = path.resolve(inputs.projectPath, teamsTab.folder);
        const artifactFolder = projectSettingsHelper_1.isVSProject(context.projectSetting)
            ? await this.doBlazorBuild(tabPath, context.logProvider)
            : await this.doReactBuild(tabPath, ctx.envInfo.envName, context.telemetryReporter, context.logProvider);
        lodash_1.merge(teamsTab, {
            build: true,
            artifactFolder: path.join(teamsTab.folder, artifactFolder),
        });
        return teamsfx_api_1.ok(undefined);
    }
    collectEnvs(ctx) {
        var _a, _b, _c, _d, _e, _f;
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        const teamsTab = workflow_1.getComponent(ctx.projectSetting, constants_2.ComponentNames.TeamsTab);
        const teamsApi = workflow_1.getComponent(ctx.projectSetting, constants_2.ComponentNames.TeamsApi);
        if (teamsApi) {
            addToEnvs(env_1.EnvKeys.FuncName, teamsApi.functionNames[0]);
            addToEnvs(env_1.EnvKeys.FuncEndpoint, (_c = (_b = (_a = ctx.envInfo) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b[constants_2.ComponentNames.TeamsApi]) === null || _c === void 0 ? void 0 : _c.functionEndpoint);
        }
        if (teamsTab === null || teamsTab === void 0 ? void 0 : teamsTab.sso) {
            addToEnvs(env_1.EnvKeys.ClientID, (_f = (_e = (_d = ctx.envInfo) === null || _d === void 0 ? void 0 : _d.state) === null || _e === void 0 ? void 0 : _e[constants_2.ComponentNames.AadApp]) === null || _f === void 0 ? void 0 : _f.clientId);
            addToEnvs(env_1.EnvKeys.StartLoginPage, constants_1.DependentPluginInfo.StartLoginPageURL);
        }
        return envs;
    }
    async doBlazorBuild(tabPath, logger) {
        const command = constants_3.DotnetCommands.buildRelease("win-x86");
        try {
            await utils_2.execute(command, tabPath, logger);
        }
        catch (e) {
            throw new errors_2.CommandExecutionError(command, tabPath, e);
        }
        return "publish";
    }
    async doReactBuild(tabPath, envName, telemetryReporter, logger) {
        const needBuild = await deploy_1.FrontendDeployment.needBuild(tabPath, envName);
        if (!needBuild) {
            return "build";
        }
        const scripts = async () => { var _a; return (_a = (await fs.readJSON(path.join(tabPath, constants_1.FrontendPathInfo.NodePackageFile))).scripts) !== null && _a !== void 0 ? _a : []; };
        if (!("install:teamsfx" in scripts)) {
            // * Track legacy projects
            telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(constants_1.TelemetryEvent.InstallScriptNotFound);
        }
        await utils_2.execute("install:teamsfx" in scripts
            ? constants_1.Commands.InstallNodePackages
            : constants_1.Commands.DefaultInstallNodePackages, tabPath, logger);
        if ("build:teamsfx" in scripts) {
            await utils_2.execute(constants_1.Commands.BuildFrontend, tabPath, logger, {
                TEAMS_FX_ENV: envName,
            });
        }
        else {
            const envs = await env_1.loadEnvFile(env_1.envFilePath(envName, tabPath));
            await utils_2.execute(constants_1.Commands.DefaultBuildFrontend, tabPath, logger, Object.assign(Object.assign({}, envs.customizedRemoteEnvs), envs.teamsfxRemoteEnvs));
        }
        await deploy_1.FrontendDeployment.saveDeploymentInfo(tabPath, envName, {
            lastBuildTime: new Date().toISOString(),
        });
        return "build";
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: "FE",
            enableProgressBar: true,
            progressTitle: messages_2.ProgressTitles.scaffoldTab,
            progressSteps: Object.keys(steps_1.ScaffoldProgress.steps).length,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: "FE",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_2.ProgressTitles.buildingTab,
            progressSteps: 1,
            errorSource: "FE",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TabCodeProvider.prototype, "build", null);
TabCodeProvider = tslib_1.__decorate([
    typedi_1.Service("tab-code")
], TabCodeProvider);
exports.TabCodeProvider = TabCodeProvider;
var Scenario;
(function (Scenario) {
    Scenario["default"] = "default";
    Scenario["nonSso"] = "non-sso";
    Scenario["m365"] = "m365";
})(Scenario || (Scenario = {}));
const featureToScenario = new Map([
    [question_2.TabOptionItem.id, Scenario.default],
    [question_2.TabNonSsoItem.id, Scenario.nonSso],
    [question_2.M365SsoLaunchPageOptionItem.id, Scenario.m365],
]);
//# sourceMappingURL=tabCode.js.map