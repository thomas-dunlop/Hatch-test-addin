"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApimService = void 0;
const constants_1 = require("../constants");
const error_1 = require("../error");
const telemetry_1 = require("../utils/telemetry");
const log_1 = require("../log");
class ApimService {
    constructor(apimClient, resourceProviderClient, credential, subscriptionId, telemetryReporter, logger) {
        this.credential = credential;
        this.subscriptionId = subscriptionId;
        this.apimClient = apimClient;
        this.resourceProviderClient = resourceProviderClient;
        this.telemetryReporter = telemetryReporter;
        this.logger = logger;
    }
    async getService(resourceGroupName, serviceName) {
        const fn = () => this.apimClient.apiManagementService.get(resourceGroupName, serviceName);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.APIM, serviceName, fn, resourceNotFoundErrorHandler);
    }
    async getApi(resourceGroupName, serviceName, apiId) {
        const fn = () => this.apimClient.api.get(resourceGroupName, serviceName, apiId);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.API, apiId, fn, resourceNotFoundErrorHandler);
    }
    // The maximum number of APIs in consumption tier is 50. There are no limits for other tiers.
    // Detail: https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#api-management-limits
    async listApi(resourceGroupName, serviceName, versionSetId) {
        const resourceId = versionSetId
            ? this.generateVersionSetResourceId(this.subscriptionId, resourceGroupName, serviceName, versionSetId)
            : undefined;
        const fn = () => this.apimClient.api.listByService(resourceGroupName, serviceName, {
            expandApiVersionSet: true,
        });
        const apiListResponse = await this.execute(constants_1.Operation.List, constants_1.AzureResource.API, undefined, fn);
        const apiList = error_1.AssertNotEmpty("apiListResponse", apiListResponse);
        const result = apiList.filter((x) => { var _a; return !!resourceId && ((_a = x.apiVersionSet) === null || _a === void 0 ? void 0 : _a.id) === resourceId; });
        let nextLink = apiList.nextLink;
        while (nextLink) {
            const nextFn = () => this.apimClient.api.listByServiceNext(nextLink);
            const nextPageResponse = await this.execute(constants_1.Operation.ListNextPage, constants_1.AzureResource.API, undefined, nextFn);
            const apiNextList = error_1.AssertNotEmpty("nextPageResponse", nextPageResponse);
            result.push(...apiNextList.filter((x) => { var _a; return !!resourceId && ((_a = x.apiVersionSet) === null || _a === void 0 ? void 0 : _a.id) === resourceId; }));
            nextLink = apiNextList.nextLink;
        }
        return result;
    }
    async importApi(resourceGroupName, serviceName, apiId, apiPath, version, versionSetId, oAuthServerId, schemaVersion, spec) {
        const newApi = {
            authenticationSettings: {
                oAuth2: {
                    authorizationServerId: oAuthServerId,
                },
            },
            path: apiPath,
            apiVersion: version,
            apiVersionSetId: `/apiVersionSets/${versionSetId}`,
            format: schemaVersion === constants_1.OpenApiSchemaVersion.V2 ? "swagger-json" : "openapi+json",
            value: JSON.stringify(spec),
            subscriptionRequired: false,
            protocols: ["https"],
        };
        const fn = () => this.apimClient.api.createOrUpdate(resourceGroupName, serviceName, apiId, newApi);
        await this.execute(constants_1.Operation.Import, constants_1.AzureResource.API, apiId, fn, validationErrorHandler);
    }
    async getVersionSet(resourceGroupName, serviceName, versionSetId) {
        const fn = () => this.apimClient.apiVersionSet.get(resourceGroupName, serviceName, versionSetId);
        return await this.execute(constants_1.Operation.Get, constants_1.AzureResource.VersionSet, versionSetId, fn, resourceNotFoundErrorHandler);
    }
    async createVersionSet(resourceGroupName, serviceName, versionSetId, versionSetName) {
        const originVersionSet = await this.getVersionSet(resourceGroupName, serviceName, versionSetId);
        if (originVersionSet) {
            return;
        }
        const newVersionSet = {
            displayName: versionSetName !== null && versionSetName !== void 0 ? versionSetName : versionSetId,
            versioningScheme: "Segment",
        };
        const fn = () => this.apimClient.apiVersionSet.createOrUpdate(resourceGroupName, serviceName, versionSetId, newVersionSet);
        await this.execute(constants_1.Operation.Create, constants_1.AzureResource.VersionSet, versionSetId, fn);
    }
    async checkProductApiExistence(resourceGroupName, serviceName, productId, apiId) {
        const fn = () => this.apimClient.productApi.checkEntityExists(resourceGroupName, serviceName, productId, apiId);
        const id = `${productId} - ${apiId}`;
        return !!(await this.execute(constants_1.Operation.Get, constants_1.AzureResource.ProductAPI, id, fn, productApiNotFoundErrorHandler));
    }
    async addApiToProduct(resourceGroupName, serviceName, productId, apiId) {
        const existence = await this.checkProductApiExistence(resourceGroupName, serviceName, productId, apiId);
        if (existence) {
            return;
        }
        const fn = () => this.apimClient.productApi.createOrUpdate(resourceGroupName, serviceName, productId, apiId);
        const id = `${productId} - ${apiId}`;
        await this.execute(constants_1.Operation.Create, constants_1.AzureResource.ProductAPI, id, fn, validationErrorHandler);
    }
    async getUserId() {
        var _a, _b;
        const token = await ((_a = this.credential) === null || _a === void 0 ? void 0 : _a.getToken());
        if (!(token === null || token === void 0 ? void 0 : token.userId)) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warning(log_1.LogMessages.useDefaultUserId);
            return constants_1.ApimDefaultValues.userId;
        }
        else {
            return token.userId;
        }
    }
    async execute(operation, resourceType, resourceId, fn, errorHandler) {
        var _a, _b, _c, _d, _e;
        try {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(log_1.LogMessages.operationStarts(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Started);
            const result = await fn();
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(log_1.LogMessages.operationSuccess(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Succeeded);
            return result;
        }
        catch (error) {
            if (!!errorHandler && errorHandler(error) === constants_1.ErrorHandlerResult.Return) {
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(log_1.LogMessages.operationSuccess(operation, resourceType, resourceId));
                telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Succeeded);
                if (operation === constants_1.Operation.Get) {
                    (_d = this.logger) === null || _d === void 0 ? void 0 : _d.info(log_1.LogMessages.resourceNotFound(resourceType, resourceId));
                }
                return undefined;
            }
            const wrappedError = error_1.BuildError(error_1.ApimOperationError, error, operation.displayName, resourceType.displayName);
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.warning(log_1.LogMessages.operationFailed(operation, resourceType, resourceId));
            telemetry_1.Telemetry.sendApimOperationEvent(this.telemetryReporter, operation, resourceType, constants_1.OperationStatus.Failed, wrappedError);
            throw wrappedError;
        }
    }
    generateVersionSetResourceId(subscriptionId, resourceGroupName, serviceName, versionSetId) {
        return `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}/providers/Microsoft.ApiManagement/service/${serviceName}/apiVersionSets/${versionSetId}`;
    }
}
exports.ApimService = ApimService;
function resourceNotFoundErrorHandler(error) {
    if ("code" in error) {
        if (error.code === "ResourceNotFound") {
            return constants_1.ErrorHandlerResult.Return;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
function productApiNotFoundErrorHandler(error) {
    if ("statusCode" in error) {
        if (error.statusCode === 404) {
            return constants_1.ErrorHandlerResult.Return;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
function validationErrorHandler(error) {
    if ("code" in error) {
        if (error.code === "ValidationError") {
            if (error.body.details instanceof Array) {
                for (const detailError of error.body.details) {
                    if (detailError.message) {
                        error.message += ` [Detail] ${detailError.message}`;
                    }
                }
            }
        }
        else if (typeof error.body === "string") {
            error.message += `[Detail] ${error.body}.`;
        }
    }
    return constants_1.ErrorHandlerResult.Continue;
}
//# sourceMappingURL=apimService.js.map