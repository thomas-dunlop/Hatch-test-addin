"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureStorageResource = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
require("reflect-metadata");
const typedi_1 = require("typedi");
const path = tslib_1.__importStar(require("path"));
const configs_1 = require("../../plugins/resource/frontend/configs");
const tools_1 = require("../../common/tools");
const error_1 = require("../../plugins/resource/frontend/v3/error");
const clients_1 = require("../../plugins/resource/frontend/clients");
const deploy_1 = require("../../plugins/resource/frontend/ops/deploy");
const azureResource_1 = require("./azureResource");
const constants_1 = require("../../plugins/resource/frontend/constants");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const error_2 = require("../error");
const ErrorSource = "Storage";
let AzureStorageResource = class AzureStorageResource extends azureResource_1.AzureResource {
    constructor() {
        super(...arguments);
        this.name = "azure-storage";
        this.bicepModuleName = "azureStorage";
        this.outputs = constants_2.StorageOutputs;
        this.finalOutputKeys = ["domain", "endpoint", "storageResourceId", "indexPath"];
    }
    async configure(context, inputs, actionContext) {
        var _a, _b;
        const ctx = context;
        if (context.envInfo.envName !== "local") {
            context.logProvider.info(messages_1.LogMessages.enableStaticWebsite);
            const frontendConfigRes = await this.buildFrontendConfig(ctx.envInfo, constants_2.ComponentNames.TeamsTab, ctx.tokenProvider.azureAccountProvider);
            if (frontendConfigRes.isErr()) {
                return teamsfx_api_1.err(frontendConfigRes.error);
            }
            await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.enableStaticWebsite));
            const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
            await client.enableStaticWebsite();
        }
        else {
            await ((_b = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _b === void 0 ? void 0 : _b.next(""));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async deploy(context, inputs, actionContext) {
        const ctx = context;
        const deployDir = path.resolve(inputs.projectPath, inputs.folder);
        const frontendConfigRes = await this.buildFrontendConfig(ctx.envInfo, inputs.componentId, ctx.tokenProvider.azureAccountProvider);
        if (frontendConfigRes.isErr()) {
            return teamsfx_api_1.err(frontendConfigRes.error);
        }
        const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
        const envName = ctx.envInfo.envName;
        await deploy_1.FrontendDeployment.doFrontendDeploymentV3(client, deployDir, envName, actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar);
        return teamsfx_api_1.ok(undefined);
    }
    async buildFrontendConfig(envInfo, scenario, tokenProvider) {
        const credentials = await tokenProvider.getAccountCredentialAsync();
        if (!credentials) {
            return teamsfx_api_1.err(new error_1.UnauthenticatedError());
        }
        const storage = envInfo.state[scenario];
        const resourceId = error_2.CheckThrowSomethingMissing(ErrorSource, "storageResourceId", storage === null || storage === void 0 ? void 0 : storage.storageResourceId);
        const frontendConfig = new configs_1.FrontendConfig(tools_1.getSubscriptionIdFromResourceId(resourceId), tools_1.getResourceGroupNameFromResourceId(resourceId), envInfo.state.solution.location, tools_1.getStorageAccountNameFromResourceId(resourceId), credentials);
        return teamsfx_api_1.ok(frontendConfig);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: ErrorSource,
            errorIssueLink: constants_1.FrontendPluginInfo.IssueLink,
            errorHelpLink: constants_1.FrontendPluginInfo.HelpLink,
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.configureStorage,
            progressSteps: 1,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageResource.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            errorSource: ErrorSource,
            errorIssueLink: constants_1.FrontendPluginInfo.IssueLink,
            errorHelpLink: constants_1.FrontendPluginInfo.HelpLink,
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.deployingStorage,
            progressSteps: 3,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AzureStorageResource.prototype, "deploy", null);
AzureStorageResource = tslib_1.__decorate([
    typedi_1.Service("azure-storage")
], AzureStorageResource);
exports.AzureStorageResource = AzureStorageResource;
//# sourceMappingURL=azureStorage.js.map