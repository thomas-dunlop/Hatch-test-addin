"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagementClient = void 0;
const tslib_1 = require("tslib");
const arm_sql_1 = require("@azure/arm-sql");
const axios_1 = tslib_1.__importDefault(require("axios"));
const errors_1 = require("../errors");
const constants_1 = require("../constants");
const results_1 = require("../results");
class ManagementClient {
    constructor(manager, config) {
        this.totalFirewallRuleCount = 0;
        this.manager = manager;
        this.config = config;
    }
    static async create(azureAccountProvider, config) {
        const credential = await azureAccountProvider.getAccountCredentialAsync();
        const manager = new arm_sql_1.SqlManagementClient(credential, config.azureSubscriptionId);
        return new ManagementClient(manager, config);
    }
    async existAzureSQL() {
        try {
            const result = await this.manager.servers.checkNameAvailability({
                name: this.config.sqlServer,
            });
            if (result.available) {
                return false;
            }
            else {
                return true;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlCheckError.name, errors_1.ErrorMessage.SqlCheckError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async existAadAdmin(aadAdmin) {
        try {
            const result = await this.manager.serverAzureADAdministrators.listByServer(this.config.resourceGroup, this.config.sqlServer);
            if (result.find((item) => item.login === aadAdmin)) {
                return true;
            }
            else {
                return false;
            }
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlCheckAdminError.name, errors_1.ErrorMessage.SqlCheckAdminError.message(this.config.sqlServer, error.message), error);
        }
    }
    async addAADadmin(tenantId, aadAdminObjectId, aadAdmin) {
        let model = {
            tenantId: tenantId,
            sid: aadAdminObjectId,
            login: aadAdmin,
        };
        const tmp = model;
        tmp.administratorType = constants_1.Constants.sqlAdministratorType;
        model = tmp;
        try {
            await this.manager.serverAzureADAdministrators.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, model);
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlAddAdminError.name, errors_1.ErrorMessage.SqlAddAdminError.message(aadAdmin, error.message), error);
        }
    }
    async addLocalFirewallRule() {
        try {
            const response = await axios_1.default.get(constants_1.Constants.echoIpAddress);
            const localIp = response.data;
            const partials = localIp.split(".");
            partials[2] = constants_1.Constants.ipBeginToken;
            partials[3] = constants_1.Constants.ipBeginToken;
            const startIp = partials.join(".");
            partials[2] = constants_1.Constants.ipEndToken;
            partials[3] = constants_1.Constants.ipEndToken;
            const endIp = partials.join(".");
            const model = {
                startIpAddress: startIp,
                endIpAddress: endIp,
            };
            const ruleName = this.getRuleName(this.totalFirewallRuleCount);
            await this.manager.firewallRules.createOrUpdate(this.config.resourceGroup, this.config.sqlServer, ruleName, model);
            this.totalFirewallRuleCount++;
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlLocalFirwallError.name, errors_1.ErrorMessage.SqlLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    async deleteLocalFirewallRule() {
        try {
            await Promise.all(Array.from(Array(this.totalFirewallRuleCount).keys()).map(async (i) => {
                const ruleName = this.getRuleName(i);
                await this.manager.firewallRules.deleteMethod(this.config.resourceGroup, this.config.sqlServer, ruleName);
            }));
        }
        catch (error) {
            throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlDeleteLocalFirwallError.name, errors_1.ErrorMessage.SqlDeleteLocalFirwallError.message(this.config.sqlEndpoint, error.message), error);
        }
    }
    getRuleName(suffix) {
        return constants_1.Constants.firewall.localRule + suffix;
    }
    async delay(s) {
        return new Promise((resolve) => setTimeout(resolve, s * 1000));
    }
}
exports.ManagementClient = ManagementClient;
//# sourceMappingURL=management.js.map