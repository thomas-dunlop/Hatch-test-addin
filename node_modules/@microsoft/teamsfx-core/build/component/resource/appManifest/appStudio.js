"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateManifest = exports.validateManifest = exports.buildTeamsAppPackage = exports.publishTeamsApp = exports.updateTeamsApp = exports.createTeamsApp = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const uuid_1 = require("uuid");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const util = tslib_1.__importStar(require("util"));
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const tools_1 = require("../../../common/tools");
const constants_1 = require("../../../common/constants");
const appStudio_1 = require("../../../plugins/resource/appstudio/appStudio");
const constants_2 = require("../../../plugins/resource/appstudio/constants");
const errors_1 = require("../../../plugins/resource/appstudio/errors");
const results_1 = require("../../../plugins/resource/appstudio/results");
const constants_3 = require("../../constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const utils_1 = require("./utils");
/**
 * Create Teams app if not exists
 * @param ctx
 * @param inputs
 * @param envInfo
 * @param tokenProvider
 * @returns Teams app id
 */
async function createTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    var _a;
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    let teamsAppId;
    let archivedFile;
    if (inputs.appPackagePath) {
        if (!(await fs_extra_1.default.pathExists(inputs.appPackagePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
        archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_2.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_2.Constants.MANIFEST_FILE)));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        teamsAppId = manifest.id;
    }
    else {
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo, true);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
        teamsAppId = (_a = envInfo.state[constants_3.ComponentNames.AppManifest]) === null || _a === void 0 ? void 0 : _a.teamsAppId;
    }
    let create = true;
    if (teamsAppId) {
        try {
            await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            create = false;
        }
        catch (error) { }
    }
    if (create) {
        try {
            const appDefinition = await appStudio_1.AppStudioClient.importApp(archivedFile, appStudioTokenRes.value, ctx.logProvider);
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppCreatedNotice", appDefinition.teamsAppId));
            return teamsfx_api_1.ok(appDefinition.teamsAppId);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
        }
    }
    else {
        return teamsfx_api_1.ok(teamsAppId);
    }
}
exports.createTeamsApp = createTeamsApp;
/**
 * Update Teams app
 * @param ctx
 * @param inputs
 * @param envInfo
 * @param tokenProvider
 * @returns
 */
async function updateTeamsApp(ctx, inputs, envInfo, tokenProvider) {
    const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    let archivedFile;
    if (inputs.appPackagePath) {
        if (!(await fs_extra_1.default.pathExists(inputs.appPackagePath))) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
        archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
    }
    else {
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    try {
        const appDefinition = await appStudio_1.AppStudioClient.importApp(archivedFile, appStudioToken, ctx.logProvider, true);
        ctx.logProvider.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", appDefinition.teamsAppId));
        return teamsfx_api_1.ok(appDefinition.teamsAppId);
    }
    catch (e) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e)));
    }
}
exports.updateTeamsApp = updateTeamsApp;
async function publishTeamsApp(ctx, inputs, envInfo, tokenProvider, telemetryProps) {
    var _a;
    let archivedFile;
    // User provided zip file
    if (inputs.appPackagePath) {
        if (await fs_extra_1.default.pathExists(inputs.appPackagePath)) {
            archivedFile = await fs_extra_1.default.readFile(inputs.appPackagePath);
        }
        else {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(inputs.appPackagePath)));
        }
    }
    else {
        const buildPackage = await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, envInfo, false, telemetryProps);
        if (buildPackage.isErr()) {
            return teamsfx_api_1.err(buildPackage.error);
        }
        archivedFile = await fs_extra_1.default.readFile(buildPackage.value);
    }
    const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_2.Constants.MANIFEST_FILE);
    if (!manifestFile) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_2.Constants.MANIFEST_FILE)));
    }
    const manifestString = manifestFile.getData().toString();
    const manifest = JSON.parse(manifestString);
    // manifest.id === externalID
    const appStudioTokenRes = await tokenProvider.getAccessToken({ scopes: tools_1.AppStudioScopes });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const existApp = await appStudio_1.AppStudioClient.getAppByTeamsAppId(manifest.id, appStudioTokenRes.value);
    if (existApp) {
        let executePublishUpdate = false;
        let description = `The app ${existApp.displayName} has already been submitted to tenant App Catalog.\nStatus: ${existApp.publishingState}\n`;
        if (existApp.lastModifiedDateTime) {
            description =
                description + `Last Modified: ${(_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString()}\n`;
        }
        description = description + "Do you want to submit a new update?";
        const res = await ctx.userInteraction.showMessage("warn", description, true, "Confirm");
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Confirm")
            executePublishUpdate = true;
        if (executePublishUpdate) {
            const appId = await appStudio_1.AppStudioClient.publishTeamsAppUpdate(manifest.id, archivedFile, appStudioTokenRes.value);
            return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: true });
        }
        else {
            throw results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppPublishCancelError.name, errors_1.AppStudioError.TeamsAppPublishCancelError.message(manifest.name.short));
        }
    }
    else {
        const appId = await appStudio_1.AppStudioClient.publishTeamsApp(manifest.id, archivedFile, appStudioTokenRes.value);
        return teamsfx_api_1.ok({ publishedAppId: appId, appName: manifest.name.short, update: false });
    }
}
exports.publishTeamsApp = publishTeamsApp;
/**
 * Build appPackage.{envName}.zip
 * @returns Path for built Teams app package
 */
async function buildTeamsAppPackage(projectSettings, projectPath, envInfo, withEmptyCapabilities = false, telemetryProps) {
    const buildFolderPath = path.join(projectPath, teamsfx_api_1.BuildFolderName, teamsfx_api_1.AppPackageFolderName);
    await fs_extra_1.default.ensureDir(buildFolderPath);
    const manifestRes = await utils_1.manifestUtils.getManifest(projectPath, envInfo, withEmptyCapabilities, telemetryProps);
    if (manifestRes.isErr()) {
        return teamsfx_api_1.err(manifestRes.error);
    }
    const manifest = manifestRes.value;
    if (!isUUID_1.default(manifest.id)) {
        manifest.id = uuid_1.v4();
    }
    if (withEmptyCapabilities) {
        manifest.bots = [];
        manifest.composeExtensions = [];
        manifest.configurableTabs = [];
        manifest.staticTabs = [];
        manifest.webApplicationInfo = undefined;
    }
    const appDirectory = await tools_1.getAppDirectory(projectPath);
    const colorFile = path.join(appDirectory, manifest.icons.color);
    if (!(await fs_extra_1.default.pathExists(colorFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(colorFile)));
    }
    const outlineFile = path.join(appDirectory, manifest.icons.outline);
    if (!(await fs_extra_1.default.pathExists(outlineFile))) {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(outlineFile)));
    }
    const zip = new adm_zip_1.default();
    zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
    // outline.png & color.png, relative path
    let dir = path.dirname(manifest.icons.color);
    zip.addLocalFile(colorFile, dir === "." ? "" : dir);
    dir = path.dirname(manifest.icons.outline);
    zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
    const zipFileName = path.join(buildFolderPath, `appPackage.${envInfo.envName}.zip`);
    zip.writeZip(zipFileName);
    const manifestFileName = path.join(buildFolderPath, `manifest.${envInfo.envName}.json`);
    if (await fs_extra_1.default.pathExists(manifestFileName)) {
        await fs_extra_1.default.chmod(manifestFileName, 0o777);
    }
    await fs_extra_1.default.writeFile(manifestFileName, JSON.stringify(manifest, null, 4));
    await fs_extra_1.default.chmod(manifestFileName, 0o444);
    if (tools_1.isSPFxProject(projectSettings)) {
        const spfxTeamsPath = `${projectPath}/SPFx/teams`;
        await fs_extra_1.default.copyFile(zipFileName, path.join(spfxTeamsPath, "TeamsSPFxApp.zip"));
        for (const file of await fs_extra_1.default.readdir(`${projectPath}/SPFx/teams/`)) {
            if (file.endsWith("color.png") &&
                manifest.icons.color &&
                !manifest.icons.color.startsWith("https://")) {
                const colorFile = `${appDirectory}/${manifest.icons.color}`;
                const color = await fs_extra_1.default.readFile(colorFile);
                await fs_extra_1.default.writeFile(path.join(spfxTeamsPath, file), color);
            }
            else if (file.endsWith("outline.png") &&
                manifest.icons.outline &&
                !manifest.icons.outline.startsWith("https://")) {
                const outlineFile = `${appDirectory}/${manifest.icons.outline}`;
                const outline = await fs_extra_1.default.readFile(outlineFile);
                await fs_extra_1.default.writeFile(path.join(spfxTeamsPath, file), outline);
            }
        }
    }
    return teamsfx_api_1.ok(zipFileName);
}
exports.buildTeamsAppPackage = buildTeamsAppPackage;
/**
 * Validate manifest
 * @returns an array of validation error strings
 */
async function validateManifest(manifest) {
    // Corner case: SPFx project validate without provision
    if (!isUUID_1.default(manifest.id)) {
        manifest.id = uuid_1.v4();
    }
    if (manifest.$schema) {
        try {
            const result = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
            return teamsfx_api_1.ok(result);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
            ]), constants_1.HelpLinks.WhyNeedProvision));
        }
    }
    else {
        return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
            localizeUtils_1.getLocalizedString("error.appstudio.validateSchemaNotDefined"),
        ]), constants_1.HelpLinks.WhyNeedProvision));
    }
}
exports.validateManifest = validateManifest;
async function updateManifest(ctx, inputs) {
    var _a, _b, _c, _d, _e;
    const teamsAppId = (_a = ctx.envInfo.state[constants_3.ComponentNames.AppManifest]) === null || _a === void 0 ? void 0 : _a.teamsAppId;
    let manifest;
    const manifestResult = await utils_1.manifestUtils.getManifest(inputs.projectPath, ctx.envInfo, false);
    if (manifestResult.isErr()) {
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"));
        const isProvisionSucceeded = ctx.envInfo.state["solution"].provisionSucceeded;
        if (manifestResult.error.name === errors_1.AppStudioError.GetRemoteConfigFailedError.name &&
            !isProvisionSucceeded) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.GetRemoteConfigFailedError.name, errors_1.AppStudioError.GetRemoteConfigFailedError.message(localizeUtils_1.getLocalizedString("error.appstudio.updateManifestFailed"), isProvisionSucceeded), constants_1.HelpLinks.WhyNeedProvision));
        }
        else {
            return teamsfx_api_1.err(manifestResult.error);
        }
    }
    else {
        manifest = manifestResult.value;
    }
    const manifestFileName = await utils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath);
    if (!(await fs_extra_1.default.pathExists(manifestFileName))) {
        const isProvisionSucceeded = ctx.envInfo.state["solution"].provisionSucceeded;
        if (!isProvisionSucceeded) {
            const msgs = errors_1.AppStudioError.FileNotFoundError.message(manifestFileName);
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, [
                msgs[0] + localizeUtils_1.getDefaultString("plugins.appstudio.provisionTip"),
                msgs[1] + localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTip"),
            ], constants_1.HelpLinks.WhyNeedProvision));
        }
        await buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
    }
    const existingManifest = await fs_extra_1.default.readJSON(manifestFileName);
    delete manifest.id;
    delete existingManifest.id;
    if (!lodash_1.default.isEqual(manifest, existingManifest)) {
        const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateManifestTip"), true, "Preview only", "Preview and update");
        const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview only") {
            buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
            return teamsfx_api_1.err(error);
        }
        else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Preview and update") {
            buildTeamsAppPackage(ctx.projectSetting, inputs.projectPath, ctx.envInfo);
        }
        else {
            return teamsfx_api_1.err(error);
        }
    }
    const appStudioTokenRes = await ctx.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: tools_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return teamsfx_api_1.err(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        const localUpdateTime = ctx.envInfo.state[constants_3.ComponentNames.AppManifest]
            .teamsAppUpdatedAt;
        if (localUpdateTime) {
            const app = await appStudio_1.AppStudioClient.getApp(teamsAppId, appStudioToken, ctx.logProvider);
            const devPortalUpdateTime = (_d = (_c = new Date(app.updatedAt)) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : -1;
            if (localUpdateTime < devPortalUpdateTime) {
                const res = await ctx.userInteraction.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.appstudio.updateOverwriteTip"), true, "Overwrite and update");
                if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === "Overwrite and update")) {
                    const error = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestCancelError.name, errors_1.AppStudioError.UpdateManifestCancelError.message(manifest.name.short));
                    return teamsfx_api_1.err(error);
                }
            }
        }
        const result = await updateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.info(localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedLog", teamsAppId));
        ctx.userInteraction
            .showMessage("info", localizeUtils_1.getLocalizedString("plugins.appstudio.teamsAppUpdatedNotice"), false, constants_2.Constants.VIEW_DEVELOPER_PORTAL)
            .then((res) => {
            if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === constants_2.Constants.VIEW_DEVELOPER_PORTAL) {
                ctx.userInteraction.openUrl(util.format(constants_2.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, result.value));
            }
        });
        return teamsfx_api_1.ok(teamsAppId);
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
        }
        else {
            return teamsfx_api_1.err(error);
        }
    }
}
exports.updateManifest = updateManifest;
//# sourceMappingURL=appStudio.js.map