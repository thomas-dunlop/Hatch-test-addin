// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TabDebugHandler = void 0;
const lodash_1 = require("lodash");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const localEnvProvider_1 = require("./localEnvProvider");
const crypto_1 = require("../../core/crypto");
const environment_1 = require("../../core/environment");
const projectSettingsLoader_1 = require("../../core/middleware/projectSettingsLoader");
const constants_1 = require("../../plugins/resource/frontend/constants");
const constants_2 = require("../constants");
const error_1 = require("./error");
class TabDebugHandler {
    constructor(projectPath, args) {
        this.projectPath = projectPath;
        this.args = args;
    }
    async setUp() {
        try {
            const checkArgsResult = await this.checkArgs();
            if (checkArgsResult.isErr()) {
                return teamsfx_api_1.err(checkArgsResult.error);
            }
            const projectSettingsResult = await projectSettingsLoader_1.loadProjectSettingsByProjectPath(this.projectPath, true);
            if (projectSettingsResult.isErr()) {
                return teamsfx_api_1.err(projectSettingsResult.error);
            }
            const projectSettingsV3 = projectSettingsResult.value;
            const cryptoProvider = new crypto_1.LocalCrypto(projectSettingsV3.projectId);
            const envInfoResult = await environment_1.environmentManager.loadEnvInfo(this.projectPath, cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (envInfoResult.isErr()) {
                return teamsfx_api_1.err(envInfoResult.error);
            }
            const envInfoV3 = envInfoResult.value;
            envInfoV3.state[constants_2.ComponentNames.TeamsTab] = envInfoV3.state[constants_2.ComponentNames.TeamsTab] || {};
            // set endpoint, domain, indexPath to state
            envInfoV3.state[constants_2.ComponentNames.TeamsTab].endpoint = this.args.baseUrl;
            envInfoV3.state[constants_2.ComponentNames.TeamsTab].domain = "localhost";
            envInfoV3.state[constants_2.ComponentNames.TeamsTab].indexPath = constants_1.Constants.FrontendIndexPath;
            await environment_1.environmentManager.writeEnvState(lodash_1.cloneDeep(envInfoV3.state), this.projectPath, cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            await this.setEnvs(envInfoV3);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async setEnvs(envInfoV3) {
        const localEnvProvider = new localEnvProvider_1.LocalEnvProvider(this.projectPath);
        const frontendEnvs = await localEnvProvider.loadFrontendLocalEnvs();
        frontendEnvs.template[localEnvProvider_1.LocalEnvKeys.frontend.template.Browser] = "none";
        frontendEnvs.template[localEnvProvider_1.LocalEnvKeys.frontend.template.Https] = "true";
        const url = new URL(envInfoV3.state[constants_2.ComponentNames.TeamsTab].endpoint);
        frontendEnvs.template[localEnvProvider_1.LocalEnvKeys.frontend.template.Port] = url.port;
        // certificate envs are set when cheking prerequisites
        await localEnvProvider.saveFrontendLocalEnvs(frontendEnvs);
    }
    async checkArgs() {
        if (!this.args.baseUrl) {
            return teamsfx_api_1.err(error_1.InvalidTabDebugArgsError());
        }
        const pattern = /https:\/\/localhost:\d+/;
        const result = this.args.baseUrl.match(pattern);
        if (!result) {
            return teamsfx_api_1.err(error_1.InvalidTabDebugArgsError());
        }
        return teamsfx_api_1.ok(true);
    }
}
exports.TabDebugHandler = TabDebugHandler;
//# sourceMappingURL=tab.js.map