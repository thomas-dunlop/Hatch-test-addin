// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotDebugHandler = void 0;
const lodash_1 = require("lodash");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../common/tools");
const utils_1 = require("../../common/utils");
const crypto_1 = require("../../core/crypto");
const environment_1 = require("../../core/environment");
const projectSettingsLoader_1 = require("../../core/middleware/projectSettingsLoader");
const aadRegistration_1 = require("../../plugins/resource/bot/aadRegistration");
const appStudio_1 = require("../../plugins/resource/bot/appStudio/appStudio");
const constants_1 = require("../../plugins/resource/bot/constants");
const strings_1 = require("../../plugins/resource/bot/resources/strings");
const common_1 = require("../../plugins/resource/bot/utils/common");
const resourceNameFactory_1 = require("../../plugins/resource/bot/utils/resourceNameFactory");
const constants_2 = require("../constants");
const constants_3 = require("./constants");
const error_1 = require("./error");
const localEnvProvider_1 = require("./localEnvProvider");
class BotDebugHandler {
    constructor(projectPath, args, m365TokenProvider, logger, telemetry, ui) {
        this.projectPath = projectPath;
        this.args = args;
        this.m365TokenProvider = m365TokenProvider;
        this.logger = logger;
        this.telemetry = telemetry;
        this.ui = ui;
    }
    // TODO: output message
    async setUp() {
        try {
            const checkArgsResult = await this.checkArgs();
            if (checkArgsResult.isErr()) {
                return teamsfx_api_1.err(checkArgsResult.error);
            }
            const projectSettingsResult = await projectSettingsLoader_1.loadProjectSettingsByProjectPath(this.projectPath, true);
            if (projectSettingsResult.isErr()) {
                return teamsfx_api_1.err(projectSettingsResult.error);
            }
            const projectSettingsV3 = projectSettingsResult.value;
            const cryptoProvider = new crypto_1.LocalCrypto(projectSettingsV3.projectId);
            const envInfoResult = await environment_1.environmentManager.loadEnvInfo(this.projectPath, cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            if (envInfoResult.isErr()) {
                return teamsfx_api_1.err(envInfoResult.error);
            }
            const envInfoV3 = envInfoResult.value;
            envInfoV3.state[constants_2.ComponentNames.TeamsBot] = envInfoV3.state[constants_2.ComponentNames.TeamsBot] || {};
            // set botId, botPassword from args to state
            if (checkArgsResult.value) {
                envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId = this.args.botId;
                envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword = this.args.botPassword;
            }
            // set validDomain, domain, siteEndpoint from args to state
            const url = new URL(this.args.botMessagingEndpoint);
            envInfoV3.state[constants_2.ComponentNames.TeamsBot].validDomain = url.hostname;
            envInfoV3.state[constants_2.ComponentNames.TeamsBot].domain = url.hostname;
            envInfoV3.state[constants_2.ComponentNames.TeamsBot].siteEndpoint = url.origin;
            // not using existing bot and not yet created
            if (!envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId) {
                const tokenResult = await this.m365TokenProvider.getAccessToken({
                    scopes: tools_1.GraphScopes,
                });
                if (tokenResult.isErr()) {
                    return teamsfx_api_1.err(tokenResult.error);
                }
                const displayName = resourceNameFactory_1.ResourceNameFactory.createCommonName(common_1.genUUID(), projectSettingsV3.appName, constants_1.MaxLengths.AAD_DISPLAY_NAME);
                const botAuthCredential = await aadRegistration_1.AADRegistration.registerAADAppAndGetSecretByGraph(tokenResult.value, displayName);
                // set objectId, botId, botPassword to state
                envInfoV3.state[constants_2.ComponentNames.TeamsBot].objectId = botAuthCredential.objectId;
                envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId = botAuthCredential.clientId;
                envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword = botAuthCredential.clientSecret;
            }
            const tokenResult = await this.m365TokenProvider.getAccessToken({
                scopes: tools_1.AppStudioScopes,
            });
            if (tokenResult.isErr()) {
                return teamsfx_api_1.err(tokenResult.error);
            }
            const botReg = {
                botId: envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId,
                name: utils_1.convertToAlphanumericOnly(projectSettingsV3.appName) +
                    strings_1.PluginLocalDebug.LOCAL_DEBUG_SUFFIX,
                description: "",
                iconUrl: "",
                messagingEndpoint: this.args.botMessagingEndpoint,
                callingEndpoint: "",
            };
            await appStudio_1.AppStudio.createBotRegistration(tokenResult.value, botReg);
            await appStudio_1.AppStudio.updateMessageEndpoint(tokenResult.value, envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId, this.args.botMessagingEndpoint);
            await environment_1.environmentManager.writeEnvState(lodash_1.cloneDeep(envInfoV3.state), this.projectPath, cryptoProvider, environment_1.environmentManager.getLocalEnvName(), true);
            await this.setEnvs(envInfoV3);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        catch (error) {
            return teamsfx_api_1.err(teamsfx_api_1.assembleError(error, error_1.errorSource));
        }
    }
    async setEnvs(envInfoV3) {
        const localEnvProvider = new localEnvProvider_1.LocalEnvProvider(this.projectPath);
        const botEnvs = await localEnvProvider.loadBotLocalEnvs();
        botEnvs.template[localEnvProvider_1.LocalEnvKeys.bot.template.BotId] =
            envInfoV3.state[constants_2.ComponentNames.TeamsBot].botId;
        botEnvs.template[localEnvProvider_1.LocalEnvKeys.bot.template.BotPassword] =
            envInfoV3.state[constants_2.ComponentNames.TeamsBot].botPassword;
        localEnvProvider.saveBotLocalEnvs(botEnvs);
    }
    // return true if using existing bot
    async checkArgs() {
        // TODO: allow botPassword to be set in other places (like env) instead of tasks.json
        let flag = false;
        if (this.args.botId && this.args.botPassword) {
            flag = true;
        }
        else if (this.args.botId || this.args.botPassword) {
            return teamsfx_api_1.err(error_1.InvalidExistingBotArgsError());
        }
        if (!this.args.botMessagingEndpoint || this.args.botMessagingEndpoint.trim().length === 0) {
            return teamsfx_api_1.err(error_1.BotMessagingEndpointMissingError());
        }
        if (this.args.botMessagingEndpoint.includes(constants_3.botTunnelEndpointPlaceholder)) {
            // TODO: get bot endpoint from tunnel manager
            const botEndpoint = "";
            this.args.botMessagingEndpoint = this.args.botMessagingEndpoint.replace(constants_3.botTunnelEndpointPlaceholder, botEndpoint);
        }
        return teamsfx_api_1.ok(flag);
    }
}
exports.BotDebugHandler = BotDebugHandler;
//# sourceMappingURL=bot.js.map