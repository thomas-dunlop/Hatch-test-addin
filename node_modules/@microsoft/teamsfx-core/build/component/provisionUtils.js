"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.provisionUtils = exports.findSubscriptionFromList = exports.getTeamsAppTenantId = exports.getSubscriptionId = exports.ProvisionUtils = void 0;
const arm_resources_1 = require("@azure/arm-resources");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const uuid_1 = require("uuid");
const constants_1 = require("../common/constants");
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const telemetry_1 = require("../common/telemetry");
const tools_1 = require("../common/tools");
const utils_1 = require("../common/utils");
const core_1 = require("../core");
const constants_2 = require("../plugins/solution/fx-solution/constants");
const ResourceGroupHelper_1 = require("../plugins/solution/fx-solution/utils/ResourceGroupHelper");
const util_1 = require("../plugins/solution/fx-solution/utils/util");
const utils_2 = require("../plugins/solution/fx-solution/v2/utils");
const constants_3 = require("../plugins/solution/fx-solution/v3/constants");
const constants_4 = require("./constants");
const constants_5 = require("./resource/appManifest/constants");
const utils_3 = require("./utils");
class ProvisionUtils {
    async preProvision(context, inputs) {
        const ctx = context;
        const envInfo = ctx.envInfo;
        const hasBotServiceCreatedBefore = util_1.hasBotServiceCreated(envInfo);
        // 1. check M365 tenant
        envInfo.state[constants_4.ComponentNames.AppManifest] = envInfo.state[constants_4.ComponentNames.AppManifest] || {};
        envInfo.state.solution = envInfo.state.solution || {};
        const appManifest = envInfo.state[constants_4.ComponentNames.AppManifest];
        const solutionConfig = envInfo.state.solution;
        solutionConfig.provisionSucceeded = false;
        const tenantIdInConfig = appManifest.tenantId;
        const isLocalDebug = envInfo.envName === "local";
        const tenantInfoInTokenRes = await this.getM365TenantId(ctx.tokenProvider.m365TokenProvider);
        if (tenantInfoInTokenRes.isErr()) {
            return teamsfx_api_1.err(tenantInfoInTokenRes.error);
        }
        const tenantIdInToken = tenantInfoInTokenRes.value.tenantIdInToken;
        const hasSwitchedM365Tenant = !!tenantIdInConfig && !!tenantIdInToken && tenantIdInToken !== tenantIdInConfig;
        if (!isLocalDebug) {
            if (hasSwitchedM365Tenant) {
                utils_3.resetEnvInfoWhenSwitchM365(envInfo);
            }
        }
        else {
            const res = await utils_2.checkWhetherLocalDebugM365TenantMatches(envInfo, ctx.telemetryReporter, tenantIdInConfig, ctx.tokenProvider.m365TokenProvider, inputs.projectPath);
            if (res.isErr()) {
                return teamsfx_api_1.err(res.error);
            }
        }
        envInfo.state[constants_4.ComponentNames.AppManifest] = envInfo.state[constants_4.ComponentNames.AppManifest] || {};
        envInfo.state[constants_4.ComponentNames.AppManifest].tenantId = tenantIdInToken;
        envInfo.state.solution.teamsAppTenantId = tenantIdInToken;
        core_1.globalVars.m365TenantId = tenantIdInToken;
        // 3. check Azure configs
        if (projectSettingsHelperV3_1.hasAzureResourceV3(ctx.projectSetting) && envInfo.envName !== "local") {
            // ask common question and fill in solution config
            const subscriptionIdInState = envInfo.state.solution.subscriptionId;
            const solutionConfigRes = await this.fillInAzureConfigs(ctx, inputs, envInfo, ctx.tokenProvider);
            if (solutionConfigRes.isErr()) {
                return teamsfx_api_1.err(solutionConfigRes.error);
            }
            const consentResult = await this.askForProvisionConsent(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, tenantInfoInTokenRes.value.tenantUserName, true, tenantIdInConfig, subscriptionIdInState);
            if (consentResult.isErr()) {
                return teamsfx_api_1.err(consentResult.error);
            }
            // create resource group if needed
            if (solutionConfig.needCreateResourceGroup) {
                const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(solutionConfig.resourceGroupName, ctx.tokenProvider.azureAccountProvider, solutionConfig.subscriptionId, solutionConfig.location);
                if (createRgRes.isErr()) {
                    return teamsfx_api_1.err(createRgRes.error);
                }
            }
            if (solutionConfigRes.value.hasSwitchedSubscription || hasSwitchedM365Tenant) {
                const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, hasBotServiceCreatedBefore);
                if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                    return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
                }
            }
        }
        else if (hasSwitchedM365Tenant && !isLocalDebug) {
            const consentResult = await this.askForProvisionConsent(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, false, tenantInfoInTokenRes.value.tenantUserName, false, tenantIdInConfig);
            if (consentResult.isErr()) {
                return teamsfx_api_1.err(consentResult.error);
            }
            const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, false, false);
            if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * make sure subscription is correct before provision
     *
     */
    async checkProvisionSubscription(ctx, envInfo, azureAccountProvider, targetSubscriptionIdFromCLI) {
        var _a, _b;
        const subscriptionIdInConfig = (_a = envInfo.config.azure) === null || _a === void 0 ? void 0 : _a.subscriptionId;
        const subscriptionNameInConfig = ((_b = envInfo.config.azure) === null || _b === void 0 ? void 0 : _b.subscriptionName) || subscriptionIdInConfig;
        const subscriptionIdInState = envInfo.state.solution.subscriptionId;
        const subscriptionNameInState = envInfo.state.solution.subscriptionName || subscriptionIdInState;
        if (!subscriptionIdInState && !subscriptionIdInConfig && !targetSubscriptionIdFromCLI) {
            const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
            if (!subscriptionInAccount) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, "Failed to select subscription"));
            }
            else {
                this.updateEnvInfoSubscription(envInfo, subscriptionInAccount);
                ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
            }
        }
        // make sure the user is logged in
        await azureAccountProvider.getAccountCredentialAsync(true);
        // verify valid subscription (permission)
        const subscriptions = await azureAccountProvider.listSubscriptions();
        if (targetSubscriptionIdFromCLI) {
            const targetSubscriptionInfo = findSubscriptionFromList(targetSubscriptionIdFromCLI, subscriptions);
            if (!targetSubscriptionInfo) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, `The subscription '${targetSubscriptionIdFromCLI}' for '${envInfo.envName}' environment is not found in the current account, please use the right Azure account or check the subscription parameter.`));
            }
            else {
                this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
                ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
            }
        }
        if (subscriptionIdInConfig) {
            const targetConfigSubInfo = findSubscriptionFromList(subscriptionIdInConfig, subscriptions);
            if (!targetConfigSubInfo) {
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, `The subscription '${subscriptionIdInConfig}'(${subscriptionNameInConfig}) for '${envInfo.envName}' environment is not found in the current account, please use the right Azure account or check the '${teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, envInfo.envName)}' file.`));
            }
            else {
                return this.compareWithStateSubscription(ctx, envInfo, targetConfigSubInfo, subscriptionIdInState);
            }
        }
        else {
            const targetStateSubInfo = subscriptions.find((item) => item.subscriptionId === subscriptionIdInState);
            const subscriptionInAccount = await azureAccountProvider.getSelectedSubscription(true);
            if (!subscriptionInAccount) {
                if (targetStateSubInfo) {
                    this.updateEnvInfoSubscription(envInfo, targetStateSubInfo);
                    ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
                    return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
                }
                else {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.SubscriptionNotFound, `The subscription '${subscriptionIdInState}'(${subscriptionNameInState}) for '${envInfo.envName}' environment is not found in the current account, please use the right Azure account.`));
                }
            }
            else {
                return this.compareWithStateSubscription(ctx, envInfo, subscriptionInAccount, subscriptionIdInState);
            }
        }
    }
    updateEnvInfoSubscription(envInfo, subscriptionInfo) {
        envInfo.state.solution.subscriptionId = subscriptionInfo.subscriptionId;
        envInfo.state.solution.subscriptionName = subscriptionInfo.subscriptionName;
        envInfo.state.solution.tenantId = subscriptionInfo.tenantId;
    }
    async compareWithStateSubscription(ctx, envInfo, targetSubscriptionInfo, subscriptionInStateId) {
        const hasSwitchedSubscription = !!subscriptionInStateId && targetSubscriptionInfo.subscriptionId !== subscriptionInStateId;
        if (hasSwitchedSubscription) {
            this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
            this.clearEnvInfoStateResource(envInfo);
            ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
            return teamsfx_api_1.ok({ hasSwitchedSubscription: true });
        }
        else {
            this.updateEnvInfoSubscription(envInfo, targetSubscriptionInfo);
            ctx.logProvider.info(`[${constants_1.PluginDisplayName.Solution}] checkAzureSubscription pass!`);
            return teamsfx_api_1.ok({ hasSwitchedSubscription: false });
        }
    }
    // clear resources related info in envInfo so that we could provision successfully using new sub.
    clearEnvInfoStateResource(envInfo) {
        envInfo.state.solution.resourceGroupName = "";
        envInfo.state.solution.resourceNameSuffix = "";
        const keysToClear = [
            constants_3.BuiltInFeaturePluginNames.bot,
            constants_3.BuiltInFeaturePluginNames.frontend,
            constants_3.BuiltInFeaturePluginNames.function,
            constants_3.BuiltInFeaturePluginNames.identity,
            constants_3.BuiltInFeaturePluginNames.keyVault,
            constants_3.BuiltInFeaturePluginNames.sql,
            constants_3.BuiltInFeaturePluginNames.simpleAuth,
            constants_4.ComponentNames.TeamsBot,
            constants_4.ComponentNames.TeamsTab,
            constants_4.ComponentNames.TeamsApi,
            constants_4.ComponentNames.Identity,
            constants_4.ComponentNames.KeyVault,
            constants_4.ComponentNames.AzureSQL,
        ];
        const keysToModify = [constants_3.BuiltInFeaturePluginNames.apim, constants_4.ComponentNames.APIM];
        const keys = Object.keys(envInfo.state);
        for (const key of keys) {
            if (keysToClear.includes(key)) {
                delete envInfo.state[key];
            }
            if (keysToModify.includes(key)) {
                delete envInfo.state[key]["serviceResourceId"];
            }
        }
    }
    /**
     * Asks common questions and puts the answers in the global namespace of SolutionConfig
     *
     */
    async fillInAzureConfigs(ctx, inputs, envInfo, tokenProvider) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        //1. check subscriptionId
        (_a = ctx.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscriptionStart, inputs.env ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(inputs.env) } : {});
        const targetSubscriptionId = inputs.targetSubscriptionId;
        const subscriptionResult = await this.checkProvisionSubscription(ctx, envInfo, tokenProvider.azureAccountProvider, targetSubscriptionId);
        if (subscriptionResult.isErr()) {
            return teamsfx_api_1.err(subscriptionResult.error);
        }
        (_b = ctx.telemetryReporter) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckSubscription, {
            [telemetry_1.TelemetryProperty.Env]: !inputs.env ? "" : tools_1.getHashedEnv(inputs.env),
            [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: subscriptionResult.value.hasSwitchedSubscription.toString(),
        });
        // Note setSubscription here will change the token returned by getAccountCredentialAsync according to the subscription selected.
        // So getting azureToken needs to precede setSubscription.
        const azureToken = await tokenProvider.azureAccountProvider.getAccountCredentialAsync();
        if (azureToken === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.NotLoginToAzure, "Login to Azure using the Azure Account extension"));
        }
        //2. check resource group
        (_c = ctx.telemetryReporter) === null || _c === void 0 ? void 0 : _c.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroupStart, inputs.env ? { [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(inputs.env) } : {});
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, envInfo.state.solution.subscriptionId);
        // Resource group info precedence are:
        //   0. ctx.answers, for VS targetResourceGroupName and targetResourceLocationName to create a new rg
        //   1. ctx.answers, for CLI --resource-group argument, only support existing resource group
        //   2. env config (config.{envName}.json), for user customization, only support existing resource group
        //   3. states (state.{envName}.json), for re-provision
        //   4. asking user with a popup
        const resourceGroupNameFromEnvConfig = (_d = envInfo.config.azure) === null || _d === void 0 ? void 0 : _d.resourceGroupName;
        const resourceGroupNameFromState = envInfo.state.solution.resourceGroupName;
        const resourceGroupLocationFromState = envInfo.state.solution.location;
        const appName = utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName);
        const defaultResourceGroupName = `${lodash_1.snakeCase(appName)}${"-" + envInfo.envName}-rg`;
        let resourceGroupInfo;
        const telemetryProperties = {};
        if (inputs.env) {
            telemetryProperties[telemetry_1.TelemetryProperty.Env] = tools_1.getHashedEnv(inputs.env);
        }
        if (inputs.targetResourceGroupName) {
            const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(inputs.targetResourceGroupName, rmClient);
            if (getRes.isErr()) {
                // support vs to create a new resource group
                if (inputs.platform === teamsfx_api_1.Platform.VS && inputs.targetResourceLocationName) {
                    resourceGroupInfo = {
                        createNewResourceGroup: true,
                        name: inputs.targetResourceGroupName,
                        location: inputs.targetResourceLocationName,
                    };
                }
                else
                    return teamsfx_api_1.err(getRes.error);
            }
            else {
                if (!getRes.value) {
                    // Currently we do not support creating resource group from command line arguments
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, `Resource group '${inputs.targetResourceGroupName}' does not exist, please specify an existing resource group.`));
                }
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.CommandLine;
                resourceGroupInfo = getRes.value;
            }
        }
        else if (resourceGroupNameFromEnvConfig) {
            const resourceGroupName = resourceGroupNameFromEnvConfig;
            const getRes = await ResourceGroupHelper_1.resourceGroupHelper.getResourceGroupInfo(resourceGroupName, rmClient);
            if (getRes.isErr())
                return teamsfx_api_1.err(getRes.error);
            if (!getRes.value) {
                // Currently we do not support creating resource group by input config, so just throw an error.
                const envFile = teamsfx_api_1.EnvConfigFileNameTemplate.replace(teamsfx_api_1.EnvNamePlaceholder, inputs.envName);
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, constants_2.SolutionError.ResourceGroupNotFound, `Resource group '${resourceGroupName}' does not exist, please check your '${envFile}' file.`));
            }
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.EnvConfig;
            resourceGroupInfo = getRes.value;
        }
        else if (resourceGroupNameFromState && resourceGroupLocationFromState) {
            const checkRes = await ResourceGroupHelper_1.resourceGroupHelper.checkResourceGroupExistence(resourceGroupNameFromState, rmClient);
            if (checkRes.isErr()) {
                return teamsfx_api_1.err(checkRes.error);
            }
            const exist = checkRes.value;
            resourceGroupInfo = {
                createNewResourceGroup: !exist,
                name: resourceGroupNameFromState,
                location: resourceGroupLocationFromState,
            };
            telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                telemetry_1.CustomizeResourceGroupType.EnvState;
        }
        else {
            const resourceGroupInfoResult = await ResourceGroupHelper_1.resourceGroupHelper.askResourceGroupInfo(ctx, inputs, tokenProvider.azureAccountProvider, rmClient, defaultResourceGroupName);
            if (resourceGroupInfoResult.isErr()) {
                return teamsfx_api_1.err(resourceGroupInfoResult.error);
            }
            resourceGroupInfo = resourceGroupInfoResult.value;
            if (resourceGroupInfo.createNewResourceGroup) {
                if (resourceGroupInfo.name === defaultResourceGroupName) {
                    telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                        telemetry_1.CustomizeResourceGroupType.InteractiveCreateDefault;
                }
                else {
                    telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                        telemetry_1.CustomizeResourceGroupType.InteractiveCreateCustomized;
                }
            }
            else {
                telemetryProperties[telemetry_1.TelemetryProperty.CustomizeResourceGroupType] =
                    telemetry_1.CustomizeResourceGroupType.InteractiveUseExisting;
            }
        }
        (_e = ctx.telemetryReporter) === null || _e === void 0 ? void 0 : _e.sendTelemetryEvent(telemetry_1.TelemetryEvent.CheckResourceGroup, telemetryProperties);
        envInfo.state.solution.needCreateResourceGroup = resourceGroupInfo.createNewResourceGroup;
        envInfo.state.solution.resourceGroupName = resourceGroupInfo.name;
        envInfo.state.solution.location = resourceGroupInfo.location;
        (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.info(`[${constants_1.PluginDisplayName.Solution}] check resource group pass!`);
        (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(`[${constants_1.PluginDisplayName.Solution}] check teamsAppTenantId pass!`);
        //resourceNameSuffix
        const resourceNameSuffix = ((_h = envInfo.config.azure) === null || _h === void 0 ? void 0 : _h.resourceNameSuffix) ||
            envInfo.state.solution.resourceNameSuffix ||
            uuid_1.v4().substr(0, 6);
        envInfo.state.solution.resourceNameSuffix = resourceNameSuffix;
        (_j = ctx.logProvider) === null || _j === void 0 ? void 0 : _j.info(`[${constants_1.PluginDisplayName.Solution}] check resourceNameSuffix pass!`);
        return teamsfx_api_1.ok({ hasSwitchedSubscription: subscriptionResult.value.hasSwitchedSubscription });
    }
    async getM365TenantId(m365TokenProvider) {
        // Just to trigger M365 login before the concurrent execution of localDebug.
        // Because concurrent execution of localDebug may getAccessToken() concurrently, which
        // causes 2 M365 logins before the token caching in common lib takes effect.
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: constants_5.AppStudioScopes });
        if (appStudioTokenRes.isErr()) {
            return teamsfx_api_1.err(appStudioTokenRes.error);
        }
        const appStudioTokenJsonRes = await m365TokenProvider.getJsonObject({
            scopes: constants_5.AppStudioScopes,
        });
        const appStudioTokenJson = appStudioTokenJsonRes.isOk()
            ? appStudioTokenJsonRes.value
            : undefined;
        if (appStudioTokenJson === undefined) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoAppStudioToken, localizeUtils_1.getDefaultString("error.NoAppStudioToken"), localizeUtils_1.getLocalizedString("error.NoAppStudioToken")));
        }
        const tenantIdInToken = appStudioTokenJson.tid;
        const tenantUserName = appStudioTokenJson.upn;
        if (!tenantIdInToken || !(typeof tenantIdInToken === "string")) {
            return teamsfx_api_1.err(new teamsfx_api_1.SystemError(constants_2.SolutionSource, constants_2.SolutionError.NoTeamsAppTenantId, localizeUtils_1.getDefaultString("error.NoTeamsAppTenantId"), localizeUtils_1.getLocalizedString("error.NoTeamsAppTenantId")));
        }
        return teamsfx_api_1.ok({ tenantIdInToken, tenantUserName });
    }
    async askForProvisionConsent(ctx, azureAccountProvider, envInfo, hasSwitchedM365Tenant, hasSwitchedSubscription, m365AccountName, hasAzureResource, previousM365TenantId, previousSubscriptionId) {
        var _a, _b, _c, _d, _e;
        const azureToken = await azureAccountProvider.getAccountCredentialAsync();
        const username = azureToken.username || "";
        const subscriptionId = ((_a = envInfo.state.solution) === null || _a === void 0 ? void 0 : _a.subscriptionId) || "";
        const subscriptionName = ((_b = envInfo.state.solution) === null || _b === void 0 ? void 0 : _b.subscriptionName) || "";
        const m365TenantId = ((_c = envInfo.state.solution) === null || _c === void 0 ? void 0 : _c.teamsAppTenantId) || "";
        let switchedNotice = "";
        if (hasSwitchedM365Tenant && hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedM365AccountAndAzureSubscriptionNotice");
        }
        else if (hasSwitchedM365Tenant && !hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedM365AccountNotice");
        }
        else if (!hasSwitchedM365Tenant && hasSwitchedSubscription) {
            switchedNotice = localizeUtils_1.getLocalizedString("core.provision.switchedAzureSubscriptionNotice");
            const botResource = (_d = envInfo.state[constants_3.BuiltInFeaturePluginNames.bot]) !== null && _d !== void 0 ? _d : envInfo.state[constants_4.ComponentNames.TeamsBot];
            const newBotNotice = !!botResource && !!botResource["resourceId"]
                ? localizeUtils_1.getLocalizedString("core.provision.createNewAzureBotNotice")
                : "";
            switchedNotice = switchedNotice + newBotNotice;
        }
        const azureAccountInfo = localizeUtils_1.getLocalizedString("core.provision.azureAccount", username);
        const azureSubscriptionInfo = localizeUtils_1.getLocalizedString("core.provision.azureSubscription", subscriptionName ? subscriptionName : subscriptionId);
        const m365AccountInfo = localizeUtils_1.getLocalizedString("core.provision.m365Account", m365AccountName ? m365AccountName : m365TenantId);
        let accountsInfo = "";
        if (!switchedNotice && !hasAzureResource) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        else if (!switchedNotice && hasAzureResource) {
            accountsInfo = [azureAccountInfo, azureSubscriptionInfo, m365AccountInfo].join("\n");
        }
        else {
            // switchedNotice
            accountsInfo = hasAzureResource
                ? [switchedNotice, azureAccountInfo, azureSubscriptionInfo, m365AccountInfo].join("\n")
                : [switchedNotice, m365AccountInfo].join("\n");
        }
        const confirmMsg = hasAzureResource
            ? localizeUtils_1.getLocalizedString("core.provision.confirmEnvAndCostNotice", envInfo.envName)
            : hasSwitchedM365Tenant
                ? localizeUtils_1.getLocalizedString("core.provision.confirmEnvOnlyNotice", envInfo.envName)
                : "";
        const provisionText = localizeUtils_1.getLocalizedString("core.provision.provision");
        const learnMoreText = localizeUtils_1.getLocalizedString("core.provision.learnMore");
        const items = hasSwitchedM365Tenant || hasSwitchedSubscription
            ? [provisionText, learnMoreText]
            : [provisionText];
        let confirm;
        do {
            const confirmRes = await ctx.userInteraction.showMessage("warn", accountsInfo + "\n\n" + confirmMsg, true, ...items);
            confirm = (confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) ? confirmRes.value : undefined;
            (_e = ctx.telemetryReporter) === null || _e === void 0 ? void 0 : _e.sendTelemetryEvent(telemetry_1.TelemetryEvent.ConfirmProvision, envInfo.envName
                ? {
                    [telemetry_1.TelemetryProperty.Env]: tools_1.getHashedEnv(envInfo.envName),
                    [telemetry_1.TelemetryProperty.HasSwitchedM365Tenant]: hasSwitchedM365Tenant.toString(),
                    [telemetry_1.TelemetryProperty.HasSwitchedSubscription]: hasSwitchedSubscription.toString(),
                    [constants_2.SolutionTelemetryProperty.SubscriptionId]: getSubscriptionId(envInfo.state),
                    [constants_2.SolutionTelemetryProperty.M365TenantId]: getTeamsAppTenantId(envInfo.state),
                    [constants_2.SolutionTelemetryProperty.PreviousM365TenantId]: previousM365TenantId,
                    [constants_2.SolutionTelemetryProperty.PreviousSubsriptionId]: previousSubscriptionId !== null && previousSubscriptionId !== void 0 ? previousSubscriptionId : "",
                    [constants_2.SolutionTelemetryProperty.ConfirmRes]: !confirm
                        ? "Error"
                        : confirm === learnMoreText
                            ? "Learn more"
                            : confirm === provisionText
                                ? "Provision"
                                : "",
                }
                : {});
            if (confirm !== provisionText) {
                if (confirm === learnMoreText) {
                    ctx.userInteraction.openUrl("https://aka.ms/teamsfx-switch-tenant-or-subscription-help");
                }
                else {
                    return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.SolutionSource, "CancelProvision", "CancelProvision"));
                }
            }
        } while (confirm === learnMoreText);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
exports.ProvisionUtils = ProvisionUtils;
function getSubscriptionId(state) {
    if (state && state[constants_2.GLOBAL_CONFIG] && state[constants_2.GLOBAL_CONFIG][constants_2.SUBSCRIPTION_ID]) {
        return state[constants_2.GLOBAL_CONFIG][constants_2.SUBSCRIPTION_ID];
    }
    return "";
}
exports.getSubscriptionId = getSubscriptionId;
function getTeamsAppTenantId(state) {
    if (state && state[constants_2.GLOBAL_CONFIG] && state[constants_2.GLOBAL_CONFIG][constants_2.REMOTE_TEAMS_APP_TENANT_ID]) {
        return state[constants_2.GLOBAL_CONFIG][constants_2.REMOTE_TEAMS_APP_TENANT_ID];
    }
    return "";
}
exports.getTeamsAppTenantId = getTeamsAppTenantId;
function findSubscriptionFromList(subscriptionId, subscriptions) {
    return subscriptions.find((item) => item.subscriptionId === subscriptionId);
}
exports.findSubscriptionFromList = findSubscriptionFromList;
exports.provisionUtils = new ProvisionUtils();
//# sourceMappingURL=provisionUtils.js.map