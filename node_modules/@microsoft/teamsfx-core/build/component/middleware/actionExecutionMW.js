"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionExecutionMW = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const globalVars_1 = require("../../core/globalVars");
const constants_1 = require("../constants");
const telemetry_1 = require("../telemetry");
function ActionExecutionMW(action) {
    return async (ctx, next) => {
        var _a;
        const componentName = ((_a = ctx.self) === null || _a === void 0 ? void 0 : _a.constructor.name) || action.componentName;
        const telemetryComponentName = action.telemetryComponentName || componentName;
        const methodName = ctx.method;
        const actionName = `${componentName}.${methodName}`;
        globalVars_1.TOOLS.logProvider.info(`execute [${actionName}] start!`);
        const eventName = action.telemetryEventName || methodName;
        const telemetryProps = {
            [constants_1.TelemetryConstants.properties.component]: telemetryComponentName,
        };
        let progressBar;
        try {
            // send start telemetry
            if (action.enableTelemetry) {
                if (action.telemetryProps)
                    lodash_1.assign(telemetryProps, action.telemetryProps);
                telemetry_1.sendStartEvent(eventName, telemetryProps);
                telemetry_1.sendMigratedStartEvent(eventName, ctx.arguments[0], ctx.arguments[1], telemetryProps);
            }
            // run question model
            if (action.question) {
                const context = ctx.arguments[0];
                const inputs = ctx.arguments[1];
                const getQuestionRes = await action.question(context, inputs);
                if (getQuestionRes.isErr())
                    throw getQuestionRes.error;
                const node = getQuestionRes.value;
                if (node) {
                    const askQuestionRes = await teamsfx_api_1.traverse(node, inputs, context.userInteraction, context.telemetryReporter);
                    if (askQuestionRes.isErr())
                        throw askQuestionRes.error;
                }
            }
            // progress bar
            if (action.enableProgressBar) {
                progressBar = globalVars_1.TOOLS.ui.createProgressBar(action.progressTitle || methodName, action.progressSteps || 1);
                await progressBar.start();
            }
            if (action.enableTelemetry || action.enableProgressBar) {
                const actionContext = {
                    progressBar: progressBar,
                    telemetryProps: telemetryProps,
                };
                ctx.arguments.push(actionContext);
            }
            await next();
            if (ctx.result.isErr())
                throw ctx.result.error;
            // send end telemetry
            if (action.enableTelemetry) {
                telemetry_1.sendSuccessEvent(eventName, telemetryProps);
                telemetry_1.sendMigratedSuccessEvent(eventName, ctx.arguments[0], ctx.arguments[1], telemetryProps);
            }
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true));
            globalVars_1.TOOLS.logProvider.info(`execute [${actionName}] success!`);
        }
        catch (e) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(false));
            let fxError;
            if (action.errorHandler) {
                fxError = action.errorHandler(e, telemetryProps);
            }
            else {
                fxError = teamsfx_api_1.assembleError(e);
                if (fxError.source === "unknown") {
                    fxError.source = action.errorSource || fxError.source;
                    if (fxError instanceof teamsfx_api_1.UserError) {
                        fxError.helpLink = fxError.helpLink || action.errorHelpLink;
                    }
                    if (fxError instanceof teamsfx_api_1.SystemError) {
                        fxError.issueLink = fxError.issueLink || action.errorIssueLink;
                    }
                }
            }
            // send error telemetry
            if (action.enableTelemetry) {
                telemetry_1.sendErrorEvent(eventName, fxError, telemetryProps);
                telemetry_1.sendMigratedErrorEvent(eventName, fxError, ctx.arguments[0], ctx.arguments[1], telemetryProps);
            }
            globalVars_1.TOOLS.logProvider.info(`execute [${actionName}] failed!`);
            ctx.result = teamsfx_api_1.err(fxError);
        }
    };
}
exports.ActionExecutionMW = ActionExecutionMW;
//# sourceMappingURL=actionExecutionMW.js.map