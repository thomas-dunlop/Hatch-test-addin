"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionNodeChecker = exports.AzureNodeChecker = exports.SPFxNodeChecker = exports.getInstalledNodeVersion = exports.NodeChecker = void 0;
const depsError_1 = require("../depsError");
const cpUtils_1 = require("../util/cpUtils");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const message_1 = require("../constant/message");
const helpLink_1 = require("../constant/helpLink");
const NodeName = "Node.js";
class NodeVersion {
    constructor(version, majorVersion) {
        this.version = version;
        this.majorVersion = majorVersion;
    }
}
class NodeChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async getInstallationInfo() {
        try {
            const supportedVersions = await this.getSupportedVersions();
            this._logger.debug(`NodeChecker checking for supported versions: '${JSON.stringify(supportedVersions)}'`);
            const currentVersion = await getInstalledNodeVersion();
            if (currentVersion === null) {
                this._telemetry.sendUserErrorEvent(telemetry_1.DepsCheckerEvent.nodeNotFound, "Node.js can't be found.");
                const error = new depsError_1.NodeNotFoundError(message_1.Messages.NodeNotFound.split("@NodeVersion").join(supportedVersions[supportedVersions.length - 1]), this._nodeNotFoundHelpLink);
                return await this.getDepsInfo(false, undefined, error);
            }
            this._telemetry.sendEvent(telemetry_1.DepsCheckerEvent.nodeVersion, {
                "global-version": `${currentVersion.version}`,
                "global-major-version": `${currentVersion.majorVersion}`,
            });
            if (!NodeChecker.isVersionSupported(supportedVersions, currentVersion)) {
                const supportedVersionsString = supportedVersions.map((v) => "v" + v).join(" ,");
                this._telemetry.sendUserErrorEvent(this._nodeNotSupportedEvent, `Node.js ${currentVersion.version} is not supported.`);
                const error = new depsError_1.NodeNotSupportedError(message_1.Messages.NodeNotSupported.split("@CurrentVersion")
                    .join(currentVersion.version)
                    .split("@SupportedVersions")
                    .join(supportedVersionsString), await this.getNodeNotSupportedHelpLink());
                return await this.getDepsInfo(false, currentVersion.version, error);
            }
            return await this.getDepsInfo(true, currentVersion.version);
        }
        catch (error) {
            return await this.getDepsInfo(false, undefined, new depsError_1.DepsCheckerError(error.message, helpLink_1.nodeNotFoundHelpLink));
        }
    }
    async resolve() {
        const installationInfo = await this.getInstallationInfo();
        if (installationInfo.error) {
            await this._logger.printDetailLog();
            await this._logger.error(`${installationInfo.error.message}, error = '${installationInfo.error}'`);
        }
        this._logger.cleanup();
        return installationInfo;
    }
    async install() {
        return Promise.resolve();
    }
    async getDepsInfo(isInstalled, installVersion, error) {
        return {
            name: NodeName,
            type: this._type,
            isInstalled: isInstalled,
            command: await this.command(),
            details: {
                isLinuxSupported: true,
                supportedVersions: await this.getSupportedVersions(),
                installVersion: installVersion,
            },
            error: error,
        };
    }
    static isVersionSupported(supportedVersion, version) {
        return supportedVersion.includes(version.majorVersion);
    }
    async command() {
        return "node";
    }
}
exports.NodeChecker = NodeChecker;
async function getInstalledNodeVersion() {
    try {
        const output = await cpUtils_1.cpUtils.executeCommand(undefined, undefined, undefined, "node", "--version");
        return getNodeVersion(output);
    }
    catch (error) {
        return null;
    }
}
exports.getInstalledNodeVersion = getInstalledNodeVersion;
function getNodeVersion(output) {
    var _a;
    const regex = /v(?<major_version>\d+)\.(?<minor_version>\d+)\.(?<patch_version>\d+)/gm;
    const match = regex.exec(output);
    if (!match) {
        return null;
    }
    const majorVersion = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.major_version;
    if (!majorVersion) {
        return null;
    }
    return new NodeVersion(match[0], majorVersion);
}
class SPFxNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForSPFx;
        this._type = depsChecker_1.DepsType.SpfxNode;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForSPFxHelpLink;
    }
    async getSupportedVersions() {
        return ["14", "16"];
    }
}
exports.SPFxNodeChecker = SPFxNodeChecker;
class AzureNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForAzure;
        this._type = depsChecker_1.DepsType.AzureNode;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForAzureHelpLink;
    }
    async getSupportedVersions() {
        return ["14", "16"];
    }
}
exports.AzureNodeChecker = AzureNodeChecker;
class FunctionNodeChecker extends NodeChecker {
    constructor() {
        super(...arguments);
        this._nodeNotFoundHelpLink = helpLink_1.nodeNotFoundHelpLink;
        this._nodeNotSupportedEvent = telemetry_1.DepsCheckerEvent.nodeNotSupportedForAzure;
        this._type = depsChecker_1.DepsType.FunctionNode;
    }
    async getNodeNotSupportedHelpLink() {
        return helpLink_1.nodeNotSupportedForFunctionsHelpLink;
    }
    async getSupportedVersions() {
        return ["14", "16"];
    }
}
exports.FunctionNodeChecker = FunctionNodeChecker;
//# sourceMappingURL=nodeChecker.js.map